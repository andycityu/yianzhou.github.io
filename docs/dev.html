<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-dev docs-doc-id-computer-network">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Computer Network | yianzhou</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://yianzhou.github.io/docs/dev"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-dev-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-dev-current"><meta data-rh="true" property="og:title" content="Computer Network | yianzhou"><meta data-rh="true" name="description" content="Welcome to the student resources for the Computer Networking: A Top-Down Approach Sixth Edition Companion Website."><meta data-rh="true" property="og:description" content="Welcome to the student resources for the Computer Networking: A Top-Down Approach Sixth Edition Companion Website."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://yianzhou.github.io/docs/dev"><link data-rh="true" rel="alternate" href="https://yianzhou.github.io/docs/dev" hreflang="en"><link data-rh="true" rel="alternate" href="https://yianzhou.github.io/docs/dev" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.6a91212d.css">
<link rel="preload" href="/assets/js/runtime~main.c41fd4f7.js" as="script">
<link rel="preload" href="/assets/js/main.71c80274.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="yianzhou" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="yianzhou" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">yianzhou</b></a><a class="navbar__item navbar__link" href="/docs/apple">Apple</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/dev">开发</a><a class="navbar__item navbar__link" href="/docs/language">编程语言</a><a class="navbar__item navbar__link" href="/docs/flutter">Flutter</a><a class="navbar__item navbar__link" href="/docs/insights">Insights</a><a class="navbar__item navbar__link" href="/docs/codes">Codes</a><a class="navbar__item navbar__link" href="/docs/ai">AI</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yianzhou/yianzhou.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/agile">敏捷开发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/algorithm">数据结构与算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/android">Android</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/btw">BTW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/bugs">Bugs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/centos-setup">CentOS 7 配置</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/chrome">Chrome</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/dev">Computer Network</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/computer-science">计算机科学</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/courses">课程表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/cryptography">加解密与数字签名</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/css">CSS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/design-pattern">设计模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/faq">常见问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/gRPC">gRPC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/git">Git</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/google">Google</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/dev/leetcode/leetcode1">leetcode</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/machine-learning">Machine Learning</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/macos">macOS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/nqe">Network Quality Estimator</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/os">操作系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/react">React</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/server">快速创建本地服务器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/vscode">VSCode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/wasm">WASM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/数据可视化">数据可视化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev/日志">日志</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Computer Network</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Computer Network</h1><blockquote><p><a href="https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/index.html" target="_blank" rel="noopener noreferrer">Welcome to the student resources for the Computer Networking: A Top-Down Approach Sixth Edition Companion Website.</a></p><p><a href="https://gaia.cs.umass.edu/kurose_ross/interactive/" target="_blank" rel="noopener noreferrer">INTERACTIVE END-OF-CHAPTER EXERCISES, Supplement to Computer Networking: A Top Down Approach 8th Edition</a></p><p><a href="https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198702.cw/index.html" target="_blank" rel="noopener noreferrer">Interactive Animations</a></p><p><a href="https://quic.xargs.org/" target="_blank" rel="noopener noreferrer">The Illustrated QUIC Connection: Every Byte Explained</a>（QUIC 协议图解）</p><p><a href="https://baida.dev/articles/https-explained-with-carrier-pigeons" target="_blank" rel="noopener noreferrer">Baida | HTTPS explained with carrier pigeons</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="computer-network-and-internet">Computer Network and Internet<a href="#computer-network-and-internet" class="hash-link" aria-label="Direct link to Computer Network and Internet" title="Direct link to Computer Network and Internet">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="network-edge">Network Edge<a href="#network-edge" class="hash-link" aria-label="Direct link to Network Edge" title="Direct link to Network Edge">​</a></h3><p>因特网是世界范围的计算机网络。传统的桌面 PC、Linux 工作站、服务器，以及新兴的手机、家用电器、可穿戴设备等正在与因特网相连。这些设备被称为主机 (host)，主机又可分为两类：客户端和服务器；因主机运行在网络边缘 (network edge)，故又称为端系统 (end system)。</p><p>Access network—the network that physically connects an end system to the first router.</p><ul><li>家庭入网过去用的是 DSL (Digital Subscriber Line)，DSL modem 得到数字信息后将其转换为高频信号，通过电话线（即双绞铜线）与电话公司的 DSLAM 交换数据，并在那里被转换回数字形式。电话线通过“频分复用技术”形成了双向电话信道（0 - 4kHz）、中速上行信道（4kHz - 50kHz）、高速下行信道（50kHz - 1MHz）。使得电话呼叫和因特网连接能同时进行。</li><li>另一种家庭入网是同轴电缆 (cable) 接入，利用了有线电视公司的基础设施。家庭先通过同轴电缆接入到地区的光纤节点，再通过光纤连接到有线电视公司。这种入网要用到 cable modem，同 DSL modem 一样将信号进行数模转换。</li><li>现在更多的家庭享受到了光纤入户 (Fiber To The Home, FTTH)，用户在家中将无线路由器与 ONT (Optical Network Terminator) 相连，多个家庭的 ONT 通过光纤连接到临近的分配器 (splitter)，再通过一根共享的光纤连接到本地中心局的 OLT (Optical Line Terminator)。OLT 提供了光信号和电信号之间的转换。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="network-core">Network Core<a href="#network-core" class="hash-link" aria-label="Direct link to Network Core" title="Direct link to Network Core">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="packet-switching">Packet Switching<a href="#packet-switching" class="hash-link" aria-label="Direct link to Packet Switching" title="Direct link to Packet Switching">​</a></h4><p>网络核心是由通信链路 (communication link) 和分组交换机 (packet switch) 构成的网状网络。端系统彼此交换报文 (message)。长的报文被划分成分组 (packet)，分组通过网络核心传送。</p><p>通信链路由不同的物理媒体组成，包括同轴电缆、双绞铜线、光纤、无线电频谱等。链路的传输速率以 bit/s 度量。假设链路的传输速率是 R bits/s，经过一条链路发送 L bits 的 packet，传输时间应为 L/R 秒。</p><p>Packet switch 最著名的两种类型是路由器 (router) 和链路层交换机 (link-layer switch)。</p><p>Packet 在传输的路径上的<strong>每个节点</strong>都要经历几种不同类型的时延。</p><p><strong>节点处理时延 (nodal processing delay)</strong>：检查 packet 的头部并决定将该 packet 导向何处。</p><p><strong>排队时延 (queuing delay)</strong>：对于每一条连接到 packet switch 上的链路，都有一个对应的输出缓存 (output buffer)，它用于存储准备发往那条链路的 packet。如果该链路正忙于传输，则到达路由器的 packet 必须在输出缓存中等待，这就造成了排队时延。如果输出缓存已满，那么在新的 packet 到达时就会有 packet 被丢弃，造成丢包。</p><p><img loading="lazy" alt="img" src="/assets/images/3CA03F1B-4719-4E90-977E-849FCD857DBB-1ae452fbac2b52f2b062aafca2ec59e6.jpg" width="558" height="356" class="img_ev3q"></p><p><strong>传输时延 (transmission delay)</strong>：L/R，这是将一个 packet 的所有比特推向链路的时间，传输时延的原因是存储转发机制。</p><p>多数 packet switch 在链路的输入端使用存储转发传输 (store-and-forward transmission)，这是指 packet switch 在开始向输出链路传输 packet 的第一个比特之前，必须收到整个 packet。</p><p>为了理解这一机制，考虑两个端系统经一台路由器连接构成的简单网络，Source 在时刻 0 开始传输，经过 L/R 秒，路由器接受到整个 packet，并且开始向出链路传输，在时刻 2L/R 整个 packet 到达目的地，所以总时延是 2L/R。如果 packet switch 不使用存储转发机制，而是每到达一个比特就直接转发，那么总时延将会是 L/R。</p><p><img loading="lazy" alt="img" src="/assets/images/1A46D224-C9F6-41C8-88A9-E2612F154B7F-160ab0ee2538f433aa3a1835862b96c7.jpg" width="540" height="224" class="img_ev3q"></p><p>一般地，通过由 N 条速率均为 R 的链路组成的路径（代表有 N - 1 台路由器），端到端的存储转发时延是 <code>d = N * L / R</code>。</p><p><strong>传播时延 (propagation delay)</strong>：一旦一个比特被推向链路，它就会向下一个节点传播，这是一个比特从路由器 A 的出口到路由器 B 的入口所需要的时间。传播速率取决于该链路的物理媒体。</p><p>下面一张图概括了路由器 A 的节点总时延 (total nodal delay)：</p><p><img loading="lazy" alt="img" src="/assets/images/5A9F468D-F161-4FC4-B691-1FFC1C06B953-4b9a1697185f1165cce4676075c0aab4.jpg" width="613" height="266" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="circuit-switching">Circuit Switching<a href="#circuit-switching" class="hash-link" aria-label="Direct link to Circuit Switching" title="Direct link to Circuit Switching">​</a></h4><p>Circuit Switching 必须在发送方和接收方之间建立一条连接，该连接被称为一条电路 (circuit)，它路径上的交换机都要为该连接维护必要的状态。Circuit 预留了恒定的传输速率，以确保发送方能够以恒定速率向接收方传送数据。（类比固定电话之间的通话）</p><p>与之相反，packet switching 不预留任何链路资源，因特网尽最大努力交付 packet 但不做任何保证。（类比微信语音通话）</p><p>Circuit Switching 需要预先分配资源，已分配而没有用上的链路时间就被浪费掉了；Packet Switching 则可以按需共享链路传输能力。今天的电信网络正在朝 Packet switching 发展，特别是，电话网经常在昂贵的海外电话部分使用 Packet Switching。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="internet-service-provider">Internet Service Provider<a href="#internet-service-provider" class="hash-link" aria-label="Direct link to Internet Service Provider" title="Direct link to Internet Service Provider">​</a></h3><p>端系统要通过 ISP (Internet Service Provider) 接入因特网。Access ISPs 的类型多种多样，包括住宅 ISP、公司 ISP、大学 ISP、咖啡厅或医院等公共场所的 ISP……</p><p>在中国，每个城市有 Access ISPs，它们与省级 ISP 连接，再与国家级 ISP 连接，最终与 tier-1 ISP 连接；在此基础上，再加上 PoPs (Point of Presence)、multi-homing、peering、IXPs (Internet exchange points)、内容提供商网络 (content provider network) ，构成了今天的因特网结构。</p><p><img loading="lazy" alt="img" src="/assets/images/7182E1A1-1964-4FFD-8AC9-659F8101715C-d30d4a8b45fea1dc631ef79e6042db71.jpg" width="681" height="358" class="img_ev3q"></p><p>总之，今天的因特网是一个网络的网络，结构非常复杂，由十多个 tier-1 ISP 和数十万个较低层 ISP 组成。用户和内容提供商是较低层 ISP 的客户，低层 ISP 是高层 ISP 的客户。例如谷歌通过创建自己的网络和数据中心，直接在可能的地方与低层 ISP 互联。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="protocol-layers">Protocol Layers<a href="#protocol-layers" class="hash-link" aria-label="Direct link to Protocol Layers" title="Direct link to Protocol Layers">​</a></h3><p>网络设计者以分层的方式组织协议、并实现这些协议的网络硬件和软件。一个 layer 会使用它下层的服务，并同时向上层提供服务 (service model)。</p><p>各层的所有协议被称为协议栈 (protocol stack)，因特网的协议栈由 5 个层次组成：物理层、链路层、网络层、运输层、应用层。</p><p>传输层负责进程到进程的传送；网络层负责主机到主机的传送；链路层负责将帧从一个节点移动到邻近的下一个节点；物理层负责将帧中的每一个比特从一个节点移动到下一个节点。</p><p><img loading="lazy" alt="img" src="/assets/images/8399A4F3-9540-4485-A26D-2747A1DC4BAF-d5bf8d06e0a7d4eee534c8d7d5bf1808.jpg" width="857" height="601" class="img_ev3q"></p><p>上图显示了这样一条路径：数据从源的协议栈一路向下、经过中间的链路层交换机和路由器的协议栈上上下下、最后向上到达目的地的协议栈。注意，路由器实现了第一层到第三层协议，而链路层交换机只实现了前二层。这意味着路由器能够实现 IP 协议，但链路层交换机不能，因此它不能识别 IP 地址，但它能够识别第二层地址如 Ethernet 地址。如上图所示，packet 到达每一层，都会被附加上该层的首部字段（用字母 H 表示），首部字段会在之后被相应的层使用。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="application-layer">Application Layer<a href="#application-layer" class="hash-link" aria-label="Direct link to Application Layer" title="Direct link to Application Layer">​</a></h2><p>在同一个端系统上的进程，它们使用 IPC 相互通信，规则由操作系统确定；在两个不同端系统上的进程，通过跨越计算机网络交换 message 而相互通信。</p><p>不管是 client-server architecture 还是 P2P architecture，对每对通信进程，我们把主动发起通信方称为客户端，被动等待联系方称为服务器。在 P2P architecture 中，一个进程既能够是客户端又能够是服务器。</p><p>进程通过一个称为 socket 的软件接口发送和接收 message。</p><p>在因特网中，目的地主机由 IP 地址标识；接收进程由端口号标识。</p><p>开发一个应用时，必须选择一种运输层协议，如何选择呢？大体从可靠数据传输、吞吐量、时效性和安全性几个方面考虑。如电子邮件、Web 文档这类应用，必须保证可靠数据传输（不能丢失数据）、对吞吐量无要求、对响应时间不敏感；流媒体、视频通话、游戏等应用，则可以容忍丢包、但对带宽有要求、对响应时间敏感。</p><p>TCP 为应用层提供了面向连接的、可靠数据传输服务，还具有拥塞控制机制；UDP 是一种“仅提供最小服务”的传输层协议，它不提供可靠数据传输服务，不保证 message 能到达、能有序到达接收进程。</p><p>TCP 和 UDP 本身都没有提供安全性相关的服务，但 TCP <strong>在应用层</strong>可以用 SSL 来提供安全服务。除了可靠数据传输和安全性，目前的因特网运输协议并不能提供吞吐量和时效性的保证。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-web-and-http">The Web and HTTP<a href="#the-web-and-http" class="hash-link" aria-label="Direct link to The Web and HTTP" title="Direct link to The Web and HTTP">​</a></h3><p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web’s application-layer protocol, is at the heart of the Web.</p><p>A Web page (also called a document) consists of objects. An <strong>object</strong> is simply a file—such as an HTML file, a JPEG image, a Javascrpt file, or a video clip—that is addressable by a single URL. Most Web pages consist of a base HTML file and several referenced objects.</p><p>HTTP defines how Web clients (Web browsers) request Web pages from Web servers (e.g. Apache) and how servers transfer Web pages to clients.</p><p>It is important to note that the server sends requested files to clients without storing any state information about the client. If a particular client asks for the same object twice in a period of a few seconds, the server does not respond by saying that it just served the object to the client; instead, the server resends the object, as it has completely forgotten what it did earlier. Because an HTTP server maintains no information about the clients, HTTP is said to be a stateless protocol.</p><p>为什么说 HTTP 是无状态的？原因是 HTTP 协议不要求服务器保存用户的任何信息和状态。对于每个请求，服务端都把它当作新的、陌生的请求来处理。虽然协议本身无状态，但可以通过使用 cookie 来追踪用户的信息。</p><p>HTTP 在默认方式下使用持续连接 (persistent connection)，意味着客户端和服务器在一个长的时间范围内通信时，客户端一系列的请求及服务端的响应，都经同一个 TCP 连接发送。</p><p>非持续连接有这样一些缺点：第一，必须为每一个对象的请求建立和维护一个全新的 TCP 连接。这意味着，在客户端和服务器中都要分配 TCP 的缓冲区、保持 TCP 的变量；第二，每请求一个对象都要经历 2 RTTs，即 1 RTT 用于创建 TCP 连接，1 RTT 用于请求和接收对象。</p><p>With HTTP/1.1 persistent connections, the server leaves the TCP connection open after sending a response. Subsequent requests and responses between the same client and server can be sent over the same connection. In particular, an entire Web page (in the example above, the base HTML file and the 10 images), moreover, multiple Web pages residing on the same server can be sent from the server to the same client over a single persistent TCP connection. These requests for objects can be made back-to-back, without waiting for replies to pending requests (called <strong>pipelining</strong>). Typically, the HTTP server closes a connection when it isn’t used for a certain time (a configurable timeout interval). When the server receives the back-to-back requests, it sends the objects back-to-back.<strong>（大部分浏览器禁用了 pipelining，详见下文）</strong></p><p>Suppose within your Web browser you click on a link to obtain a Web page. Further suppose that the Web page associated with the link contains exactly one object, consisting of a small amount of HTML text. Assuming zero transmission time of the object, how much time elapses from when the client clicks on the link until the client receives the object? -- 1RTT elapses to set up the TCP connection and another 1RTT elapses to request and receive the small object.</p><p>Suppose the HTML file references 8 very small objects on the same server,</p><ul><li>Non-persistent HTTP with no parallel TCP connections: 2RTT + 8<!-- -->*<!-- -->2RTT</li><li>Non-persistent HTTP with the browser configured for 6 parallel connections: 2RTT + 2<!-- -->*<!-- -->2RTT</li><li>Persistent connection with pipelining: 2RTT + RTT</li><li>Persistent connection without pipelining, without parallel connections: 2RTT + 8<!-- -->*<!-- -->RTT</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http-message-format">HTTP Message Format<a href="#http-message-format" class="hash-link" aria-label="Direct link to HTTP Message Format" title="Direct link to HTTP Message Format">​</a></h3><p>There are two types of HTTP messages, request messages and response messages.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="request-message">Request Message<a href="#request-message" class="hash-link" aria-label="Direct link to Request Message" title="Direct link to Request Message">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">GET /cs453/index.html HTTP/1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Host: gaia.cs.umass.edu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">User-agent: Mozilla/5.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept-Language: en-us,en;q=0.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept-Encoding: zip,deflate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Keep-Alive: 300</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Connection: keep-alive</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The first line of an HTTP request message is called the <strong>request line</strong>. The request line has three fields: the method field, the URL field, and the HTTP version field. The subsequent lines are called the <strong>header lines</strong>.</p><p>The header line <code>Host: gaia.cs.umass.edu</code> specifies the host on which the object resides. You might think that this header line is unnecessary, as there is already a TCP connection in place to the host. But, as we’ll see in Section 2.2.5, the information provided by the host header line is required by Web proxy caches.</p><p>The <code>Accept-language:</code> header is just one of many content negotiation headers available in HTTP.</p><p>The browser is requesting a persistent connection, as indicated by the <code>Connection: keep-alive</code>.</p><p>下面是请求报文的通用格式：</p><p><img loading="lazy" alt="img" src="/assets/images/636E8239-B438-48B9-82C4-4B7219C4B65C-69fcf662604386f2efd787789f909274.jpg" width="649" height="391" class="img_ev3q"></p><p>After the header lines (and the additional carriage return 回车 and line feed 换行) there is an “entity body.” The entity body is empty with the GET method, but is used with the POST method. If the value of the method field is POST, then the entity body contains what the user entered into the form fields.</p><p>A request generated with a form does not necessarily use the POST method. Instead, HTML forms often use the GET method and include the inputted data (in the form fields) in the requested URL.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-message">Response Message<a href="#response-message" class="hash-link" aria-label="Direct link to Response Message" title="Direct link to Response Message">​</a></h4><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HTTP/1.1 200 OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date: Tue, 18 Aug 2015 15:44:04 GMT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Server: Apache/2.2.3 (CentOS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Length: 6821</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ETag: &quot;526c3-f22-a88a4c80&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Accept-Ranges: bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Keep-Alive: timeout=max=100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Connection: Keep-Alive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content-Type: text/html; charset=ISO-8859-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(data data data data data ...)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It has three sections: an initial <strong>status line</strong>, <strong>header lines</strong>, and then the <strong>entity body</strong>.</p><p>The status line has three fields: the protocol version field, a status code, and a corresponding status message.</p><p>常见的状态码包括：</p><table><thead><tr><th>Status code</th><th>说明</th></tr></thead><tbody><tr><td>200 OK</td><td>请求成功</td></tr><tr><td>301 Moved Permanently</td><td>请求的对象被永久转移了，Client 将自动获取新 URL（位于响应报文的 <code>Location:</code> header line）</td></tr><tr><td>400 Bad Request</td><td>一个通用错误码，表示该请求不能被服务器理解</td></tr><tr><td>404 Not Found</td><td>被请求的文档不存在服务器上</td></tr><tr><td>505 HTTP Version Not Supported</td><td>服务器不支持请求报文使用的 HTTP 协议版本</td></tr></tbody></table><p>For the header lines:</p><ul><li>The <code>Date:</code> header line indicates the time and date when the HTTP response was created and sent by the server.</li><li>The <code>Last-Modified:</code> header line indicates the time and date when the object was created or last modified. It is critical for object caching, both in the local client and in proxy servers.</li><li>The <code>Content-Length:</code> header line indicates the number of bytes in the object being sent.</li><li>The <code>Content-Type:</code> header line indicates that the object in the entity body is HTML text. (The object type is officially indicated by the <code>Content-Type:</code> header and not by the file extension.)</li><li>Either the client or the server can indicate to the other that it is going to close the persistent connection. It does so by including the header line <code>Connection: close</code> of the http request/reply.</li></ul><p>HTTP 规范定义了许多的 header lines，header lines 可以被浏览器、服务器、代理服务器插入。这里提到的只是一小部分。</p><p>The entity body is the meat of the message—it contains the requested object itself (represented by data ...).</p><p>下面是响应报文的通用格式：</p><p><img loading="lazy" alt="img" src="/assets/images/EA05AE9A-A41A-4AE1-A1E3-48D1E6A8AC03-1677963bd4e034b25833cc8955dec270.jpg" width="653" height="385" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cookie">Cookie<a href="#cookie" class="hash-link" aria-label="Direct link to Cookie" title="Direct link to Cookie">​</a></h3><p>We mentioned above that an HTTP server is stateless. This simplifies server design and has permitted engineers to develop high-performance Web servers that can handle thousands of simultaneous TCP connections. However, it is often desirable for a Web site to identify users, because it wants to serve content as a function of the user identity. For this purpose, HTTP uses cookies. Cookies allow sites to keep track of users.</p><p>Cookie technology has four components:</p><ol><li>A cookie header line in the HTTP response message;</li><li>A cookie header line in the HTTP request message;</li><li>A cookie file kept on the user’s end system and managed by the user’s browser;</li><li>A back-end database at the Web site.</li></ol><p><img loading="lazy" alt="img" src="/assets/images/AD027E75-A0DC-49C4-ADCF-611BD0BE7459-60b2a1fac5cab0b21de463576495f152.jpg" width="845" height="802" class="img_ev3q"></p><p>When Susan’s browser receives the HTTP response message, it sees the <code>Set-cookie:</code> header. The browser then appends a line to the special cookie file that it manages. This line includes the hostname of the server and the identification number in the <code>Set-cookie:</code> header.</p><p>We see that cookies can be used to identify a user. The first time a user visits a site, the user can provide a user identification. During the subsequent sessions, the browser passes a cookie header to the server, thereby identifying the user to the server. Cookies can thus be used to create a user session layer on top of stateless HTTP.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="web-caching-and-the-conditional-get">Web Caching and The Conditional GET<a href="#web-caching-and-the-conditional-get" class="hash-link" aria-label="Direct link to Web Caching and The Conditional GET" title="Direct link to Web Caching and The Conditional GET">​</a></h3><p>A <strong>Web cache</strong>—also called a <strong>proxy server</strong>—is a network entity that satisfies HTTP requests on the behalf of an origin Web server.</p><p>Web 缓存器有自己的磁盘存储空间，保存最近请求过的对象的副本。可以配置用户的浏览器，使得用户的所有 HTTP 请求首先指向 Web 缓存器。注意 Web cache 既是客户又是服务器。</p><p><img loading="lazy" alt="img" src="/assets/images/E14F3F02-2CA7-43D9-94C9-8AF9913719FC-7380e9ec9784eb870638515a6c6985ab.jpg" width="574" height="357" class="img_ev3q"></p><p>Web 缓存器通常由 ISP 购买并安装。例如，一所大学可能在它的校园网安装 Web cache，并且将所有校园网上的用户浏览器配置为指向它。</p><p>在因特网上部署 Web cache 有两个原因。首先，Web cache 可以大大减少客户请求的响应时间；其次，Web 缓存器能够大大减少一个机构的接入链路到因特网的通信量，通过减少通信量，该机构就不必急于增加带宽，因此降低了费用。此外，Web 缓存器能从整体上大大减低因特网上的 Web 流量，从而改善了所有应用的性能。</p><p>通过使用内容分发网络 (Content Distribution Network, CDN)，Web cache 正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理上分散的缓存器，使大量流量实现了本地化。</p><p>Web cache 可以大大减少对客户请求的响应时间，但也引入了一个新的问题，即存放在 Web cache 中的对象副本可能是陈旧的。HTTP 协议有一种机制，允许 Web cache 证实它的对象是最新的，即 conditional GET。如果请求报文使用 GET 方法、并且请求报文中包含一个 <code>If-Modified-Since:</code> 的 header line，那么，这个 HTTP 请求报文就是一个条件 GET 请求报文。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http2">HTTP/2<a href="#http2" class="hash-link" aria-label="Direct link to HTTP/2" title="Direct link to HTTP/2">​</a></h3><p>HTTP/2 <!-- -->[RFC 7540]<!-- -->, standardized in 2015, was the first new version of HTTP since HTTP/1.1, which was standardized in 1997.</p><p>The primary goals for HTTP/2 are to reduce perceived latency by enabling request and response multiplexing over a single TCP connection, provide request prioritization and server push, and provide efficient compression of HTTP header fields.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="hol-blocking-and-http2-framing">HOL Blocking and HTTP/2 Framing<a href="#hol-blocking-and-http2-framing" class="hash-link" aria-label="Direct link to HOL Blocking and HTTP/2 Framing" title="Direct link to HOL Blocking and HTTP/2 Framing">​</a></h4><p>Developers of Web browsers discovered that sending all the objects in a Web page over a single TCP connection has a <strong>Head of Line (HOL) blocking</strong> problem. To understand HOL blocking, consider a Web page that includes an HTML base page, a large video clip near the top of Web page, and many small objects below the video. Using a single TCP connection, the video clip will take a long time to pass through the link, while the small objects are delayed as they wait behind the video clip; that is, the video clip at the head of the line blocks the small objects behind it.</p><p>HTTP/1.1 browsers typically work around this problem by opening multiple parallel TCP connections, thereby having objects in the same web page sent in parallel to the browser. This way, the small objects can arrive at and be rendered in the browser much faster, thereby reducing user-perceived delay.</p><p>TCP congestion control also provides browsers an unintended incentive 动机 to use multiple parallel TCP connections rather than a single persistent connection. Very roughly speaking, TCP congestion control aims to give each TCP connection sharing a bottleneck link an equal share of the available bandwidth of that link. By opening multiple parallel TCP connections to transport a single Web page, the browser can “cheat” and grab a larger portion of the link bandwidth. Many HTTP/1.1 browsers open up to six parallel TCP connections not only to circumvent HOL blocking but also to obtain more bandwidth.</p><p>One of the primary goals of HTTP/2 is to get rid of (or at least reduce the number of) parallel TCP connections for transporting a single Web page. This not only reduces the number of sockets that need to be open and maintained at servers, but also allows TCP congestion control to operate as intended.</p><p>The HTTP/2 solution for HOL blocking is to break each message into small <strong>frames</strong>, and interleave the request and response messages on the same TCP connection. The HTTP/2 framing mechanism can significantly decrease user-perceived delay.</p><p><img loading="lazy" alt="img" src="/assets/images/2dcd5341-c392-49b1-b2ee-3eb7e357af2f-3eb08c8fd9b81d7edc2a868e3ea51511.png" width="2205" height="1384" class="img_ev3q"></p><blockquote><p><a href="https://developer.apple.com/videos/play/wwdc2015/711/" target="_blank" rel="noopener noreferrer">WWDC 2015 - Networking with NSURLSession</a></p></blockquote><p>The ability to break down an HTTP message into independent frames, interleave them, and then reassemble them on the other end is the single most important enhancement of HTTP/2. The framing is done by the framing sub-layer of the HTTP/2 protocol. When a server wants to send an HTTP response, the response is processed by the framing sub-layer, where it is broken down into frames. The header field of the response becomes one frame, and the body of the message is broken down into one for more additional frames. The frames of the response are then interleaved by the framing sub-layer in the server with the frames of other responses and sent over the single persistent TCP connection. As the frames arrive at the client, they are first reassembled into the original response messages at the framing sub-layer and then processed by the browser as usual. Similarly, a client’s HTTP requests are broken into frames and interleaved.</p><p>In addition to breaking down each HTTP message into independent frames, the framing sublayer also binary encodes the frames. Binary protocols are more efficient to parse, lead to slightly smaller frames, and are less error-prone.</p><blockquote><p><a href="https://community.akamai.com/customers/s/article/How-does-HTTP-2-solve-the-Head-of-Line-blocking-HOL-issue?language=en_US" target="_blank" rel="noopener noreferrer">How does HTTP/2 solve the Head of Line blocking (HOL) issue</a></p></blockquote><p>HTTP/1.1 introduced a feature called &quot;Pipelining&quot; which allowed a client sending several HTTP requests back-to-back over the same TCP connection. However HTTP/1.1 still required the responses to arrive in order so it didn&#x27;t really solved the HOL issue and as of today it is not widely adopted. <strong>In fact, it’s disabled on most popular desktop web browsers</strong>.</p><p>HTTP/2 solves the HOL issue by means of multiplexing requests over the same TCP connection, so a client can make multiple requests to a server without having to wait for the previous ones to complete as the responses can arrive in any order.</p><p>HTTP/2 does however still suffer from another type of HOL, as it runs over a TCP connection; and due to TCP&#x27;s congestion control, one lost packet in a TCP stream makes all streams wait until that package is re-transmitted and received. This HOL is being addressed with the QUIC protocol.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="header-compression-hpack">Header compression (HPACK)<a href="#header-compression-hpack" class="hash-link" aria-label="Direct link to Header compression (HPACK)" title="Direct link to Header compression (HPACK)">​</a></h4><p>HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</p><p>HPACK header compression is based on two tables, a static table and a dynamic table. The static table contains the most used HTTP headers and is unchangeable. The headers, which are not included in the static table, can be added to the dynamic table. The headers from the tables can be referenced by index.</p><p><img loading="lazy" alt="img" src="/assets/images/b36ec106-6902-449e-a5af-962988445beb-192af444bf714a77d82f60ada3308629.png" width="2177" height="1326" class="img_ev3q"></p><p>In this example, we need three bytes for the first three headers, plus an additional byte, which tells that we want to add the authority header to the dynamic table and the value of the authority with its length.
And this is what is going to be sent to the server plus additional overhead for the header frame.</p><p>Now with the second request,（当我们再次请求时）HTTP/1.1 would send the same headers over and over again (textual protocol overhead). But you see that, in HTTP/2 case, the authority header goes in the dynamic table, we can reference all the headers using the static and the dynamic table. We are using only one byte for each header.</p><p><img loading="lazy" alt="img" src="/assets/images/e1531839-a9e8-43b6-aeeb-6743e1f210ed-23b31ebde22f01f0a1690b6c795603bb.png" width="2196" height="1322" class="img_ev3q"></p><p>It is a huge savings of the bandwidth and it&#x27;s remarkable how few bytes are needed to encode a request or response header in HTTP/2.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-message-prioritization">Response Message Prioritization<a href="#response-message-prioritization" class="hash-link" aria-label="Direct link to Response Message Prioritization" title="Direct link to Response Message Prioritization">​</a></h4><p>Message prioritization allows developers to customize the relative priority of requests to better optimize application performance. When a client sends concurrent requests to a server, it can prioritize the responses it is requesting by assigning a weight between 1 and 256 to each message. The higher number indicates higher priority. In addition to this, the client also states each message’s dependency on other messages by specifying the ID of the message on which it depends.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="server-pushing">Server Pushing<a href="#server-pushing" class="hash-link" aria-label="Direct link to Server Pushing" title="Direct link to Server Pushing">​</a></h4><p>Another feature of HTTP/2 is the ability for a server to send multiple responses for a single client request. That is, in addition to the response to the original request, the server can push additional objects to the client, without the client having to request each one. This is possible since the HTML base page indicates the objects that will be needed to fully render the Web page. So instead of waiting for the HTTP requests for these objects, the server can analyze the HTML page, identify the objects that are needed, and send them to the client before receiving explicit requests for these objects. Server push eliminates the extra latency due to waiting for the requests.</p><p><img loading="lazy" alt="img" src="/assets/images/137c36ad-e563-4db2-a3e5-4d0a8675b59e-47e50fb5df17ff3f945a0c363673dbe9.png" width="2300" height="1374" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="http3">HTTP/3<a href="#http3" class="hash-link" aria-label="Direct link to HTTP/3" title="Direct link to HTTP/3">​</a></h3><p>Both HTTP/1.1 and HTTP/2 use TCP as their transport. QUIC, is a new protocol that is implemented in the application layer over the bare-bones UDP protocol. QUIC has several features that are desirable for HTTP, such as message multiplexing (interleaving), per-stream flow control, and low-latency connection establishment. QUIC is implemented over UDP where each stream is independent so that a lost packet only halts the particular stream to which the lost packet belongs, while the other streams can go on.</p><p>HTTP/3 is yet a new HTTP protocol that is designed to operate over QUIC. Many of the HTTP/2 features (such as message interleaving) are subsumed by QUIC, allowing for a simpler, streamlined design for HTTP/3.</p><p>HTTP/3 has TLS 1.3 security built right in and provides all the same multiplexed stream support as HTTP/2, but with further reductions to head-of-line blocking so that losses of any individual request or response won&#x27;t hold up other potentially unrelated messages.</p><p>HTTP/3 also has higher fidelity information to provide improved congestion control and recovery of lost packets.</p><p>HTTP/3 also brings built-in mobility support such that network transitions don&#x27;t cause in-progress operations to fail. They can instead seamlessly continue on the new network without interruption.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="email">Email<a href="#email" class="hash-link" aria-label="Direct link to Email" title="Direct link to Email">​</a></h3><p>Suppose Alice, with a Web-based e-mail account (such as Hotmail or Gmail), sends a message to Bob. The message is first sent from Alice’s browser to her mail server over <strong>HTTP(S)</strong>. Alice’s mail server then sends the message to Bob’s mail server over <strong>SMTP</strong>. Bob then transfers the message from his mail server to his host over <strong>POP3</strong>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dns">DNS<a href="#dns" class="hash-link" aria-label="Direct link to DNS" title="Direct link to DNS">​</a></h3><p>一个 IP 地址由 4 个字节组成，例如 <code>121.7.106.83</code>，每个字节表示 0-255 的十进制数字。在因特网中，Host name 和 IP 地址都可以用来识别主机。人们在浏览器中习惯输入 host name，而路由器则喜欢定长的、有层次结构的 IP 地址。因此，我们需要有一种能进行主机名到 IP 地址转换的目录服务，这就是域名系统 (Domain Name System, DNS) 的主要任务。</p><p>DNS 有两层含义：1<!-- -->.<!-- --> 一个由分层的 DNS 服务器实现的分布式数据库；2<!-- -->.<!-- --> 一个使端系统能够查询分布式数据库的应用层协议。DNS 协议运行在 UDP 之上，使用 53 号端口。</p><p>DNS 请求为因特网应用带来了额外的时延，幸运的是，大部分 IP 地址通常就缓存在某个“附近的” DNS 服务器中。</p><p>除了主机名到 IP 地址的转换之外，DNS 还提供了以下服务：</p><ul><li>主机别名 (host aliasing)。例如 <code>relay1.west-coast.enterprise.com</code> 称为规范主机名 (cannonical hostname)，它有两个别名 <code>enterprise.com</code> 和 <code>www.enterprise.com</code>。应用程序通过 DNS 服务来获得主机别名对应的规范主机名以及 IP 地址。</li><li>邮件服务器别名 (mail server aliasing)。</li><li>负载分配 (load distribution)。繁忙的站点如 <code>cnn.com</code> 被分布在多台服务器上，每个都拥有不同的 IP 地址，多个 IP 地址可以映射到同一个规范主机名。DNS 在所有这些服务器之间进行负载分配。</li></ul><p>DNS 是一个在因特网上实现分布式数据库的精彩范例。大量的 DNS 服务器以层次方式组织、分布在全世界范围内。大致上，有 3 种类型的 DNS 服务器。</p><ul><li>Root DNS servers. There are over 400 root name servers scattered all over the world. Root name servers provide the IP addresses of the TLD servers.</li><li>Top-level domain (TLD) servers. For each of the top-level domains such as com, org, net, edu, and gov, and all of the country top-level domains such as uk, fr, ca, and jp — there is TLD server (or server cluster). TLD servers provide the IP addresses for authoritative DNS servers.</li><li>Authoritative DNS servers. Every organization with publicly accessible hosts on the Internet must provide publicly accessible DNS records. An organization can choose to implement its own authoritative DNS server to hold these records; alternatively, the organization can pay to have these records stored in an authoritative DNS server of some service provider.</li></ul><p>The root, TLD, and authoritative DNS servers all belong to the hierarchy of DNS servers. There is another important type of DNS server called the <strong>local DNS server</strong>. Each ISP—such as a residential ISP or an institutional ISP—has a local DNS server.</p><p>When a host connects to an ISP, the ISP provides the host with the IP addresses of one or more of its local DNS servers (typically through DHCP). When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy, forwarding the query into the DNS server hierarchy.</p><p>如下图所示，Client 想要访问主机 <code>gaia.cs.umass.edu</code>：</p><ol><li>Client sends a DNS query message to its local DNS server.</li><li>The local DNS server forwards the query message to a root DNS server.</li><li>The root DNS server takes note of the <code>edu</code> suffix and returns a list of IP addresses for TLD servers responsible for <code>edu</code>.</li><li>The local DNS server then resends the query message to one of these TLD servers.</li><li>The TLD server takes note of the <code>umass.edu</code> suffix and responds with the IP address of the authoritative DNS server for the University of Massachusetts, namely, <code>dns.umass.edu</code>.</li><li>Finally, the local DNS server resends the query message directly to <code>dns.umass.edu</code>.</li><li>Authoritative DNS server responds with the IP address of <code>gaia.cs.umass.edu</code>.</li><li>Local DNS server responds with the IP address of <code>gaia.cs.umass.edu</code> to client.</li></ol><p><img loading="lazy" alt="img-40" src="/assets/images/e088a3e7-dabb-40f0-8a12-46816d54acf4-c55e9c9b2e8ca1cd805a75dfc35027a8.jpg" width="662" height="1005" class="img_ev3q"></p><p>实际上，为了改善时延、减少因特网上到处传输的 DNS 报文数量，DNS 广泛使用了缓存技术。缓存原理十分简单，在一个请求链中，当某 DNS 服务器接收一个响应后，它能将映射缓存在服务器本地存储中。当新的、对相同主机名的查询到达时，就能直接提供 IP 地址。由于主机名和 IP 地址之间的映射不是永久的，DNS 服务器在一段时间后将丢弃缓存的信息。</p><p>DNS 服务器上存储了资源记录 (Resource Record, RR)。RR 提供了主机名到 IP 地址的映射。每个 DNS 响应报文包含一条或多条 RR。</p><p>RR 是一个包含了下列字段的四元组：<code>(Name, Value, Type, TLL)</code>。TLL 是该记录的生存时间，它决定了 RR 应当从缓存中删除的时间。</p><ul><li>If Type=A, then Name is a hostname and Value is the IP address for the hostname. As an example, (relay1.bar.foo.com, 145.37.93.126, A) is a Type A record.</li><li>If Type=NS, then Name is a domain (such as foo.com) and Value is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain. As an example, (foo.com, dns.foo.com, NS) is a Type NS record.</li><li>If Type=CNAME, then Value is a canonical hostname for the alias hostname Name. As an example, (foo.com, relay1.bar.foo.com, CNAME) is a CNAME record.</li><li>If Type=MX, then Value is the canonical name of a mail server that has an alias hostname Name.</li></ul><p>查看当前 DNS：<code>nslookup domain</code></p><p>查询域名对应的 IP：<code>nslookup www.baidu.com</code></p><p>查询 A 记录：<code>nslookup -query=A www.baidu.com</code></p><p>查询 CNAME 记录：<code>nslookup -query=CNAME www.baidu.com</code></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="p2p">P2P<a href="#p2p" class="hash-link" aria-label="Direct link to P2P" title="Direct link to P2P">​</a></h3><p>考虑从因特网上下载一个文件。在客户-服务器文件分发中，该服务器必须向每个 peer 发送该文件的一个副本；在 P2P 文件分发中，每个 peer 能够向其他 peers 分发它已经收到的该文件的部分，从而在分发过程中协助该服务器。到 2016 年止，最为流行的 P2P 文件分发协议是 BitTorrent。</p><p>用 BitTorrent 的术语来讲，参与一个特定文件分发的所有 peers 的集合被称为一个洪流 (torrent)。在一个洪流中的 peers 彼此下载等长度的文件块 (chunk)，典型的块长度为 256KB。当一个 peer 首次加入一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他 peers 上载了多个块。一旦某个 peer 获得了整个文件，它也许（自私地）离开洪流，或继续留在该洪流中并继续向其他 peers 上载块。同时，任何 peer 可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中。</p><p>每个洪流具有一个基础设施节点，称为追踪器 (tracker)。当一个 peer 加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中。以这种方式，追踪器跟踪参与在洪流中的 peers。一个给定的洪流可能在任何时刻具有数以百计或数以千计的 peers。</p><p>当一个新的 peer，Alice 加入该洪流时，追踪器随机地从参与该洪流的 peers 集合中选择一个子集（假设选择了 50 个 peers），并将它们的 IP 地址发送给 Alice。Alice 则试图与这 50 个 peers 创建并行的 TCP 连接。随着时间的流逝，这些 peers 中的某些可能离开，其他 peers（最初 50 个以外的）也可能与 Alice 创建 TCP 连接。因此一个 peer 的 neighboring peers 将随时间而波动。</p><p>在任意时刻，每个 peer 可能具有该文件的块的子集，不同的 peers 可能具有不同的子集。Alice 周期性地经 TCP 连接询问每个 neighboring peer 它们所具有的块列表。如果 Alice 具有 L 个不同的邻居，她将获得 L 个块列表。有了这个信息，Alice 将做出两个重要决定。第一，她应当向邻居请求哪些块呢？第二，她应当向哪些向她请求块的邻居发送块呢？</p><p>在决定请求哪些块的过程中，BitTorrent 使用一种称为最稀缺优先 (rarest first) 的技术。最稀缺的块，就是那些在她的邻居中副本数量最少的块)，Alice 首先请求那些最稀缺的块。这样，最稀缺的块将得到更为迅速的重新分发，这样做的目的是大致地均衡每个块在洪流中的副本数量。</p><p>为了决定她响应哪个请求，BitTorrent 使用了一种聪明的交易算法。其基本想法是，Alice 给予当前向她提供数据的邻居中速率最高的那些以优先权。Alice 对于她的每个邻居都持续地测量接收速率，并确定流入速率最高的 4 个邻居。每过 10 秒，她重新计算该速率并可能修改这 4 个 peers 的集合，我们称这 4 个 peers 被 unchoked。重要的是，每过 30 秒，她也要随机地选择另外一个邻居（不在这 4 个 peers 里）Bob 并向其发送块。因为 Alice 正在向 Bob 发送数据，她可能成为 Bob 前 4 位上载者之一，这样的话 Bob 将开始向 Alice 发送数据。如果 Bob 向 Alice 发送数据的速率足够高，Bob 接下来也能成为 Alice 的前 4 位上载者。这种设计的效果是 peers 能够在洪流中，始终趋向于找到那些以最快速率交换文件块的邻居。对于 Alice，除了这 4 个 peers 和一个每隔一段时间就随机选择的试探性 peer，其它所有 neighboring peers 都被 choked，即它们不会从 Alice 这里接收到任何块。</p><p>BitTorrent 还有一些有趣的机制没有在这里讨论。但总体来说，BitTorrent 取得了广泛成功，它的设计使得无数个 peers 在无数个洪流中积极地共享文件。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="video-streaming">Video Streaming<a href="#video-streaming" class="hash-link" aria-label="Direct link to Video Streaming" title="Direct link to Video Streaming">​</a></h3><p>From a networking perspective, perhaps the most salient characteristic of video is its high bit rate. For example, a single 2 Mbps video with a duration of 67 minutes will consume 1 gigabyte of storage and traffic. By far, the most important performance measure for streaming video is average end-to-end throughput. In order to provide continuous playout, the network must provide an average throughput to the streaming application that is at least as large as the bit rate of the compressed video. We can also use compression to create multiple versions of the same video, each at a different quality level.</p><p>In <strong>HTTP streaming</strong>, the video is simply stored at an HTTP server as an ordinary file with a specific URL. On the client side, the bytes are collected in a client application buffer. The streaming video application periodically grabs video frames from the client application buffer, decompresses the frames, and displays them on the user’s screen.</p><p>Although HTTP streaming has been extensively deployed in practice, it has a major shortcoming: All clients receive the same encoding of the video, despite the large variations in the amount of bandwidth available to a client. This has led to the development of a new type of HTTP-based streaming, often referred to as <strong>Dynamic Adaptive Streaming over HTTP (DASH)</strong>.</p><p>In DASH, the video is encoded into several different versions, with each version having a different bit rate. Each video version is stored in the HTTP server, each with a different URL. The HTTP server also has a <strong>manifest file</strong>, which provides a URL for each version along with its bit rate. The client first requests the manifest file and learns about the various versions. The client then selects one chunk at a time by specifying a URL and a byte-range in an HTTP GET request message header for each chunk. While downloading chunks, the client also measures the received bandwidth and runs a rate determination algorithm to select the chunk to request next. Naturally, if the client has a lot of video buffered and if the measured receive bandwidth is high, it will choose a chunk from a high-bitrate version. And naturally if the client has little video buffered and the measured received bandwidth is low, it will choose a chunk from a low-bitrate version. DASH therefore allows the client to freely switch among different quality levels.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="content-distribution-networks">Content Distribution Networks<a href="#content-distribution-networks" class="hash-link" aria-label="Direct link to Content Distribution Networks" title="Direct link to Content Distribution Networks">​</a></h3><p>为了应对向分布于全世界的用户分发巨量视频数据的挑战，视频流公司都会利用内容分发网络 (Content Distribution Network, CDN)。一个 CDN 管理着分布在多个地理位置上的服务器，这些服务器上存储着视频等资源文件的副本，并且总是将每个用户请求定向到最优的 CDN 位置。CDN 可以是专用 CDN (privace CDN)，它由内容提供商私人所有；也可以是第三方 CDN (third-party CDN)，它代表多个内容提供商分发内容。</p><p>CDN 的服务器是如何部署的呢？CDNs typically adopt one of two different server placement philosophies: Enter Deep (deploying server clusters in access ISPs); Bring Home (place their clusters in IXPs).</p><p>一旦 CDN 的集群准备就绪，它就可以跨集群复制内容。CDN 不会将每个视频的副本放置在每个集群中，因为某些视频很少观看或仅在某些国家中流行。而是使用一种简单的拉策略：如果客户向一个未存储该视频的集群请求某视频，则该集群检索该视频（从某中心仓库或者从另一个集群），向客户流式传输视频时的同时、在本地存储一个副本。当某集群存储器变满时，它删除不经常请求的视频。除了拉策略，当然还有其它策略，Netflix CDN 使用 push caching 而不是 pull caching：内容在非高峰时段被推入服务器，而不是在缓存未命中时拉取。</p><p>当客户端检索某个资源时，CDN 必须截获该请求，以便能够——1<!-- -->.<!-- --> 确定此时适合用于该客户的 CDN 服务器集群；2<!-- -->.<!-- --> 将客户的请求重定向到该集群的某台服务器。大多数 CDN 利用 DNS 来截获和重定向请求。</p><p><img loading="lazy" alt="img" src="/assets/images/4d3a46f7-4960-4f27-92c1-49e317ee2c5c-37a14960e4bc3f411766cfac20afd714.jpg" width="623" height="473" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="socket-programming">Socket Programming<a href="#socket-programming" class="hash-link" aria-label="Direct link to Socket Programming" title="Direct link to Socket Programming">​</a></h3><p>Processes residing in two different end systems communicate with each other by reading from, and writing to, sockets.</p><p>网络应用程序有两类。一类是由协议标准（如一个 RFC）中所定义的操作的实现，客户端和服务端必须遵守该 RFC 的规则；另一类是专用的应用程序，其应用层协议没有公开发布在某 RFC 中或其他地方，不知道这个协议的开发者无法开发出能与之通信的应用程序。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="udp">UDP<a href="#udp" class="hash-link" aria-label="Direct link to UDP" title="Direct link to UDP">​</a></h4><p>When a socket is created, an identifier, called a <strong>port number</strong>, is assigned to it. The sending process attaches to the packet a destination address, which consists of the destination host’s IP address and the destination socket’s port number.</p><div class="language-py codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_Ktv7">client.py</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-py codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> socket </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverName </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;127.0.0.1&#x27;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverPort </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">12000</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> socket</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">AF_INET</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> SOCK_DGRAM</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">message </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token builtin">input</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;Input lowercase sentence:&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">sendto</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">message</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">encode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">serverName</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> serverPort</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 2,3</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">modifiedMessage</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> serverAddress </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">recvfrom</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">2048</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 4</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">modifiedMessage</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">close</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>[1]<!-- --> The first parameter indicates the address family; in particular, <code>AF_INET</code> indicates that the underlying network is using IPv4. The second parameter indicates that the socket is of type <code>SOCK_DGRAM</code>, which means it is a UDP socket (rather than a TCP socket).</p><p>[2]<!-- --> Note that we are not specifying the port number of the client socket when we create it; we are instead letting the operating system do this for us.</p><p>[3]<!-- --> <code>encode</code> convert the message from string type to byte type.</p><p>[4]<!-- --> The maximum amount of data to be received is specified as 2048 bytes in the buffer size.</p><div class="language-py codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_Ktv7">server.py</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-py codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> socket </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverPort </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">12000</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> socket</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">AF_INET</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> SOCK_DGRAM</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">bind</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> serverPort</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;The server is ready to receive&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">True</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    message</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> clientAddress </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">recvfrom</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">2048</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifiedMessage </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> message</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">upper</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">sendto</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">modifiedMessage</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">encode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> clientAddress</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>[1]<!-- --> <code>bind</code> binds (that is, assigns) the port number 12000 to the server’s socket. In this manner, when anyone sends a packet to port 12000 at the server, that packet will be directed to this socket.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tcp">TCP<a href="#tcp" class="hash-link" aria-label="Direct link to TCP" title="Direct link to TCP">​</a></h4><p>Unlike UDP, TCP is a connection-oriented protocol. This means that before the client and server can start to send data to each other, they first need to handshake and establish a TCP connection. After that, they just drop the data into the TCP connection via sockets. This is different from UDP, for which the server must attach a destination address to the packet before dropping it into the socket.</p><blockquote><p>What is meant by a handshaking protocol? A protocol uses handshaking if the two communicating entities first exchange control packets before sending data to each other. SMTP uses handshaking at the application layer whereas HTTP does not.</p></blockquote><p>With the server process running, the client process can initiate a TCP connection to the server. This is done in the client program by creating a TCP socket. When the client creates its TCP socket, it specifies the address of the <strong>welcoming socket</strong> in the server, namely, the IP address of the server host and the port number of the socket.</p><p>During the three-way handshake, when the server “hears” the knocking, it creates a new connection socket that is dedicated to that particular client.</p><p><img loading="lazy" alt="img" src="/assets/images/3b306793-09e2-4022-a2af-b960959232fc-411294f7f51d35cc08d59b6004e27ffa.jpg" width="587" height="494" class="img_ev3q"></p><div class="language-py codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockTitle_Ktv7">client.py</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-py codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> socket </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverName </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;127.0.0.1&#x27;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverPort </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">12000</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> socket</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">AF_INET</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> SOCK_STREAM</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">connect</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">serverName</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> serverPort</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentence </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token builtin">input</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;Input lowercase sentence:&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">send</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentence</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">encode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">modifiedSetence </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">recv</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1024</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;From Server:&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> modifiedSetence</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clientSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">close</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>[1]<!-- --> This line sends the sentence through the client’s socket and into the TCP connection. Note that the program does not explicitly create a packet and attach the destination address to the packet, as was the case with UDP sockets.</p><div class="language-py codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-py codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> socket </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverPort </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">12000</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> socket</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">AF_INET</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> SOCK_STREAM</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">bind</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> serverPort</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">listen</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">## the maximum number of queued connections (at least 1)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;The server is ready to receive&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">True</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectionSocket</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> addr </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">accept</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sentence </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> connectionSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">recv</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1024</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    capitalizedSentence </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> setence</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">upper</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectionSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">send</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">capitalizedSentence</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">encode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectionSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">close</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">close</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When a client knocks on this door, the program invokes the <code>accept()</code> method for <code>serverSocket</code>, which creates a new socket in the server, called <code>connectionSocket</code>, dedicated to this particular client.</p><p>With the UDP server, there is no welcoming socket, and all data from different clients enters the server through one single socket. With the TCP server, there is a welcoming socket, thus, to support n simultaneous connections, the server would need n+1 sockets.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="exercise-proxy-server">Exercise: Proxy Server<a href="#exercise-proxy-server" class="hash-link" aria-label="Direct link to Exercise: Proxy Server" title="Direct link to Exercise: Proxy Server">​</a></h4><p>Write a simple TCP program for a server that accepts lines of input from a client and prints the lines onto the server’s standard output.</p><div class="language-py codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-py codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> socket </span><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverPort </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">12000</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> socket</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">AF_INET</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> SOCK_STREAM</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">bind</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> serverPort</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">listen</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">True</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectionSocket</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> addr </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">accept</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sentence </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> connectionSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">recv</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1024</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">decode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentence</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectionSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">send</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;Hello world!&quot;</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">encode</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    connectionSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">close</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serverSocket</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">close</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>On the Web browser, set the proxy server to your running server program. Your browser should now send its GET request messages to your server, and your server should display the messages on its standard output.</p><div class="language-py codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-py codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CONNECT www</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">baidu</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">com</span><span class="token punctuation" style="color:#393A34">:</span><span class="token number" style="color:#36acaa">443</span><span class="token plain"> HTTP</span><span class="token operator" style="color:#393A34">/</span><span class="token number" style="color:#36acaa">1.1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Host</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> www</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">baidu</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">com</span><span class="token punctuation" style="color:#393A34">:</span><span class="token number" style="color:#36acaa">443</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Proxy</span><span class="token operator" style="color:#393A34">-</span><span class="token plain">Connection</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> keep</span><span class="token operator" style="color:#393A34">-</span><span class="token plain">alive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">User</span><span class="token operator" style="color:#393A34">-</span><span class="token plain">Agent</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Mozilla</span><span class="token operator" style="color:#393A34">/</span><span class="token number" style="color:#36acaa">5.0</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">Macintosh</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> Intel Mac OS X </span><span class="token number" style="color:#36acaa">11_2_3</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> AppleWebKit</span><span class="token operator" style="color:#393A34">/</span><span class="token number" style="color:#36acaa">537.36</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">KHTML</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> like Gecko</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> Chrome</span><span class="token operator" style="color:#393A34">/</span><span class="token number" style="color:#36acaa">89.0</span><span class="token number" style="color:#36acaa">.4389</span><span class="token number" style="color:#36acaa">.90</span><span class="token plain"> Safari</span><span class="token operator" style="color:#393A34">/</span><span class="token number" style="color:#36acaa">537.36</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="transport-layer">Transport Layer<a href="#transport-layer" class="hash-link" aria-label="Direct link to Transport Layer" title="Direct link to Transport Layer">​</a></h2><p>Transport-layer protocols are implemented in the end systems but not in network routers. On the sending side, the transport layer converts the application-layer messages into segments. This is done by (possibly) breaking the application messages into smaller chunks and adding a transport-layer header to each chunk to create the transport-layer segment. The transport layer then passes the segment to the network layer at the sending end system, where the segment is encapsulated within a network-layer packet (a datagram) and sent to the destination. It’s important to note that network routers act only on the network-layer fields of the datagram; that is, they do not examine the fields of the transport-layer segment encapsulated with the datagram. On the receiving side, the network layer extracts the transport-layer segment from the datagram and passes the segment up to the transport layer. The transport layer then processes the received segment, making the data in the segment available to the receiving application.</p><p>Before proceeding with our introduction of <strong>UDP (User Datagram Protocol)</strong> and <strong>TCP (Transmission Control Protocol)</strong>, it will be useful to say a few words about the Internet’s network layer. IP, for Internet Protocol, is a best-effort delivery service. This means that IP makes its “best effort” to deliver segments between communicating hosts, but it makes no guarantees.</p><p>Extending host-to-host delivery to process-to-process delivery is called <strong>transport-layer multiplexing and demultiplexing</strong>.（多路复用、多路分解）UDP and TCP also provide <strong>integrity checking</strong> by including error-detection fields in their segments’ headers. These two minimal transport-layer services are the only two that UDP provides!</p><p>TCP, on the other hand, offers several additional services to applications.</p><ul><li>First and foremost, it provides <strong>reliable data transfer</strong>. Using flow control, sequence numbers, acknowledgments, and timers, TCP ensures that data is delivered from sending process to receiving process, correctly and in order.</li><li>TCP also provides <strong>congestion control</strong>. Congestion control is not so much a service provided to the invoking application as it is a service for the Internet as a whole.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="multiplexing-and-demultiplexing">Multiplexing and Demultiplexing<a href="#multiplexing-and-demultiplexing" class="hash-link" aria-label="Direct link to Multiplexing and Demultiplexing" title="Direct link to Multiplexing and Demultiplexing">​</a></h3><p>This job of delivering the data in a transport-layer segment to the correct socket is called demultiplexing. The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing.</p><p>There are <strong>source port number field</strong> and the <strong>destination port number field</strong> in a transport-layer segment. Each port number is a 16-bit number, ranging from 0 to 65535. The port numbers ranging from 0 to 1023 are called well-known port numbers and are restricted, which means reserved for use by well-known application protocols such as HTTP.</p><p>Each socket in the host could be assigned a port number, and when a segment arrives at the host, the transport layer examines the destination port number in the segment and directs the segment to the corresponding socket. The segment’s data then passes through the socket into the attached process. As we’ll see, this is basically how UDP does it.</p><p>It is important to note that a UDP socket is fully identified by a two-tuple consisting of a destination IP address and a destination port number. As a consequence, if two UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP address and destination port number, then the two segments will be directed to the same destination process via the same destination socket. In UDP, the source port number serves as part of a “return address”.</p><p>TCP socket is identified by a four-tuple: (source IP address, source port number, destination IP address, destination port number). In particular, and in contrast with UDP, two arriving TCP segments with different source IP addresses or source port numbers will (with the exception of a TCP segment carrying the original connection-establishment request) be directed to two different sockets.</p><p>Today’s high-performing Web servers often use only one process, and create a new thread with a new connection socket for each new client connection. For such a server, at any given time there may be many connection sockets (with different identifiers) attached to the same process. If the client and server are using persistent HTTP, then throughout the duration of the persistent connection the client and server exchange HTTP messages via the same server socket.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="udp-1">UDP<a href="#udp-1" class="hash-link" aria-label="Direct link to UDP" title="Direct link to UDP">​</a></h3><p>Note that with UDP there is no handshaking between sending and receiving transport-layer entities before sending a segment. For this reason, UDP is said to be <strong>connectionless</strong>.</p><p>DNS is an example of an application-layer protocol that typically uses UDP. The DNS application at the querying host then waits for a reply to its query. If it doesn’t receive a reply (possibly because the underlying network lost the query or the reply), it might try resending the query, try sending the query to another name server, or inform the invoking application that it can’t get a reply.</p><p>The UDP header has only four fields, each consisting of two bytes, totally 8 bytes. The length field specifies the number of bytes in the UDP segment (header plus data). The checksum is used by the receiving host to check whether errors have been introduced into the segment. In truth, the checksum is also calculated over a few of the fields in the IP header in addition to the UDP segment.</p><p><img loading="lazy" alt="img" src="/assets/images/3e9abcd9-448d-4b5e-a9c2-f4cffdae7808-83b6d061b1252c3d768173887fc7ebc6.jpg" width="481" height="288" class="img_ev3q"></p><p>Although UDP provides error checking, it does not do anything to recover from an error. Some implementations of UDP simply discard the damaged segment; others pass the damaged segment to the application with a warning.</p><p>Some applications are better suited for UDP (rather than TCP) for the following reasons:</p><ul><li>Finer application-level control over what data is sent, and when.<ul><li>WHAT: With TCP, the application writes data to the connection send buffer and TCP will grab bytes without necessarily putting a single message in the TCP segment; TCP may put more or less than a single message in a segment. UDP, on the other hand, encapsulates in a segment whatever the application gives it; so that, if the application gives UDP an application message, this message will be the payload of the UDP segment. Thus, with UDP, an application has more control of what data is sent in a segment.</li><li>WHEN: With TCP, due to flow control and congestion control, there may be significant delay from the time when an application writes data to its send buffer until when the data is given to the network layer. UDP does not have delays due to flow control and congestion control.</li></ul></li><li>No connection establishment. UDP does not introduce any delay to establish a connection. The TCP connection-establishment delay in HTTP is an important contributor to the delays associated with downloading Web documents.</li><li>No connection state. A server devoted to a particular application can typically support many more active clients when the application runs over UDP rather than TCP.</li><li>Small packet header overhead. The TCP segment has 20 bytes of header over- head in every segment, whereas UDP has only 8 bytes of overhead.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-1">TCP<a href="#tcp-1" class="hash-link" aria-label="Direct link to TCP" title="Direct link to TCP">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="go-back-n-gbn-and-selective-repeat-sr">Go-Back-N (GBN) and Selective Repeat (SR)<a href="#go-back-n-gbn-and-selective-repeat-sr" class="hash-link" aria-label="Direct link to Go-Back-N (GBN) and Selective Repeat (SR)" title="Direct link to Go-Back-N (GBN) and Selective Repeat (SR)">​</a></h4><p>In a Go-Back-N (GBN) protocol, the sender is allowed to transmit multiple packets (when available) without waiting for an acknowledgment, but is constrained to have no more than some maximum allowable number, N, of unacknowledged packets in the pipeline.</p><p><img loading="lazy" alt="img-80" src="/assets/images/6b6efedb-18b1-4215-8432-7e05d3b8cc0c-f28dde76faa999c0ad18c22da83ac395.png" width="2560" height="662" class="img_ev3q"></p><p>Four intervals in the range of sequence numbers can be identified:</p><ul><li>packets that have already been transmitted and acknowledged</li><li>packets that have been sent but not yet acknowledged</li><li>can be used for packets that can be sent immediately</li><li>cannot be used until an unacknowledged packet currently in the pipeline has been acknowledged</li></ul><p>As the protocol operates, this window slides forward over the sequence number space. For this reason, N is often referred to as the window size and the GBN protocol itself as a sliding-window protocol. N is limited by flow control and congestion control.</p><p>When <code>rdt_send()</code> is called from above, the sender first checks to see if the window is full, that is, whether there are N outstanding, unacknowledged packets. If the window is not full, a packet is created and sent, and variables are appropriately updated. If the window is full, the sender simply returns the data back to the upper layer, an implicit indication that the window is full. The upper layer would presumably then have to try again later. In a real implementation, the sender would more likely have either buffered (but not immediately sent) this data, or would have a synchronization mechanism (for example, a semaphore or a flag) that would allow the upper layer to call <code>rdt_send()</code> only when the window is not full.</p><p>Selective-repeat protocols avoid unnecessary retransmissions by having the sender retransmit only those packets that it suspects were received in error (that is, were lost or corrupted) at the receiver. This individual, as-needed, retransmission will require that the receiver individually acknowledge correctly received packets. A window size of N will again be used to limit the number of outstanding, unacknowledged packets in the pipeline. However, unlike GBN, the sender will have already received ACKs for some of the packets in the window.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-connection">TCP Connection<a href="#tcp-connection" class="hash-link" aria-label="Direct link to TCP Connection" title="Direct link to TCP Connection">​</a></h4><p>TCP is said to be connection-oriented because before one application process can begin to send data to another, the two processes must first “handshake” with each other. Both sides of the connection will initialize many TCP state variables.</p><p>Recall that because the TCP protocol runs only in the end systems and not in the intermediate network elements (routers and link-layer switches), the intermediate network elements do not maintain TCP connection state.</p><p>A TCP connection provides a <strong>full-duplex service</strong>: The application-layer data can flow from Process A to Process B <strong>at the same time</strong> as application-layer data flows from Process B to Process A.</p><p>Suppose a process running in one host wants to initiate a connection with another process in another host. Recall that the process that is initiating the connection is called the client process, while the other process is called the server process. Because three segments are sent between the two hosts, this connection-establishment procedure is often referred to as a <strong>three-way handshake</strong>.</p><p>Once a TCP connection is established, the two application processes can send data to each other. Let’s consider the sending of data from the client process to the server process. The client process passes a stream of data through the socket. Once the data passes through the door, the data is in the hands of TCP running in the client. TCP directs this data to the connection’s send buffer, which is one of the buffers that is set aside during the initial three-way handshake. From time to time, TCP will grab chunks of data from the send buffer and pass the data to the network layer. Interestingly, the TCP specification <!-- -->[RFC 793]<!-- --> is very laid back about specifying when TCP should actually send buffered data, stating that TCP should “send that data in segments at its own convenience.”</p><p>The maximum amount of data that can be grabbed and placed in a segment is limited by the <strong>maximum segment size (MSS)</strong>. The MSS is typically set by first determining the length of the largest link-layer frame that can be sent by the local sending host (the so-called <strong>maximum transmission unit, MTU</strong>), and then setting the MSS to ensure that a TCP segment (when encapsulated in an IP datagram) plus the TCP/IP header length (typically 40 bytes) will fit into a single link-layer frame. Both Ethernet and PPP link-layer protocols have an MTU of 1,500 bytes. Thus, a typical value of MSS is <strong>1460 bytes</strong>. Note that the MSS is the maximum amount of application-layer data in the segment, not the maximum size of the TCP segment including headers.</p><p>TCP pairs each chunk of client data with a TCP header, thereby forming TCP segments. The segments are passed down to the network layer, where they are separately encapsulated within network-layer IP datagrams. The IP datagrams are then sent into the network. When TCP receives a segment at the other end, the segment’s data is placed in the TCP connection’s receive buffer. <strong>Each side of the connection has its own send buffer and its own receive buffer</strong>.</p><p><img loading="lazy" alt="img" src="/assets/images/3483e571-f865-4200-8eb3-2bf951add260-537310703435aa1b532e8a41fef0e81d.jpg" width="681" height="308" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-segment">TCP Segment<a href="#tcp-segment" class="hash-link" aria-label="Direct link to TCP Segment" title="Direct link to TCP Segment">​</a></h4><p>The TCP segment consists of header fields and a data field. TCP header is typically 20 bytes. The data field contains a chunk of application data.</p><p>As with UDP, the header includes source and destination port numbers, which are used for multiplexing/ demultiplexing data from/to upper-layer applications. Also, as with UDP, the header includes a checksum field. A TCP segment header also contains the following fields:</p><ul><li>The 32-bit sequence number field and the 32-bit acknowledgment number field are used by the TCP sender and receiver in implementing a reliable data transfer service.</li><li>The 16-bit receive window field is used for flow control.</li><li>The 4-bit header length field specifies the length of the TCP header (typically 20 bytes).</li><li>The <strong>ACK bit</strong> is used to indicate that the segment contains an acknowledgment for a segment that has been successfully received.</li><li>The <strong>RST</strong>, <strong>SYN</strong>, and <strong>FIN</strong> bits are used for connection setup and teardown.</li><li>The CWR and ECE bits are used in explicit congestion notification.</li></ul><p><img loading="lazy" alt="img" src="/assets/images/e1517d86-1953-4dc1-8bcc-6aa30160c5b5-24abf62786985a40edeeb005086fbcb1.jpg" width="1667" height="1360" class="img_ev3q"></p><p>TCP views data as an unstructured, but ordered, stream of bytes. The sequence number for a segment is therefore the byte-stream number of the first byte in the segment.</p><p>Suppose that a process in Host A wants to send a stream of data to a process in Host B over a TCP connection. The TCP in Host A will implicitly number each byte in the data stream. Suppose that the data stream consists of a file consisting of 500,000 bytes, that the MSS is 1,000 bytes, and that the first byte of the data stream is numbered 0. As shown in Figure 3.30, TCP constructs 500 segments out of the data stream. The first segment gets assigned sequence number 0, the second segment gets assigned sequence number 1,000, the third segment gets assigned sequence number 2,000, and so on. Each sequence number is inserted in the sequence number field in the header of the appropriate TCP segment.</p><p><img loading="lazy" alt="img" src="/assets/images/2fa1b7f7-7e91-4476-b7f7-47f20997d923-a535079c2c354422287462334546a787.png" width="1780" height="606" class="img_ev3q"></p><p>Recall that TCP is full-duplex, the acknowledgment number that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B.</p><p>Suppose that Host A has received one segment from Host B containing bytes 0 through 535 and another segment containing bytes 900 through 1,000. For some reason Host A has not yet received bytes 536 through 899. In this example, Host A is still waiting for byte 536 (and beyond) in order to re-create B’s data stream. Thus, A’s next segment to B will contain 536 in the acknowledgment number field. Because TCP only acknowledges bytes up to the first missing byte in the stream, TCP is said to provide <strong>cumulative acknowledgments</strong> 累积确认. The receiver keeps the out-of-order bytes and waits for the missing bytes to fill in the gaps.</p><p>在图 3-30 中，我们假设初始序号为 0。实际上，TCP 连接的双方随机地选择初始序号。这样做可以减少将那些仍在网络中存在的、来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性（它碰巧与旧连接使用了相同的端口号）。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="round-trip-time-estimation-and-timeout">Round-Trip Time Estimation and Timeout<a href="#round-trip-time-estimation-and-timeout" class="hash-link" aria-label="Direct link to Round-Trip Time Estimation and Timeout" title="Direct link to Round-Trip Time Estimation and Timeout">​</a></h4><p>TCP uses a timeout/retransmit mechanism to recover from lost segments. Perhaps the most obvious question is the length of the timeout intervals. Clearly, the timeout should be larger than the connection’s round-trip time (RTT). Otherwise, unnecessary retransmissions would be sent.</p><p>How TCP estimates the round-trip time between sender and receiver? The sample RTT, denoted <code>SampleRTT</code>, for a segment is the amount of time between when the segment is sent (that is, passed to IP) and when an acknowledgment for the segment is received. At any point in time, the <code>SampleRTT</code> is being estimated for only one of the transmitted but currently unacknowledged segments, leading to a new value of <code>SampleRTT</code> approximately once every RTT. Also, TCP <strong>never</strong> computes a <code>SampleRTT</code> for a segment that has been retransmitted; it only measures <code>SampleRTT</code> for segments that have been transmitted once.</p><p>Obviously, the <code>SampleRTT</code> values will fluctuate. Upon obtaining a new <code>SampleRTT</code>, TCP updates <code>EstimatedRTT</code> according to the following formula:</p><p><code>EstimatedRTT = (1 – α) * EstimatedRTT + α * SampleRTT</code> (The recommended value of α is 0.125)</p><p>Note that EstimatedRTT is a weighted average of the SampleRTT values.</p><p>It is also valuable to have a measure of the variability of the RTT: <code>DevRTT</code>, an estimate of how much <code>SampleRTT</code> typically deviates from <code>EstimatedRTT</code>.</p><p><code>DevRTT = (1 – β) * DevRTT + β * |SampleRTT – EstimatedRTT|</code> (The recommended value of β is 0.25)</p><p>It is therefore desirable to set the timeout equal to the <code>EstimatedRTT</code> plus some margin:</p><p><code>TimeoutInterval = EstimatedRTT + 4 * DevRTT</code></p><p>An initial <code>TimeoutInterval</code> value of 1 second is recommended <!-- -->[RFC 6298]<!-- -->. Also, when a timeout occurs, the value of <code>TimeoutInterval</code> is doubled to avoid a premature timeout occurring for a subsequent segment that will soon be acknowledged. However, as soon as a segment is received and <code>EstimatedRTT</code> is updated, the <code>TimeoutInterval</code> is again computed using the formula above.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="reliable-data-transfer">Reliable Data Transfer<a href="#reliable-data-transfer" class="hash-link" aria-label="Direct link to Reliable Data Transfer" title="Direct link to Reliable Data Transfer">​</a></h4><p>We should keep in mind that reliable data transfer can be provided by link-, network-, transport-, or application-layer protocols.</p><p>The TCP timer management procedures use only a single retransmission <strong>timer</strong>, even if there are multiple transmitted but not yet acknowledged segments. It is helpful to think of the timer as being associated with the oldest unacknowledged segment.</p><p>Whenever the timeout event occurs, TCP retransmits the not-yet-acknowledged segment with the smallest sequence number, sets the next timeout interval to twice the previous value. Thus, the intervals grow exponentially after each retransmission. However, whenever the timer is started after either of the two other events (that is, data received from application above, and ACK received), the <code>TimeoutInterval</code> is derived from the most recent values of <code>EstimatedRTT</code> and <code>DevRTT</code>.</p><p>One of the problems with timeout-triggered retransmissions is that the timeout period can be relatively long. Fortunately, the sender can often detect packet loss well before the timeout event occurs by noting so-called duplicate ACKs. In the case that <strong>three duplicate ACKs</strong> are received, the TCP sender performs a <strong>fast retransmit</strong> <!-- -->[RFC 5681]<!-- -->, retransmitting the missing segment before that segment’s timer expires.</p><p>TCP looks a lot like a GBN-style protocol. But there are some striking differences between TCP and Go- Back-N. Many TCP implementations will buffer correctly received but out-of-order segments.</p><p>A proposed modification to TCP, the so-called selective acknowledgment <!-- -->[RFC 2018]<!-- -->, allows a TCP receiver to acknowledge out-of-order segments selectively rather than just cumulatively acknowledging the last correctly received, in-order segment. When combined with selective retransmission—skipping the retransmission of segments that have already been selectively acknowledged by the receiver—TCP looks a lot like our generic SR protocol. Thus, TCP’s error-recovery mechanism is probably best categorized as a hybrid of GBN and SR protocols.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="flow-control">Flow Control<a href="#flow-control" class="hash-link" aria-label="Direct link to Flow Control" title="Direct link to Flow Control">​</a></h4><p>Recall that the hosts on each side of a TCP connection set aside a <strong>receive buffer</strong> for the connection. Because TCP is full-duplex, the sender at each side of the connection maintains a distinct <strong>receive window</strong>.</p><p>When the TCP connection receives bytes that are correct and in sequence, it places the data in the receive buffer. The associated application process will read data from this buffer, but not necessarily at the instant the data arrives. If the application is relatively slow at reading the data, the sender can very easily overflow the connection’s receive buffer by sending too much data too quickly.</p><p>TCP provides a flow-control service to its applications to eliminate the possibility of the sender overflowing the receiver’s buffer. Flow control is thus a speed matching service—matching the rate at which the sender is sending against the rate at which the receiving application is reading.</p><p>Even though the actions taken by flow and congestion control are similar (the throttling of the sender), they are obviously taken for very different reasons.</p><p>TCP provides flow control by having the sender maintain a variable called the <strong>receive window</strong>: <code>rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]</code></p><p><img loading="lazy" alt="img" src="/assets/images/2c34bbc3-fb1a-40a0-be20-60dbed5764a2-d1b9b8a8671f17fbf3031d97ddecb7dc.png" width="1702" height="974" class="img_ev3q"></p><p>Host A makes sure throughout the connection’s life that, the amount of unacknowledged data that A has sent into the connection, less or equals than the rwnd: <code>LastByteSent – LastByteAcked &lt;= rwnd</code>.</p><p>See <a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/flow-control/index.html" target="_blank" rel="noopener noreferrer">interactive animation</a>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-connection-management">TCP Connection Management<a href="#tcp-connection-management" class="hash-link" aria-label="Direct link to TCP Connection Management" title="Direct link to TCP Connection Management">​</a></h4><p>Suppose a process running in one host (client) wants to initiate a connection with another process in another host (server):</p><ol><li>The client-side TCP first sends a special TCP segment, the <strong>SYN segment</strong>, to the server-side TCP. The SYN segment contains no application-layer data. But the SYN bit, is set to 1. In addition, the client randomly chooses an initial sequence number (<code>client_isn</code>) and puts this number in the sequence number field of the initial TCP SYN segment.</li><li>Once the TCP SYN segment arrives, the server allocates the TCP buffers and variables to the connection, and sends a connection-granted segment, the <strong>SYNACK segment</strong>, to the client TCP. The SYNACK segment also contains no application-layer data. However, it does contain three important pieces of information in the segment header. First, the SYN bit is set to 1. Second, the acknowledgment field of the TCP segment header is set to <code>client_isn+1</code>. Finally, the server chooses its own initial sequence number (<code>server_isn</code>) and puts this value in the sequence number field of the TCP segment header.</li><li>Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection. The client host then sends the server yet another segment, putting the value <code>server_isn+1</code> in the acknowledgment field of the TCP segment header. The SYN bit is set to zero, since the connection is established. This third stage of the three-way handshake may carry client-to-server data in the segment payload.</li></ol><p><img loading="lazy" alt="img" src="/assets/images/f7435a29-0c44-415f-b830-676a291e1f6e-87d09b51e4431a99d2e560b7dd7eddec.png" width="1540" height="1350" class="img_ev3q"></p><p>Once these three steps have been completed, the client and server hosts can send segments containing data to each other.</p><p>Either of the two processes participating in a TCP connection can end the connection. suppose the client decides to close the connection:</p><ul><li>The client TCP sends a TCP segment with the FIN bit set to 1.（之后客户端停止发送数据，但仍会对收到的数据进行确认）</li><li>When the server receives this segment, it sends the client an acknowledgment segment in return.（此时服务端还可能继续发送一些数据，客户端也会对这些数据返回 ACK 确认）</li><li>The server then sends its own shutdown segment, which has the FIN bit set to 1.（之后服务端也停止发送数据）</li><li>The client acknowledges the server’s shutdown segment and wait for a time, typically 30 seconds, letting the TCP client resend the final acknowledgment in case the ACK is lost. After the wait, the connection formally closes and all resources on the client side (including port numbers) are released.</li><li>The server receives the final ACK and closes down.</li></ul><p>TCP 关闭连接时，主动方和被动方分别发生了什么：</p><ul><li>双方都需要发送 FIN 信号，并且，发送 ACK 以确认对方发的 FIN 信号</li><li>主动方在发送最后的 ACK 后，需要等待 2MSL 的时间，这是为了确认被动方收到了最后的 ACK</li></ul><p>The MSL is the maximum amount of time that a TCP segment can live in the network.</p><p><img loading="lazy" alt="img" src="/assets/images/a3952603-43c0-49c8-b969-df3d4ef60658-7a5c4721120fda4d5dd831b6b84136b2.png" width="1472" height="1490" class="img_ev3q"></p><blockquote><p><a href="https://nmap.org/" target="_blank" rel="noopener noreferrer">Nmap</a> (&quot;Network Mapper&quot;) is a free and open source (license) utility for network discovery and security auditing.</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="classic-tcp-congestion-control-tcp-reno">Classic TCP Congestion Control (TCP Reno)<a href="#classic-tcp-congestion-control-tcp-reno" class="hash-link" aria-label="Direct link to Classic TCP Congestion Control (TCP Reno)" title="Direct link to Classic TCP Congestion Control (TCP Reno)">​</a></h4><p>TCP 拥塞控制的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其发送流量的速率。</p><p>The TCP congestion-control mechanism operating at the <strong>sender</strong> keeps track of an additional variable, the <strong>congestion window</strong>, denoted <code>cwnd</code>. Specifically, the amount of unacknowledged data at a sender may not exceed the minimum of <code>cwnd</code> and <code>rwnd</code>, that is: <code>LastByteSent – LastByteAcked &lt;= min{cwnd, rwnd}</code>.（TCP 流水线中可以同时发送的、即未经 ACK 确认的数据量，不能超过拥塞窗口和接收窗口中的较小值）</p><p>The constraint above limits the amount of unacknowledged data at the sender and therefore indirectly limits the sender’s send rate.</p><p>There is no explicit signaling of congestion state by the network—<strong>ACKs and loss events</strong> serve as implicit signals. The loss event at the sender—either a timeout or the receipt of three duplicate ACKs (totally 4 ACKs)—which is taken by the sender to be an indication of congestion on the sender-to-receiver path. An acknowledged segment indicates that the network is delivering the sender’s segments to the receiver, and hence, the sender’s rate can be increased when an ACK arrives.</p><p>We’re now in a position to consider the details of the celebrated <strong>TCP congestion-control algorithm</strong>, which has three major components: (1) slow start, (2) congestion avoidance, and (3) fast recovery.</p><p>In the <strong>slow-start</strong> state, the value of <code>cwnd</code> begins at 1 MSS and increases by 1 MSS every time a transmitted segment is first acknowledged. This process results in a doubling of the sending rate every RTT. Thus, the TCP send rate starts slow but grows exponentially during the slow start phase.</p><ul><li>Timeout: <code>ssthresh = cwnd/2; cwnd = 1 MSS;</code>, begins the slow start process anew.</li><li>3 duplicate ACKs: <code>ssthresh = cwnd/2; cwnd = ssthresh + 3 * MSS;</code>, performs a fast retransmit and enters the fast recovery state.</li><li>When <code>cwnd == ssthresh</code>, slow start ends and TCP transitions into congestion avoidance mode.</li></ul><p>On entry to the <strong>congestion-avoidance state</strong>, TCP linearly increases the value of <code>cwnd</code> by just a single MSS every RTT.</p><ul><li>Timeout: <code>ssthresh = cwnd/2; cwnd = 1 MSS;</code>, begins the slow start process anew.</li><li>3 duplicate ACKs: <code>ssthresh = cwnd/2; cwnd = ssthresh + 3 * MSS;</code>, performs a fast retransmit and enters the fast recovery state.</li></ul><p>In <strong>fast recovery state</strong>, the value of <code>cwnd</code> is increased by 1 MSS for every duplicate ACK received for the missing segment. Eventually, when an ACK arrives for the missing segment, TCP enters the congestion-avoidance state and sets <code>cwnd = ssthresh</code>.</p><ul><li>Timeout: <code>ssthresh = cwnd/2; cwnd = 1 MSS;</code>, begins the slow start process anew.</li></ul><blockquote><p>[1]<!-- --> ssthresh: slow start threshold.</p><p>[2]<!-- --> Adding in 3 MSS for good measure to account for the triple duplicate ACKs received. This artificially &quot;inflates&quot; the congestion window by the number of segments (three) that have left the network and which the receiver has buffered <!-- -->[RFC 2582]<!-- -->.</p></blockquote><p><img loading="lazy" alt="img" src="/assets/images/41a59b59-dace-4d31-acde-4cddeada64ca-8942455b85a618d8a0896af93e389f43.png" width="2049" height="1667" class="img_ev3q"></p><blockquote><p>The arrows in the FSM description indicate the transition of the protocol from one state to another.</p><p>The event causing the transition is shown above the horizontal line labeling the transition, and the actions taken when the event occurs are shown below the horizontal line.</p><p>When no action is taken on an event, or no event occurs and an action is taken, we’ll use the symbol Λ below or above the horizontal, respectively, to explicitly denote the lack of an action or event.</p><p>The initial state of the FSM is indicated by the dashed arrow.</p></blockquote><p>Ignoring the slow-start phase (This phase is typically very short, since the sender grows out of the phase exponentially fast) and assuming that losses are indicated by triple duplicate ACKs, TCP’s congestion control consists of linear (additive) increase in cwnd of 1 MSS per RTT and then a halving (multiplicative decrease) of cwnd on a triple duplicate-ACK event. For this reason, TCP congestion control is often referred to as an <strong>additive-increase, multiplicative-decrease (AIMD)</strong> form of congestion control.</p><p>TCP Reno’s AIMD to congestion control may be overly cautious. It’s better to more quickly ramp up the sending rate to get close to the pre-loss sending rate and only then probe cautiously for bandwidth. This insight lies at the heart of a flavor of TCP known as TCP CUBIC, who has recently gained wide deployment.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="explicit-congestion-notification-and-delayed-based-congestion-control">Explicit Congestion Notification and Delayed-based Congestion Control<a href="#explicit-congestion-notification-and-delayed-based-congestion-control" class="hash-link" aria-label="Direct link to Explicit Congestion Notification and Delayed-based Congestion Control" title="Direct link to Explicit Congestion Notification and Delayed-based Congestion Control">​</a></h4><p>TCP 拥塞控制已经演化了多年并仍在继续演化。</p><p>More recently, extensions to both IP and TCP <!-- -->[RFC 3168]<!-- --> have been proposed, implemented, and deployed that allow the network to explicitly signal congestion to a TCP sender and receiver.</p><p><strong>Explicit Congestion Notification (ECN)</strong> 显式阻塞通知 is the form of network-assisted congestion control performed within the Internet. Both TCP and IP are involved. At the network layer, two bits (with four possible values, overall) in the &quot;Type of Service field&quot; of the IP datagram header are used for ECN.</p><p>One setting of the ECN bits is used by a router to indicate that it (the router) is experiencing congestion. A second setting of the ECN bits is used by the sending host to inform routers that the sender and receiver are ECN-capable, and thus capable of taking action in response to ECN-indicated network congestion.</p><p>The intuition is that the congestion indication bit can be set to signal the onset of congestion to the sender before loss actually occurs.</p><p>As shown in Figure 3.55, when the TCP in the receiving host receives an ECN congestion indication via a received IP datagram, the TCP in the receiving host informs the TCP in the sending host of the congestion indication by setting the ECE (Explicit Congestion Notification Echo) bit in a receiver-to-sender TCP ACK segment. The TCP sender, in turn, reacts by halving the congestion window, as it would react to a lost segment using fast retransmit, and sets the CWR (Congestion Window Reduced) bit in the header of the next transmitted TCP sender-to-receiver segment.</p><p><img loading="lazy" alt="img" src="/assets/images/9f99030c-c50e-41f4-970d-4bd207e00f72-9926918ffecf58ec889936c386d14a8c.png" width="2108" height="1374" class="img_ev3q"></p><p>In addition, a number of variations of TCP congestion control protocols have been proposed that infer congestion using measured packet delay.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="fairness">Fairness<a href="#fairness" class="hash-link" aria-label="Direct link to Fairness" title="Direct link to Fairness">​</a></h4><p>TCP 的 AIMD 算法公平吗? TCP 趋于在竞争的多条 TCP 连接之间提供对瓶颈链路带宽的平等分享。但实践中，那些具有较小 RTT 的连接能够通过更快地增大其拥塞窗口、抢到更多的可用带宽，因而比那些具有较大 RTT 的连接享用更高的吞吐量。</p><p>UDP 是没有内置的拥塞控制的。实时通话应用通常希望以恒定的速率将其数据注入网络，它们可以接受偶尔丢失分组，但不愿在拥塞时将其发送速率降至“公平”级别而不丢失任何分组。从 TCP 的观点来看，运行在 UDP 上的应用是不公平的，因为它们不与其他连接合作、适时地调整传输速率，UDP 有可能压制 TCP 流量。当今的一个主要研究领域就是因特网的拥塞控制机制，用于阻止 UDP 流量不断压制直至中断因特网吞吐量的情况。</p><p>即使我们能够使 UDP 流量具有公平的行为，但公平性问题仍然没有完全解决。因为我们没有办法阻止应用使用多个并行 TCP 连接。例如，Web 浏览器通常使用多个并行 TCP 连接来传送一个 Web</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="evolution">Evolution<a href="#evolution" class="hash-link" aria-label="Direct link to Evolution" title="Direct link to Evolution">​</a></h3><p>Three decades of experience with TCP and UDP has identified circumstances in which neither is ideally suited, and so the design and implementation of transport layer functionality has continued to evolve.</p><p>Indeed, measurements in <!-- -->[Yang 2014]<!-- --> indicate that CUBIC (and its predecessor, BIC <!-- -->[Xu 2004]<!-- -->) and CTCP are more widely deployed on Web servers than classic <strong>TCP Reno</strong>; we also saw that BBR is being deployed in Google’s internal B4 network, as well as on many of Google’s public-facing servers. And there are many (many!) more versions of TCP!</p><p>QUIC is a new application-layer protocol designed from the ground up to improve the performance of transport-layer services for secure HTTP. QUIC has already been widely deployed, although is still in the process of being standardized as an Internet RFC.</p><p>QUIC is an application-layer protocol, using UDP as its underlying transport-layer protocol, and is designed to interface above specifically to a simplified but evolved version of HTTP/2. In the near future, HTTP/3 will natively incorporate QUIC.</p><p><img loading="lazy" alt="img-80" src="/assets/images/83a49780-3c9b-45bc-8281-da99bbdbd1fc-efbb033289765e9a1eccbb0153156456.png" width="2508" height="1066" class="img_ev3q"></p><p>Some of QUIC’s major features include:</p><ul><li>Connection-Oriented and Secure. QUIC combines the handshakes needed to establish connection state with those needed for authentication and encryptionm, thus providing faster establishment.</li><li>Streams. QUIC allows several different application-level “streams” to be multiplexed through a single QUIC connection. Data from multiple streams may be contained within a single QUIC segment, which is carried over UDP.</li><li>Reliable, TCP-friendly congestion-controlled data transfer. QUIC provides reliable data transfer to each QUIC stream separately. Since QUIC provides a reliable in-order delivery on a per-stream basis, a lost UDP segment only impacts those streams whose data was carried in that segment; HTTP messages in other streams can continue to be received and delivered to the application. QUIC provides reliable data transfer using acknowledgment mechanisms similar to TCP’s, as specified in <!-- -->[RFC 5681]<!-- -->.</li></ul><p><img loading="lazy" alt="img" src="/assets/images/1d0a6128-dc02-4e5a-938a-711cb8227694-716bd8c6aba8895ca54153af8da1abb1.png" width="2334" height="1128" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="network-layer">Network Layer<a href="#network-layer" class="hash-link" aria-label="Direct link to Network Layer" title="Direct link to Network Layer">​</a></h2><p>Having now covered the application layer and the transport layer, our discussion of the network edge is complete. It is time to explore the network core!</p><p>The network layer is arguably the most complex layer in the protocol stack. We’ll see that the network layer can be decomposed into two interacting parts, the <strong>data plane</strong> and the <strong>control plane</strong>.</p><p>In Chapter 4, we’ll first cover the data plane functions—the <strong>per-router</strong> functions that determine how a datagram arriving on one of a router’s input links is forwarded to one of that router’s output links.</p><p>In Chapter 5, we’ll cover the control plane functions—the <strong>network-wide</strong> logic that controls how a datagram is routed among routers along an end-to-end path from the source host to the destination host, also, how network-layer components and services are configured and managed.</p><p><strong>Forwarding</strong> refers to the router-local action of transferring a packet from an input link interface to the appropriate output link interface. Forwarding takes place at very short timescales (typically a few nanoseconds), and thus is typically implemented in hardware.</p><p><strong>Routing</strong> refers to the network-wide process that determines the end-to-end paths that packets take from source to destination. Routing takes place on much longer timescales (typically seconds), and as we will see is often implemented in software.</p><p>Some packet switches, called <strong>link-layer switches</strong>, base their forwarding decision on values in the fields of the link-layer frame; switches are thus referred to as link-layer (layer 2) devices. Other packet switches, called <strong>routers</strong>, base their forwarding decision on header field values in the network-layer datagram. Routers are thus network-layer (layer 3) devices.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-plane">Data Plane<a href="#data-plane" class="hash-link" aria-label="Direct link to Data Plane" title="Direct link to Data Plane">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="router">Router<a href="#router" class="hash-link" aria-label="Direct link to Router" title="Direct link to Router">​</a></h4><p>一台路由器的组成：（注意这里的端口指的是物理硬件端口，而非软件端口）</p><ul><li>Input ports. It is here that the forwarding table is consulted to determine the router output port to which an arriving packet will be forwarded via the switching fabric. Control packets (for example, packets carrying routing protocol information) are forwarded from an input port to the routing processor.</li><li>Switching fabric. The switching fabric connects the router’s input ports to its output ports. A network inside of a router!</li><li>Output ports. An output port stores packets received from the switching fabric and transmits these packets on the outgoing link.</li><li>Routing processor. The routing processor performs control-plane functions. In traditional routers, it executes the routing protocols, maintains routing tables and attached link state information, and computes the forwarding table for the router. In SDN routers, the routing processor is responsible for communicating with the remote controller in order to (among other activities) receive forwarding table entries computed by the remote controller, and install these entries in the router’s input ports.</li></ul><p>A router’s input ports, output ports, and switching fabric are almost always implemented in hardware.</p><p><img loading="lazy" alt="img" src="/assets/images/b03d7bc1-becf-419c-9aa5-fb0b0d5ed702-2ac70f15777ebaea0a48bb727c5d211f.png" width="2560" height="1280" class="img_ev3q"></p><p>The lookup performed in the input port is central to the router’s operation—it is here that the router uses the forwarding table to look up the output port to which an arriving packet will be forwarded via the switching fabric.</p><p>The forwarding table is either computed and updated by the routing processor (using a routing protocol to interact with the routing processors in other network routers, the traditional approach) or is received from a remote SDN controller (The SDN approach).</p><p>We’ll initially assume in this section that forwarding decisions are based only on the packet’s destination address, rather than on a generalized set of packet header fields. The router matches a <strong>prefix</strong> of the packet’s destination address with the entries in the table; When there are multiple matches, the router uses the <strong>longest prefix matching</strong> rule.</p><table><thead><tr><th>Prefix</th><th>Link Interface</th></tr></thead><tbody><tr><td>11001000 00010111 00010</td><td>0</td></tr><tr><td>11001000 00010111 00011000</td><td>1</td></tr><tr><td>11001000 00010111 00011</td><td>2</td></tr><tr><td>Otherwise</td><td>3</td></tr></tbody></table><p>Once a packet’s output port has been determined via the lookup, the packet can be sent into the switching fabric.</p><p>Switching can be accomplished in a number of ways: Switching via memory; Switching via a bus; Switching via an interconnection network.</p><p>If the switch fabric is not fast enough (relative to the input line speeds) to transfer all arriving packets through the fabric without delay, packet queuing can occur at the input ports.</p><p>Output port processing takes packets that have been stored in the output port’s memory and transmits them over the output link. This includes selecting and de-queueing packets for transmission, and performing the needed link-layer and physical-layer transmission functions.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ipv4">IPv4<a href="#ipv4" class="hash-link" aria-label="Direct link to IPv4" title="Direct link to IPv4">​</a></h4><p>Note that an IP datagram has a total of 20 bytes of header (assuming no options). If the datagram carries a TCP segment, then each datagram carries a total of 40 bytes of header (20 bytes of IP header plus 20 bytes of TCP header) along with the application-layer message.</p><p>A host typically has only a single link into the network. The boundary between the host and the physical link is called an <strong>interface</strong>. The boundary between the router and any one of its links is also called an interface. A router thus has multiple interfaces, one for each of its links. Because every host and router is capable of sending and receiving IP datagrams, IP requires each host and router interface to have its own IP address. Thus, <strong>an IP address is technically associated with an interface, rather than with the host or router containing that interface</strong>.</p><p>Each IP address is 32 bits long (4 bytes), and there are thus a total of <code>2 ^ 32</code> (or approximately 4 billion) possible IP addresses.</p><p>Each interface on every host and router in the global Internet must have an IP address that is globally unique (except for interfaces behind NATs).</p><p>Figure 4.18 provides an example of IP addressing and interfaces.</p><p><img loading="lazy" alt="img-70" src="/assets/images/e48ac656-d67a-4c0a-a481-11ced61796e0-1c1de6af34aee9d335d44984b833c578.png" width="2146" height="1568" class="img_ev3q"></p><p>The three hosts in the upper-left portion of Figure 4.18, and the router interface to which they are connected, all have an IP address of the form 223.1.1.xxx. In IP terms, this network interconnecting three host interfaces and one router interface forms a <strong>subnet</strong>. IP addressing assigns an address to this subnet: 223.1.1.0/24, where the /24 notation, sometimes known as a <strong>subnet mask</strong> 子网掩码, indicates that the leftmost 24 bits of the 32-bit quantity define the subnet address. Any additional hosts attached to the 223.1.1.0/24 subnet would be required to have an address of the form 223.1.1.xxx.</p><p>It’s clear that an organization (such as a company or academic institution) with multiple Ethernet segments and point-to-point links will have multiple subnets, with all of the devices on a given subnet having the same subnet address.</p><p>The global Internet’s address assignment strategy is known as <strong>Classless Interdomain Routing</strong> (CIDR—pronounced cider) <!-- -->[RFC 4632]<!-- -->. CIDR generalizes the notion of subnet addressing. As with subnet addressing, the 32-bit IP address is divided into two parts and again has the dotted-decimal form a.b.c.d/x, where x indicates the number of bits in the first part of the address.</p><p>An organization is typically assigned a block of contiguous addresses, that is, a range of addresses with a common prefix. In this case, the IP addresses of devices within the organization will share the common prefix.</p><p>The remaining <code>32 - x</code> bits of an address can be thought of as distinguishing among the devices within the organization, all of which have the same network prefix. These are the bits that will be considered only when forwarding packets at routers within the organization. These lower-order bits may (or may not) have an additional subnetting structure. （组织内部又可以分割成更多的子网）</p><p>IP broadcast address: When a host sends a datagram with destination address 255.255.255.255, the message is delivered to all hosts on the same subnet (e.g. using in DHCP).</p><p>Let’s begin looking at how an organization gets a block of addresses for its devices, and then look at how a device (such as a host) is assigned an address from within the organization’s block of addresses.</p><p>In order to obtain a block of IP addresses for use within an organization’s subnet, a network administrator might first contact its ISP, which would provide addresses from a larger block of addresses that had already been allocated to the ISP.</p><p>Is there a global authority that has ultimate responsibility for managing the IP address space and allocating address blocks to ISPs and other organizations? IP addresses are managed under the authority of the ICANN. The role of the nonprofit ICANN organization is not only to allocate IP addresses, but also to manage the DNS root servers.</p><p>Once an organization has obtained a block of addresses, it can assign individual IP addresses to the host and router interfaces in its organization. Typically this is done using the <strong>Dynamic Host Configuration Protocol (DHCP)</strong>. DHCP allows a host to obtain (be allocated) an IP address automatically. A network administrator can configure DHCP so that a given host receives the same IP address each time it connects to the network, or a host may be assigned a temporary IP address that will be different each time the host connects to the network. In addition to host IP address assignment, DHCP also allows a host to learn additional information, such as its subnet mask, the address of its first-hop router (often called the default gateway), and the address of its local DNS server.</p><p>DHCP is a client-server protocol. A client is typically a newly arriving host wanting to obtain network configuration information, including an IP address for itself. In the simplest case, each subnet will have a DHCP server. If no server is present on the subnet, a DHCP relay agent (typically a router) that knows the address of a DHCP server for that network is needed.</p><p>For a newly arriving host, the DHCP protocol is a four-step process: DHCP server discovery; DHCP server offer(s); DHCP request; DHCP ACK.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="nat">NAT<a href="#nat" class="hash-link" aria-label="Direct link to NAT" title="Direct link to NAT">​</a></h4><p>The address space 10.0.0.0/8 is one of three portions of the IP address space that is reserved in <!-- -->[RFC 1918]<!-- --> for a private network. The other two are 172.16.0.0/12, 192.168.0.0/16.</p><p>Figure 4.25 shows the operation of <strong>Network Address Translation (NAT)</strong>. The NAT-enabled router, residing in the home, has an interface that is part of the home network on the right of Figure 4.25.</p><p><img loading="lazy" alt="img" src="/assets/images/27f2f9fa-0491-4e4e-b151-31aa972c1ef5-ab614daab0eeb9100725b8a871b35a9e.png" width="2404" height="1278" class="img_ev3q"></p><p>The NAT router behaves to the outside world as a single device with a single IP address. The router gets its address from the ISP’s DHCP server, and the router runs a DHCP server to provide addresses to computers within the NAT-DHCP-router-controlled home network’s address space.</p><p>If all datagrams arriving at the NAT router from the WAN (Wide area network) have the same destination IP address, then how does the router know the internal host to which it should forward a given datagram? The trick is to use a <strong>NAT translation table</strong> at the NAT router, and to include port numbers as well as IP addresses in the table entries.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ipv6">IPv6<a href="#ipv6" class="hash-link" aria-label="Direct link to IPv6" title="Direct link to IPv6">​</a></h4><p>In the early 1990s, the Internet Engineering Task Force began an effort to develop a successor to the IPv4 protocol. A prime motivation for this effort was the realization that the 32-bit IPv4 address space was beginning to be used up.</p><p>The most important changes introduced in IPv6 are evident in the datagram format: IPv6 increases the size of the IP address from 32 to 128 bits. This ensures that the world won’t run out of IP addresses.</p><p>How will the public Internet, which is based on IPv4, be transitioned to IPv6? The problem is that while new IPv6-capable systems can be made backward-compatible, that is, can send, route, and receive IPv4 datagrams, already deployed IPv4-capable systems are not capable of handling IPv6 datagrams.</p><p>The approach to IPv4-to-IPv6 transition that has been most widely adopted in practice involves <strong>tunneling</strong>.</p><p><img loading="lazy" alt="img-80" src="/assets/images/41cf63cf-9758-4b6b-9759-6ce8b8585df8-f1b16572f9721113520ce6a8b264d7af.png" width="1832" height="1538" class="img_ev3q"></p><p>Suppose two IPv6 nodes (in this example, B and E in Figure 4.27) want to interoperate using IPv6 datagrams but are connected to each other by intervening IPv4 routers. We refer to the intervening set of IPv4 routers between two IPv6 routers as a tunnel. With tunneling, the IPv6 node on the sending side of the tunnel (in this example, B) takes the entire IPv6 datagram and puts it in the data (payload) field of an IPv4 datagram. This IPv4 datagram is then addressed to the IPv6 node on the receiving side of the tunnel (in this example, E) and sent to the first node in the tunnel (in this example, C). The intervening IPv4 routers in the tunnel route this IPv4 datagram among themselves, just as they would any other datagram. The IPv6 node on the receiving side determines that the payload is a IPv6 datagram, extracts the IPv6 datagram, and then routes the IPv6 datagram exactly as it would if it had received the IPv6 datagram from a directly connected IPv6 neighbor.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="control-plane">Control Plane<a href="#control-plane" class="hash-link" aria-label="Direct link to Control Plane" title="Direct link to Control Plane">​</a></h3><p>We saw that the forwarding table (in the case of destination-based forwarding) and the flow table (in the case of generalized forwarding) were the principal elements that linked the network layer’s data and control planes. We saw that in the case of generalized forwarding, the actions taken could include not only forwarding a packet to a router’s output port, but also dropping a packet, replicating a packet, and/or rewriting layer 2, 3 or 4 packet-header fields.</p><p>In this chapter, we’ll study how those forwarding and flow tables are computed, maintained and installed. We learned that there are two possible approaches for doing so:</p><ul><li>Per-router control: Each router has a routing component that communicates with the routing components in other routers to compute the values for its forwarding table. This per-router control approach has been used in the Internet for decades. The OSPF and BGP are based on this per-router approach to control.</li><li>Software-defined networking (SDN) control: A logically centralized controller computes and distributes the forwarding tables to be used by each and every router. The OpenFlow protocol operates between an SDN controller and an SDN-controlled switch or other device implementing the OpenFlow API. The OpenFlow protocol operates over TCP, with a default port number of 6653.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="routing-algorithms">Routing Algorithms<a href="#routing-algorithms" class="hash-link" aria-label="Direct link to Routing Algorithms" title="Direct link to Routing Algorithms">​</a></h4><p>The goal of routing algorithms is to determine the least cost paths (equivalently, routes), from senders to receivers, through the network of routers. A <strong>graph</strong> is used to formulate routing problems. The least-cost problem is therefore clear: Find a path between the source and destination that has least cost. Note that if all edges in the graph have the same cost, the <strong>least-cost path</strong> is also the shortest path (that is, the path with the smallest number of links between the source and the destination).</p><p>A centralized routing algorithm computes the least-cost path using complete, global knowledge about the network. Algorithms with global state information are often referred to as <strong>link-state (LS) algorithms</strong>, since the algorithm must be aware of the cost of each link in the network. In practice, this is accomplished by having each node broadcast link-state packets to all other nodes in the network, with each link-state packet containing the identities and costs of its attached links. In practice (for example, with the Internet’s OSPF routing protocol), this is often accomplished by a link-state broadcast algorithm. The result of the nodes’ broadcast is that all nodes have an identical and complete view of the network. Each node can then run the LS algorithm and compute the same set of least-cost paths as every other node.</p><p>In a decentralized routing algorithm, the calculation of the least-cost path is carried out in an iterative, distributed manner by the routers. No node has complete information about the costs of all network links. Instead, each node begins with only the knowledge of the costs of its own directly attached links. Then, through an iterative process of calculation and exchange of information with its neighboring nodes, a node gradually calculates the least-cost path to a destination or set of destinations. The decentralized routing algorithm we’ll study is called a <strong>distance-vector (DV) algorithm</strong>, because each node maintains a vector of estimates of the costs (distances) to all other nodes in the network. Such decentralized algorithms, with interactive message exchange between neighboring routers is perhaps more naturally suited to control planes where the routers interact directly with each other.</p><p>Neither algorithm is an obvious winner over the other; indeed, both algorithms are used in the Internet. These two algorithms are the basis for two widely deployed Internet routing protocols, OSPF and BGP.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ospf-and-bgp">OSPF and BGP<a href="#ospf-and-bgp" class="hash-link" aria-label="Direct link to OSPF and BGP" title="Direct link to OSPF and BGP">​</a></h4><p>In our study of routing algorithms, we’ve viewed the network simply as a collection of interconnected routers. In practice, this model is simplistic for two important reasons: First, today’s Internet consists of hundreds of millions of routers. Storing routing information for possible destinations at each of these routers would clearly require enormous amounts of memory. The overhead required to broadcast connectivity and link cost updates among all of the routers would be huge! A distance-vector algorithm that iterated among such a large number of routers would surely never converge. Clearly, something must be done to reduce the complexity of route computation in a network as large as the Internet. Second, the Internet is a network of ISPs, with each ISP consisting of its own network of routers. An ISP generally desires to operate its network as it pleases or to hide aspects of its network’s internal organization from the outside. Ideally, an organization should be able to operate and administer its network as it wishes, while still being able to connect its network to other outside networks.</p><p>Both of these problems can be solved by organizing routers into <strong>autonomous systems (ASs)</strong>, with each AS consisting of a group of routers that are under the same administrative control. An autonomous system is identified by its globally unique autonomous system number (ASN). AS numbers, like IP addresses, are assigned by ICANN regional registries.</p><p>Routers within the same AS all run the same routing algorithm and have infor- mation about each other. The routing algorithm running within an autonomous sys- tem is called an intra-autonomous system routing protocol. OSPF routing and its closely related cousin, IS-IS, are widely used for intra-AS routing in the Internet.</p><p>Since an inter-AS routing protocol involves coordination among multiple ASs, communicating ASs must run the same inter-AS routing protocol. In fact, in the Internet, all ASs run the same inter-AS routing protocol, called the Border Gateway Protocol, more commonly known as <strong>BGP</strong>.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="managing-the-ip-network">Managing the IP Network<a href="#managing-the-ip-network" class="hash-link" aria-label="Direct link to Managing the IP Network" title="Direct link to Managing the IP Network">​</a></h4><p>The Internet Control Message Protocol (ICMP), specified in <!-- -->[RFC 792]<!-- -->, is used by hosts and routers to communicate network-layer information to each other.</p><p>In practice, there are three commonly used ways in a network operator can manage the network:</p><ul><li>CLI. A network operator may issue direct Command Line Interface (CLI) commands to the device. These commands can be typed directly on a managed device’s console (if the operator is physically present at the device), or over a Telnet or secure shell (SSH) connection, possibly via scripting, between the managing server/controller and the managed device.</li><li>SNMP/MIB. In this approach, the network operator can query/set the data contained in a device’s Management Information Base (MIB) objects using the Simple Network Management Protocol (SNMP).</li><li>NETCONF/YANG. The NETCONF/YANG approach takes a more abstract, network-wide, and holistic view toward network management, with a much stronger emphasis on configuration management, including specifying correctness constraints and providing atomic management operations over multiple controlled devices. YANG <!-- -->[RFC 6020]<!-- --> is a data modeling language used to model configuration and operational data. The NETCONF protocol <!-- -->[RFC 6241]<!-- --> is used to communicate YANG-compatible actions and data to/from/among remote devices.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="link-layer">Link Layer<a href="#link-layer" class="hash-link" aria-label="Direct link to Link Layer" title="Direct link to Link Layer">​</a></h2><p>We refer to any device that runs a link-layer protocol as a <strong>node</strong>. Nodes include hosts, routers, switches, and WiFi access points. We will also refer to the communication channels that connect adjacent nodes along the communication path as <strong>links</strong>.</p><p>The basic service of the link layer is to move a network-layer datagram from one node to an adjacent node.</p><p>In order for a datagram to be transferred from source host to destination host, it must be moved over each of the individual links in the end-to-end path. Over a given link, a transmitting node encapsulates the datagram in a <strong>link-layer frame</strong> and transmits the frame into the link.</p><p>There are two types of network links: point-to-point links and broadcast links.</p><p>A point-to-point link consists of a single sender at one end of the link and a single receiver at the other end of the link. The point-to-point protocol (PPP) and high-level data link control (HDLC) are two protocols designed for point-to-point links.</p><p>A broadcast link, can have multiple sending and receiving nodes all connected to the same, single, shared broadcast channel. The term broadcast is used here because when any one node transmits a frame, the channel broadcasts the frame and each of the other nodes receives a copy. Ethernet and wireless LANs are examples of broadcast link-layer technologies.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="multiple-access-protocols">Multiple Access Protocols<a href="#multiple-access-protocols" class="hash-link" aria-label="Direct link to Multiple Access Protocols" title="Direct link to Multiple Access Protocols">​</a></h3><p>A problem of central importance to the link layer: how to coordinate the access of multiple sending and receiving nodes to a shared broadcast channel—the <strong>multiple access problem</strong>. Computer have so-called <strong>multiple access protocols</strong> by which nodes regulate their transmission into the shared broadcast channel. We can classify them to one of three categories: channel partitioning protocols, random access protocols, and taking-turns protocols.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="channel-partitioning-protocols">Channel Partitioning Protocols<a href="#channel-partitioning-protocols" class="hash-link" aria-label="Direct link to Channel Partitioning Protocols" title="Direct link to Channel Partitioning Protocols">​</a></h4><p><strong>Time-division multiplexing (TDM)</strong> divides time into time frames and further divides each time frame into N time slots. Each time slot is then assigned to one of the N nodes. Whenever a node has a packet to send, it transmits the packet’s bits during its assigned time slot in the revolving TDM frame. TDM is appealing because it eliminates collisions and is perfectly fair. However, it has two major drawbacks. First, a node is limited to an average rate of R/N bps even when it is the only node with packets to send. A second drawback is that a node must always wait for its turn in the transmission sequence—again, even when it is the only node with a frame to send.</p><p><strong>Frequency-division multiplexing (FDM)</strong> divides the R bps channel into different frequencies (each with a bandwidth of R/N) and assigns each frequency to one of the N nodes. It avoids collisions and divides the bandwidth fairly among the N nodes. However, FDM also shares a principal disadvantage with TDM—a node is limited to a bandwidth of R/N, even when it is the only node with packets to send.</p><p><strong>Code division multiple access (CDMA)</strong> assigns a different code to each node. Each node then uses its unique code to encode the data bits it sends. If the codes are chosen carefully, CDMA networks have the wonderful property that different nodes can transmit simultaneously.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="random-access-protocols">Random Access protocols<a href="#random-access-protocols" class="hash-link" aria-label="Direct link to Random Access protocols" title="Direct link to Random Access protocols">​</a></h4><p>In a random access protocol, a transmitting node always transmits at the full rate of the channel, namely, R bps. When there is a collision, each node involved in the collision repeatedly retransmits its frame (that is, packet) until its frame gets through without a collision. But when a node experiences a collision, it doesn’t necessarily retransmit the frame right away. Instead it waits a random delay before retransmitting the frame. Each node involved in a collision chooses independent random delays. Because the random delays are independently chosen, it is possible that one of the nodes will pick a delay that is sufficiently less than the delays of the other colliding nodes and will therefore be able to sneak its frame into the channel without a collision.</p><p>A few of the most commonly used random access protocols—the ALOHA protocols and the carrier sense multiple access (CSMA) protocols. Ethernet is a popular and widely deployed CSMA protocol.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="taking-turns-protocols">Taking-Turns Protocols<a href="#taking-turns-protocols" class="hash-link" aria-label="Direct link to Taking-Turns Protocols" title="Direct link to Taking-Turns Protocols">​</a></h4><p>The first one is the <strong>polling protocol</strong>. The polling protocol requires one of the nodes to be designated as a master node. The master node polls each of the nodes in a round-robin fashion. In particular, the master node first sends a message to node 1, saying that it (node 1) can transmit up to some maximum number of frames. After node 1 transmits some frames, the master node tells node 2 it (node 2) can transmit up to the maximum number of frames. (The master node can determine when a node has finished sending its frames by observing the lack of a signal on the channel.) The procedure continues in this manner, with the master node polling each of the nodes in a cyclic manner. The Bluetooth protocol is an example of a polling protocol.</p><p>The second one is the <strong>token-passing protocol</strong>. A small, special-purpose frame known as a token is exchanged among the nodes in some fixed order. When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node. Token passing is decentralized and highly efficient. But it has its problems as well. For example, the failure of one node can crash the entire channel. Or if a node accidentally neglects to release the token, then some recovery procedure must be invoked to get the token back in circulation. Over the years many token-passing protocols have been developed, including the fiber distributed data interface (FDDI) protocol and the IEEE 802.5 token ring protocol, and each one had to address these as well as other sticky issues.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="docsis">DOCSIS<a href="#docsis" class="hash-link" aria-label="Direct link to DOCSIS" title="Direct link to DOCSIS">​</a></h4><p>A cable access network will make for an excellent case study here, as we’ll find aspects of each of these three classes of multiple access protocols with the cable access network! The Data-Over-Cable Service Interface Specifications (DOCSIS) specifies the cable data network architecture and its protocols.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="switched-local-area-networks">Switched Local Area Networks<a href="#switched-local-area-networks" class="hash-link" aria-label="Direct link to Switched Local Area Networks" title="Direct link to Switched Local Area Networks">​</a></h3><p><img loading="lazy" alt="img" src="/assets/images/fe4477ef-50b4-46a3-ad40-997a187b7833-0e6c4c438c32124f07569a7079e4dea1.png" width="2134" height="1398" class="img_ev3q"></p><p>Figure 6.15 shows a switched local network connecting three departments, two servers and a router with four switches. Because these switches operate at the link layer, they switch link-layer frames (rather than network-layer datagrams), don’t recognize network-layer addresses, and don’t use routing algorithms like OSPF to determine paths through the network of layer-2 switches. Instead of using IP addresses, we will soon see that they use link-layer addresses to forward link-layer frames through the network of switches.</p><p>We’ll begin our study of switched LANs by first covering link-layer addressing. We then examine the celebrated Ethernet protocol. After examining link-layer addressing and Ethernet, we’ll look at how link-layer switches operate, and then see how these switches are often used to build large-scale LANs.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="link-layer-addressing-and-arp">Link-Layer Addressing and ARP<a href="#link-layer-addressing-and-arp" class="hash-link" aria-label="Direct link to Link-Layer Addressing and ARP" title="Direct link to Link-Layer Addressing and ARP">​</a></h4><p>In truth, it is not hosts and routers that have link-layer addresses but rather their adapters (that is, network interfaces) that have link-layer addresses. Link-layer switches do not have link-layer addresses associated with their interfaces that connect to hosts and routers. A link-layer address is variously called a LAN address, a physical address, or a <strong>MAC address</strong>. For most LANs (including Ethernet and 802.11 wireless LANs), the MAC address is 6 bytes long, giving <code>2 ^ 48</code> possible MAC addresses.</p><p>Although MAC addresses were designed to be permanent, it is now possible to change an adapter’s MAC address via software. For the rest of this section, however, we’ll assume that an adapter’s MAC address is fixed. One interesting property of MAC addresses is that no two adapters have the same address. The IEEE manages the MAC address space. In particular, when a company wants to manufacture adapters, it purchases a chunk of the address space consisting of 224 addresses for a nominal fee. IEEE allocates the chunk of 224 addresses by fixing the first 24 bits of a MAC address and letting the company create unique combinations of the last 24 bits for each adapter.</p><p>When an adapter wants to send a frame to some destination adapter, the sending adapter inserts the destination adapter’s MAC address into the frame and then sends the frame into the LAN. As we will soon see, a switch occasionally broadcasts an incoming frame onto all of its interfaces. 802.11 also broadcasts frames. Thus, an adapter may receive a frame that isn’t addressed to it. Thus, when an adapter receives a frame, it will check to see whether the destination MAC address in the frame matches its own MAC address. If there is a match, the adapter extracts the enclosed datagram and passes the datagram up the protocol stack. If there isn’t a match, the adapter discards the frame, without passing the network-layer datagram up.</p><p>However, sometimes a sending adapter does want all the other adapters on the LAN to receive and process the frame it is about to send. In this case, the sending adapter inserts a special MAC broadcast address into the destination address field of the frame. For LANs that use 6-byte addresses (such as Ethernet and 802.11), the broadcast address is a string of 48 consecutive 1s (that is, FF-FF-FF-FF-FF-FF in hexadecimal notation).</p><p>Because there are both network-layer addresses (for example, Internet IP addresses) and link-layer addresses (that is, MAC addresses), there is a need to translate between them. For the Internet, this is the job of the <strong>Address Resolution Protocol (ARP)</strong>.</p><p>Each host and router has an ARP table in its memory, which contains mappings of IP addresses to MAC addresses. But what if the ARP table doesn’t currently have an entry for the destination? In this case, the sender uses the ARP protocol to resolve the address.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ethernet">Ethernet<a href="#ethernet" class="hash-link" aria-label="Direct link to Ethernet" title="Direct link to Ethernet">​</a></h4><p>Today, Ethernet is by far the most prevalent wired LAN technology, and it is likely to remain so for the foreseeable future. One might say that Ethernet has been to local area networking what the Internet has been to global networking.</p><p><img loading="lazy" alt="img" src="/assets/images/f5a8f2be-2251-46ac-8285-048cc0776700-abe926e44379c756ae6e21295d924a84.png" width="2317" height="417" class="img_ev3q"></p><p>We can learn a lot about Ethernet by examining the Ethernet frame:</p><ul><li>Data field (46 to 1,500 bytes). This field carries the IP datagram. The maximum transmission unit (MTU) of Ethernet is 1,500 bytes. This means that if the IP datagram exceeds 1,500 bytes, then the host has to fragment the datagram, as discussed in Section 4.3.2. The minimum size of the data field is 46 bytes. This means that if the IP datagram is less than 46 bytes, the data field has to be “stuffed” to fill it out to 46 bytes. When stuffing is used, the data passed to the network layer contains the stuffing as well as an IP datagram. The network layer uses the length field in the IP datagram header to remove the stuffing.</li><li>Destination address (6 bytes). This field contains the MAC address of the destination adapter. When destination adapter receives an Ethernet frame whose destination address is its or the MAC broadcast address, it passes the contents of the frame’s data field to the network layer; if it receives a frame with any other MAC address, it discards the frame.</li><li>Source address (6 bytes). This field contains the MAC address of the adapter that transmits the frame onto the LAN.</li><li>Type field (2 bytes). The type field permits Ethernet to multiplex network-layer protocols. To understand this, we need to keep in mind that hosts can use other network-layer protocols besides IP (e.g. ARP).</li><li>Cyclic redundancy check (CRC) (4 bytes). As discussed in Section 6.2.3, the purpose of the CRC field is to allow the receiving adapter to detect bit errors in the frame.</li><li>Preamble (8 bytes).</li></ul><p>Many Ethernet technologies have been standardized over the years by the IEEE 802.3 CSMA/CD (Ethernet) working group. Ethernet is both a link-layer and a physical-layer specification and is carried over a variety of physical media including coaxial cable, copper wire, and fiber.</p><p>In a switch-based Ethernet LAN there are no collisions and, therefore, there is no need for a MAC protocol!</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="link-layer-switches">Link-Layer Switches<a href="#link-layer-switches" class="hash-link" aria-label="Direct link to Link-Layer Switches" title="Direct link to Link-Layer Switches">​</a></h4><p>The role of the switch is to receive incoming link-layer frames and forward them onto outgoing links; we’ll study this forwarding function in detail in this subsection. We’ll see that the switch itself is transparent to the hosts and routers in the subnet; that is, a host/router addresses a frame to another host/router (rather than addressing the frame to the switch) and happily sends the frame into the LAN, unaware that a switch will be receiving the frame and forward- ing it.</p><p>Filtering is the switch function that determines whether a frame should be for- warded to some interface or should just be dropped. Forwarding is the switch function that determines the interfaces to which a frame should be directed, and then moves the frame to those interfaces. Switch filtering and forwarding are done with a switch table. As long as the switch table is complete and accurate, the switch forwards frames toward destinations without any broadcasting.</p><p>As we learned in Chapter 4, routers are store-and-forward packet switches that for- ward packets using network-layer addresses. Although a switch is also a store-and- forward packet switch, it is fundamentally different from a router in that it forwards packets using MAC addresses. Whereas a router is a layer-3 packet switch, a switch is a layer-2 packet switch. Recall, however, that we learned in Section 4.4 that mod- ern switches using the “match plus action” operation can be used to forward a layer-2 frame based on the frame&#x27;s destination MAC address, as well as a layer-3 datagram using the datagram&#x27;s destination IP address. Indeed, we saw that switches using the OpenFlow standard can perform generalized packet forwarding based on any of eleven different frame, datagram, and transport-layer header fields.</p><p>Even though switches and routers are fundamentally different, network admin- istrators must often choose between them when installing an interconnection device. What are the pros and cons of the two approaches?</p><p>First consider the pros and cons of switches. As mentioned above, switches are plug-and-play, a property that is cherished by all the overworked network adminis- trators of the world. Switches can also have relatively high filtering and forwarding rates—as shown in Figure 6.24, switches have to process frames only up through layer 2, whereas routers have to process datagrams up through layer 3. On the other hand, to prevent the cycling of broadcast frames, the active topology of a switched network is restricted to a spanning tree. Also, a large switched network would require large ARP tables in the hosts and routers and would generate substantial ARP traffic and processing. Furthermore, switches are susceptible to broadcast storms—if one host goes haywire and transmits an endless stream of Ethernet broadcast frames, the switches will forward all of these frames, causing the entire network to collapse.</p><p>Now consider the pros and cons of routers. Because network addressing is often hierarchical (and not flat, as is MAC addressing), packets do not normally cycle through routers even when the network has redundant paths. (However, packets can cycle when router tables are misconfigured; but as we learned in Chapter 4, IP uses a special datagram header field to limit the cycling.) Thus, packets are not restricted to a spanning tree and can use the best path between source and destination. Because routers do not have the spanning tree restriction, they have allowed the Internet to be built with a rich topology that includes, for example, multiple active links between Europe and North America. Another feature of routers is that they provide firewall protection against layer-2 broadcast storms. Perhaps the most significant drawback of routers, though, is that they are not plug-and-play—they and the hosts that connect to them need their IP addresses to be configured. Also, routers often have a larger per-packet processing time than switches, because they have to process up through the layer-3 fields.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-day-in-the-life-of-a-web-page-request">A Day in the Life of a Web Page Request<a href="#a-day-in-the-life-of-a-web-page-request" class="hash-link" aria-label="Direct link to A Day in the Life of a Web Page Request" title="Direct link to A Day in the Life of a Web Page Request">​</a></h3><p>A student, Bob, connects his laptop to an Ethernet cable connected to the school’s Ethernet switch and downloads a Web page.</p><p><img loading="lazy" alt="img" src="/assets/images/c2a1a1a5-7c35-49aa-95ad-cb9b82cb3490-0691b8db702e42924c399637b6810ec9.png" width="1941" height="1529" class="img_ev3q"></p><ol><li>The operating system on Bob’s laptop creates a DHCP request message (Section 4.3.3) and puts this message within a UDP segment (Section 3.3) with destination port 67 (DHCP server) and source port 68 (DHCP client). The UDP segment is then placed within an IP datagram (Section 4.3.1) with a broadcast IP destination address (255.255.255.255) and a source IP address of 0.0.0.0, since Bob’s laptop doesn’t yet have an IP address.</li><li>The IP datagram containing the DHCP request message is then placed within an Ethernet frame (Section 6.4.2). The Ethernet frame has a destination MAC addresses of FF:FF:FF:FF:FF:FF so that the frame will be broadcast to all devices connected to the switch (hopefully including a DHCP server); the frame’s source MAC address is that of Bob’s laptop, 00:16:D3:23:68:8A.</li><li>The broadcast Ethernet frame containing the DHCP request is the first frame sent by Bob’s laptop to the Ethernet switch. The switch broadcasts the incoming frame on all outgoing ports, including the port connected to the router.</li><li>The router receives the broadcast Ethernet frame containing the DHCP request on its interface with MAC address 00:22:6B:45:1F:1B and the IP datagram is extracted from the Ethernet frame. The datagram’s broadcast IP destination address indicates that this IP datagram should be processed by upper layer protocols at this node, so the datagram’s payload (a UDP segment) is thus demultiplexed (Section 3.2) up to UDP, and the DHCP request message is extracted from the UDP segment. The DHCP server now has the DHCP request message.</li><li>Let’s suppose that the DHCP server running within the router can allocate IP addresses in the CIDR (Section 4.3.3) block 68.85.2.0/24. In this example, all IP addresses used within the school are thus within Comcast’s address block. Let’s suppose the DHCP server allocates address 68.85.2.101 to Bob’s laptop. The DHCP server creates a DHCP ACK message (Section 4.3.3) containing this IP address, as well as the IP address of the DNS server (68.87.71.226), the IP address for the default gateway router (68.85.2.1), and the subnet block (68.85.2.0/24) (equivalently, the “network mask”). The DHCP message is put inside a UDP segment, which is put inside an IP datagram, which is put inside an Ethernet frame. The Ethernet frame has a source MAC address of the router’s interface to the home network (00:22:6B:45:1F:1B) and a destination MAC address of Bob’s laptop (00:16:D3:23:68:8A).</li><li>The Ethernet frame containing the DHCP ACK is sent (unicast) by the router to the switch. Because the switch is self-learning (Section 6.4.3) and previously received an Ethernet frame (containing the DHCP request) from Bob’s laptop, the switch knows to forward a frame addressed to 00:16:D3:23:68:8A only to the output port leading to Bob’s laptop.</li><li>Bob’s laptop receives the Ethernet frame containing the DHCP ACK, extracts the IP datagram from the Ethernet frame, extracts the UDP segment from the IP datagram, and extracts the DHCP ACK message from the UDP segment. Bob’s DHCP client then records its IP address and the IP address of its DNS server. It also installs the address of the default gateway into its IP forward- ing table (Section 4.1). Bob’s laptop will send all datagrams with destination address outside of its subnet 68.85.2.0/24 to the default gateway. At this point, Bob’s laptop has initialized its networking components and is ready to begin processing the Web page fetch.</li><li>The operating system on Bob’s laptop thus creates a DNS query message (Section 2.5.3), putting the string &quot;<a href="http://www.google.com%22" target="_blank" rel="noopener noreferrer">www.google.com&quot;</a> in the question section of the DNS message. This DNS message is then placed within a UDP segment with a destination port of 53 (DNS server). The UDP segment is then placed within an IP datagram with an IP destination address of 68.87.71.226 (the address of the DNS server returned in the DHCP ACK in step 5) and a source IP address of 68.85.2.101.</li><li>Bob’s laptop then places the datagram containing the DNS query message in an Ethernet frame. This frame will be sent (addressed, at the link layer) to the gateway router in Bob’s school’s network. However, even though Bob’s laptop knows the IP address of the school’s gateway router (68.85.2.1) via the DHCP ACK message in step 5 above, it doesn’t know the gateway router’s MAC address. In order to obtain the MAC address of the gateway router, Bob’s laptop will need to use the ARP protocol (Section 6.4.1).</li><li>Bob’s laptop creates an ARP query message with a target IP address of 68.85.2.1 (the default gateway), places the ARP message within an Ethernet frame with a broadcast destination address (FF:FF:FF:FF:FF:FF) and sends the Ethernet frame to the switch, which delivers the frame to all connected devices, including the gateway router.</li><li>ThegatewayrouterreceivestheframecontainingtheARPquerymessageonthe interface to the school network, and finds that the target IP address of 68.85.2.1 in the ARP message matches the IP address of its interface. The gateway router thus prepares an ARP reply, indicating that its MAC address of 00:22:6B:45:1F:1B corresponds to IP address 68.85.2.1. It places the ARP reply message in an Ethernet frame, with a destination address of 00:16:D3:23:68:8A (Bob’s laptop) and sends the frame to the switch, which delivers the frame to Bob’s laptop.</li><li>Bob’s laptop receives the frame containing the ARP reply message and extracts the MAC address of the gateway router (00:22:6B:45:1F:1B) from the ARP reply message.</li><li>Bob’s laptop can now (finally!) address the Ethernet frame containing the DNS query to the gateway router’s MAC address. Note that the IP datagram in this frame has an IP destination address of 68.87.71.226 (the DNS server), while the frame has a destination address of 00:22:6B:45:1F:1B (the gateway router). Bob’s laptop sends this frame to the switch, which delivers the frame to the gateway router.</li><li>The gateway router receives the frame and extracts the IP datagram containing the DNS query. The router looks up the destination address of this datagram (68.87.71.226) and determines from its forwarding table that the datagram should be sent to the leftmost router in the Comcast network in Figure 6.32. The IP datagram is placed inside a link-layer frame appropriate for the link connecting the school’s router to the leftmost Comcast router and the frame is sent over this link.</li><li>The leftmost router in the Comcast network receives the frame, extracts the IP datagram, examines the datagram’s destination address (68.87.71.226) and determines the outgoing interface on which to forward the datagram toward the DNS server from its forwarding table, which has been filled in by Comcast’s intra-domain protocol (such as RIP, OSPF or IS-IS, Section 5.3) as well as the Internet’s inter-domain protocol, BGP (Section 5.4).</li><li>Eventually the IP datagram containing the DNS query arrives at the DNS server. The DNS server extracts the DNS query message, looks up the name <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a> in its DNS database (Section 2.5), and finds the DNS resource record that contains the IP address (64.233.169.105) for <a href="http://www.google.com." target="_blank" rel="noopener noreferrer">www.google.com.</a> (assuming that it is currently cached in the DNS server). Recall that this cached data originated in the authoritative DNS server (Section 2.5.2) for google.com. The DNS server forms a DNS reply message containing this hostname-to-IP-address mapping, and places the DNS reply message in a UDP segment, and the segment within an IP datagram addressed to Bob’s laptop (68.85.2.101). This datagram will be forwarded back through the Comcast network to the school’s router and from there, via the Ethernet switch to Bob’s laptop.</li><li>Bob’s laptop extracts the IP address of the server <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a> from the DNS message. Finally, after a lot of work, Bob’s laptop is now ready to contact the <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a> server!</li><li>Now that Bob’s laptop has the IP address of <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a>, it can create the TCP socket (Section 2.7) that will be used to send the HTTP GET message (Section 2.2.3) to <a href="http://www.google.com." target="_blank" rel="noopener noreferrer">www.google.com.</a> When Bob creates the TCP socket, the TCP in Bob’s laptop must first perform a three-way handshake (Section 3.5.6) with the TCP in <a href="http://www.google.com." target="_blank" rel="noopener noreferrer">www.google.com.</a> Bob’s laptop thus first creates a TCP SYN segment with destination port 80 (for HTTP), places the TCP segment inside an IP datagram with a destination IP address of 64.233.169.105 (<a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a>), places the datagram inside a frame with a destination MAC address of 00:22:6B:45:1F:1B (the gateway router) and sends the frame to the switch.</li><li>The routers in the school network, Comcast’s network, and Google’s network forward the datagram containing the TCP SYN toward <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a>, using the forwarding table in each router, as in steps 14–16 above. Recall that the router forwarding table entries governing forwarding of packets over the inter-domain link between the Comcast and Google networks are determined by the BGP protocol (Chapter 5).</li><li>Eventually, the datagram containing the TCP SYN arrives at<a href="http://www.google.com." target="_blank" rel="noopener noreferrer">www.google.com.</a> The TCP SYN message is extracted from the datagram and demultiplexed to the welcome socket associated with port 80. A connection socket (Section 2.7) is created for the TCP connection between the Google HTTP server and Bob’s laptop. A TCP SYNACK (Section 3.5.6) segment is generated, placed inside a datagram addressed to Bob’s laptop, and finally placed inside a link-layer frame appropriate for the link connecting <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a> to its first-hop router.</li><li>The datagram containing the TCP SYNACK segment is forwarded through the Google, Comcast, and school networks, eventually arriving at the Ethernet controller in Bob’s laptop. The datagram is demultiplexed within the operating system to the TCP socket created in step 18, which enters the connected state.</li><li>With the socket on Bob’s laptop now (finally!) ready to send bytes to <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a>, Bob’s browser creates the HTTP GET message (Section 2.2.3) containing the URL to be fetched. The HTTP GET message is then written into the socket, with the GET message becoming the payload of a TCP segment. The TCP segment is placed in a datagram and sent and delivered to <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a> as in steps 18–20 above.</li><li>The HTTP server at <a href="http://www.google.com" target="_blank" rel="noopener noreferrer">www.google.com</a> reads the HTTP GET message from the TCP socket, creates an HTTP response message (Section 2.2), places the requested Web page content in the body of the HTTP response message, and sends the message into the TCP socket.</li><li>The datagram containing the HTTP reply message is forwarded through the Google, Comcast, and school networks, and arrives at Bob’s laptop. Bob’s Web browser program reads the HTTP response from the socket, extracts the html for the Web page from the body of the HTTP response, and finally (finally!) displays the Web page!</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="wireless-and-mobile-networks">Wireless and Mobile Networks<a href="#wireless-and-mobile-networks" class="hash-link" aria-label="Direct link to Wireless and Mobile Networks" title="Direct link to Wireless and Mobile Networks">​</a></h2><p>A <strong>base station</strong> is responsible for sending and receiving data (e.g., packets) to and from a <strong>wireless host</strong> that is associated with that base station. Cell towers in cellular networks and access points in 802.11 wireless LANs are examples of base stations.</p><p>When a mobile host moves beyond the range of one base station and into the range of another—a process referred to as <strong>handoff</strong> or handover.</p><p>At the highest level we can classify wireless networks to:</p><ul><li>Single-hop, infrastructure-based. These networks have a base station that is connected to a larger wired network (e.g., the Internet). Furthermore, all communication is between this base station and a wireless host over a single wireless hop. The 802.11 networks you use in the classroom, café, or library; and the 4G LTE data networks all fall in this category.</li><li>Single-hop, infrastructure-less. In these networks, there is no base station that is connected to a wireless network. However, as we will see, one of the nodes in this single-hop network may coordinate the transmissions of the other nodes. Bluetooth networks fall in this.</li><li>Multi-hop, infrastructure-based. In these networks, a base station is present that is wired to the larger network. However, some wireless nodes may have to relay their communication through other wireless nodes in order to communicate via the base station. Some wireless sensor networks and so-called wireless mesh networks deployed in homes fall in this category.</li><li>Multi-hop, infrastructure-less. There is no base station in these networks, and nodes may have to relay messages among several other nodes in order to reach a destination. Nodes may also be mobile, with connectivity changing among nodes—a class of networks known as mobile ad hoc networks (MANETs). If the mobile nodes are vehicles, the network is a vehicular ad hoc network (VANET). As you might imagine, the development of protocols for such net- works is challenging and is the subject of much ongoing research.</li></ul><p>Bluetooth operates over short ranges, at low power, and at low cost. Bluetooth networks operate in the unlicensed 2.4 GHz radio band. The Bluetooth wireless channel is operated in a TDM manner, with time slots of 625 microseconds. Bluetooth data rates can reach up to 3 Mbps.</p><p>Bluetooth networks are ad hoc networks. Bluetooth devices must organize themselves into a piconet of up to eight active devices. One of these devices is designated as the master, with the remaining devices acting as clients. In addition to the active devices, there can also be up to 255 “parked” devices in the piconet. These parked devices are often in some form of “sleep mode” to conserve energy and will awaken periodically, according to the master’s schedule, to receive beacon messages from the master. A parked device cannot communicate until its status has been changed from parked to active by the master node.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="wireless-links-and-wifi">Wireless Links and WiFi<a href="#wireless-links-and-wifi" class="hash-link" aria-label="Direct link to Wireless Links and WiFi" title="Direct link to Wireless Links and WiFi">​</a></h3><p>Wireless links differ from their wired counterparts in a number important ways: Decreasing signal strength; Interference from other sources; Multipath propagation. Bit errors will be more common in wireless links than in wired links. For this reason, wireless link protocols employ not only powerful CRC error detection codes, but also link-level reliable-data-transfer protocols that retransmit corrupted frames.</p><p>This host receives an electromagnetic signal that is a combination of a degraded form of the original signal transmitted by the sender (degraded due to the attenuation and multipath propagation effects that we discussed above, among others) and background noise in the environment. The <strong>signal-to-noise ratio (SNR)</strong> is a relative measure of the strength of the received signal and this noise. The SNR is typically measured in units of decibels (<strong>dB</strong>). A larger SNR makes it easier for the receiver to extract the transmitted signal from the background noise.</p><p>Although many technologies and standards for wireless LANs were developed in the 1990s, one particular class of standards has clearly emerged as the winner: the IEEE 802.11 wireless LAN, also known as WiFi.</p><p>The fundamental building block of the 802.11 architecture is the basic service set (BSS). A BSS contains one or more wireless stations and a central base station, known as an <strong>access point (AP)</strong> in 802.11 parlance. As with Ethernet devices, each 802.11 wireless station has a 6-byte MAC address that is stored in the firmware of the station’s adapter (that is, 802.11 network interface card). Each AP also has a MAC address for its wireless interface. As with Ethernet, these MAC addresses are administered by IEEE and are (in theory) globally unique.</p><p><img loading="lazy" alt="img" src="/assets/images/f1ef6d59-64c0-476c-83ed-c0d97595c328-67842dcdfdfb1e150515e85248f42cb8.png" width="1830" height="1346" class="img_ev3q"></p><p>When a network administrator installs an AP, the administrator assigns a one- or two-word <strong>Service Set Identifier (SSID)</strong> to the access point（即 Wi-Fi 列表里显示的名称）. The 802.11 standard requires that an AP periodically send <strong>beacon frames</strong>, each of which includes the AP’s SSID and MAC address.</p><p>The process of scanning channels and listening for beacon frames is known as passive scanning. A wireless device can also perform active scanning, by broadcasting a probe frame that will be received by all APs within the wireless device’s range.</p><p>In order to create an association with a particular AP, the wireless device may be required to authenticate itself to the AP. One approach is to permit access based on a device’s MAC address. A second approach employs usernames and passwords.</p><p>Because multiple wireless devices, or the AP itself may want to transmit data frames at the same time over the same channel, a multiple access protocol is needed to coordinate the transmissions. Inspired by the huge success of Ethernet and its random access protocol, the designers of 802.11 chose <strong>CSMA with collision avoidance (CSMA/CA)</strong>. 802.11 uses collision-avoidance techniques and link-layer acknowledgment/retransmission (ARQ) scheme.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mobility-in-the-same-ip-subnet">Mobility in the Same IP Subnet<a href="#mobility-in-the-same-ip-subnet" class="hash-link" aria-label="Direct link to Mobility in the Same IP Subnet" title="Direct link to Mobility in the Same IP Subnet">​</a></h3><p>In order to increase the physical range of a wireless LAN, companies and universities will often deploy multiple BSSs within the same IP subnet. This naturally raises the issue of mobility among the BSSs—how do wireless stations seamlessly move from one BSS to another while maintaining ongoing TCP sessions?</p><p>Mobility can be handled in a relatively straightforward manner when the BSSs are part of the subnet.</p><p><img loading="lazy" alt="img" src="/assets/images/58f51861-ebbb-43f7-9076-d060ff13b11a-2d9fa37e61020dd41e3ff81b58eb005b.png" width="1918" height="1116" class="img_ev3q"></p><p>Figure 7.15 shows two interconnected BSSs with a host, H1, moving from BSS1 to BSS2. Because in this example the interconnection device that connects the two BSSs is not a router, all of the stations in the two BSSs, including the APs, belong to the same IP subnet. Thus, when H1 moves from BSS1 to BSS2, it may keep its IP address and all of its ongoing TCP connections. If the interconnection device were a router, then H1 would have to obtain a new IP address in the subnet in which it was moving. This address change would disrupt (and eventually terminate) any on-going TCP connections at H1. In Section 7.6, we’ll see how a network-layer mobility protocol, such as mobile IP, can be used to avoid this problem.</p><p>As H1 wanders away from AP1, H1 detects a weakening signal from AP1 and starts to scan for a stronger signal. H1 receives beacon frames from AP2 (which in many corporate and university settings will have the same SSID as AP1). H1 then disassociates with AP1 and associates with AP2, while keeping its IP address and maintaining its ongoing TCP sessions.</p><p>But what about the switch? How does it know that the host has moved from one AP to another? As you may recall from Chapter 6, switches are “self-learning” and automatically build their forwarding tables. This self-learning feature nicely handles occasional moves; however, switches were not designed to support highly mobile users who want to maintain TCP connections while moving between BSSs. To appreciate the problem here, recall that before the move, the switch has an entry in its forwarding table that pairs H1’s MAC address with the outgoing switch interface through which H1 can be reached. If H1 is initially in BSS1, then a datagram destined to H1 will be directed to H1 via AP1. Once H1 associates with BSS2, however, its frames should be directed to AP2. One solution (a bit of a hack, really) is for AP2 to send a broadcast Ethernet frame with H1’s source address to the switch just after he new association. When the switch receives the frame, it updates its forwarding table, allowing H1 to be reached via AP2. The 802.11f standards group is developing an inter-AP protocol to handle these and related issues.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cellular-networks-4g-and-5g">Cellular Networks: 4G and 5G<a href="#cellular-networks-4g-and-5g" class="hash-link" aria-label="Direct link to Cellular Networks: 4G and 5G" title="Direct link to Cellular Networks: 4G and 5G">​</a></h3><p>In a relatively short span of 20 years, cellular carrier networks have undergone an astonishing transition from being almost exclusively circuit-switched telephone networks to being all-IP packet-switched data networks.</p><p>The term cellular refers to the fact that the region covered by a cellular network is partitioned into a number of geographic coverage areas, known as cells. Each cell contains a base station that transmits signals to, and receives signals from, the mobile devices currently in its cell.</p><p>The 4G networks that are pervasive implement the 4G Long-Term Evolution standard, or more succinctly <strong>4G LTE</strong>.</p><p>The mobile device is a network endpoint, with an IP address (obtained through NAT). The mobile device also has a globally unique 64-bit identifier called the <strong>International Mobile Subscriber Identity (IMSI)</strong>, which is stored on its SIM (Subscriber Identity Module) card.</p><table><thead><tr><th>LTE Element</th><th>Description</th><th>Similar WLAN function(s)</th></tr></thead><tbody><tr><td>Mobile device</td><td>End user’s IP-capable wireless/mobile device</td><td>Host, end-system</td></tr><tr><td>Base Station</td><td>Network side of wireless access link into LTE network</td><td>Access point (AP), although the LTE base station performs many functions not found in WLANs</td></tr><tr><td>The Mobility Management Entity (MME)</td><td>Coordinator for mobile device services: authentication, mobility management</td><td>Access point (AP), although the MME performs many functions not found in WLANs</td></tr><tr><td>Home Subscriber Server (HSS)</td><td>Located in a mobile device’s home network, providing authentication, access privileges in home and visited networks</td><td>No WLAN equivalent</td></tr><tr><td>Serving Gateway (S-GW), PDN-Gateway (P-GW)</td><td>Routers in a cellular carrier’s network, coordinating forwarding to outside of the carrier’s network</td><td>iBGP and eBGP routers in access ISP network</td></tr><tr><td>Radio Access Network</td><td>Wireless link between mobile device and a base station</td><td>802.11 wireless link between mobile and AP</td></tr></tbody></table><p>LTE uses a combination of frequency division multiplexing and time division multi- plexing on the downstream channel, known as orthogonal frequency division multi- plexing (OFDM).（频分复用和时分复用结合，称为正交频分复用）</p><p>The ultimate wide-area data service would be one with ubiquitous gigabit connec- tion speeds, extremely low latency, and unrestricted limitations on the number of users and devices that could be supported in any region. It is expected that 5G, for which progressively improved versions are likely to be rolled out in the 2020 decade, will make a big step towards achieving the goals of the ultimate wide-area data service.</p><p>5G standards divide frequencies into two groups: FR1 (450 MHz–6 GHz) and FR2 (24 GHz–52 GHz). FR2 frequencies are also known as millimeter wave frequencies. Many 5G innovations will be a direct result of working in the millimeter wave fre- quencies in the 24 GHz–52 GHz band.</p><p>5G is expected to provide a 100x increase in capacity in urban areas. Similarly, owing to the much wider fre- quency band, 5G is expected to provide peak download rates of 1 Gbps or higher. Millimeter wave signals are, however, easily blocked by buildings and trees. Small cell stations are needed to fill in coverage gaps between base stations and users. In a highly populous region, the distance between two small cells could vary from 10 to 100 meters.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="network-security">Network Security<a href="#network-security" class="hash-link" aria-label="Direct link to Network Security" title="Direct link to Network Security">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="network-under-attack">Network Under Attack<a href="#network-under-attack" class="hash-link" aria-label="Direct link to Network Under Attack" title="Direct link to Network Under Attack">​</a></h3><p>Much of the <strong>malware</strong> out there today is <strong>self-replicating</strong>: once it infects one host, from that host it seeks entry into other hosts over the Internet, and from the newly infected hosts, it seeks entry into yet more hosts. Malware can spread in the form of a <strong>virus</strong> or a <strong>worm</strong>. Viruses are malware that require some form of user interaction to infect the user’s device. Worms are malware that can enter a device without any explicit user interaction.</p><p>Another broad class of security threats are known as <strong>denial-of-service (DoS)</strong> attacks. As the name suggests, a DoS attack renders a network, host, or other piece of infrastructure unusable by legitimate users.</p><p>A passive receiver that records a copy of every packet that flies by is called a <strong>packet sniffer</strong>.</p><p>It is surprisingly easy to create a packet with an arbitrary source address, packet content, and destination address and then transmit this hand-crafted packet into the Internet, which will dutifully forward the packet to its destination. Imagine the unsuspecting receiver (say an Internet router) who receives such a packet, takes the (false) source address as being truthful, and then performs some command embedded in the packet’s contents (say modifies its forwarding table). The ability to inject packets into the Internet with a false source address is known as <strong>IP spoofing</strong>, and is but one of many ways in which one user can masquerade as another user.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="symmetric-key-cryptography">Symmetric Key Cryptography<a href="#symmetric-key-cryptography" class="hash-link" aria-label="Direct link to Symmetric Key Cryptography" title="Direct link to Symmetric Key Cryptography">​</a></h3><p>Prefer: AES-GCM, ChaCha20/Poly1305.</p><p>Deprecated: RC4, 3DES-CBC, AES-CBC.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="public-key-encryption">Public Key Encryption<a href="#public-key-encryption" class="hash-link" aria-label="Direct link to Public Key Encryption" title="Direct link to Public Key Encryption">​</a></h3><p>Prefer: &gt;= 2048-bit RSA, Elliptic Curves</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cryptographic-hash-functions">Cryptographic Hash Functions<a href="#cryptographic-hash-functions" class="hash-link" aria-label="Direct link to Cryptographic Hash Functions" title="Direct link to Cryptographic Hash Functions">​</a></h3><p>Prefer: SHA-2 Family.</p><p>Deprecated: MD5, SHA-1.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="digital-signatures">Digital Signatures<a href="#digital-signatures" class="hash-link" aria-label="Direct link to Digital Signatures" title="Direct link to Digital Signatures">​</a></h3><p>An important application of digital signatures is public key certification, that is, certifying that a public key belongs to a specific entity.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="transport-layer-security-tls">Transport Layer Security (TLS)<a href="#transport-layer-security-tls" class="hash-link" aria-label="Direct link to Transport Layer Security (TLS)" title="Direct link to Transport Layer Security (TLS)">​</a></h3><p>Desirable properties of secure communication (Transport layer security provides):</p><ul><li>Encryption: So it can’t be read by other people.</li><li>Integrity: The message can’t be altered without detection.</li><li>Authentication: Prove the identity of exactly who you are talking to.</li></ul><p>TLS is often used to provide security to transactions that take place over HTTP. However, because TLS secures TCP, it can be employed by any application that runs over TCP. TLS provides a simple Application Programmer Interface (API) with sockets, which is similar and analogous to TCP’s API.</p><p>TLS has three phases: handshake, key derivation, and data transfer. We now describe these three phases for a communication session between a client (Bob) and a server (Alice), with Alice having a private/public key pair and a certificate that binds her identity to her public key.</p><ol><li>Once the TCP connection is established, Bob sends Alice a hello message. The client sends a list of cryptographic algorithms it supports, along with a client nonce.</li><li>From the list, the server chooses a symmetric algorithm (for example, AES) and a public key algorithm (for example, RSA with a specific key length), and HMAC algorithm (MD5 or SHA-1) along with the HMAC keys. It sends back to the client its choices, as well as a certificate and a server nonce.</li><li>Because the certificate has been certified by a CA, Bob knows for sure that the public key in the certificate belongs to Alice. Bob generates a Pre-Master Secret (PMS), encrypts the PMS with the server’s public key, and sends the encrypted PMS to the server. The client sends the HMAC of all the handshake messages.</li><li>Using the same key derivation function (as specified by the TLS standard), the client and server independently compute the <strong>Master Secret (MS)</strong> from the PMS and nonces. The MS is then sliced up to generate <strong>the two encryption and two HMAC keys</strong>. HMAC is a standardized hashed message authentication code (MAC). Henceforth, all messages sent between client and server are encrypted and authenticated (with the HMAC). The server sends the HMAC of all the handshake messages.</li></ol><p>Four keys:</p><ul><li>EB = session encryption key for data sent from Bob to Alice</li><li>MB = session HMAC key for data sent from Bob to Alice</li><li>EA = session encryption key for data sent from Alice to Bob</li><li>MA = session HMAC key for data sent from Alice to Bob</li></ul><p>Now that Alice and Bob share the same four session keys (EB, MB, EA, and MA), they can start to send secured data to each other over the TCP connection. Since TCP is a byte-stream protocol, TLS breaks the data stream into <strong>records</strong>, appends an HMAC to each record for integrity checking, and then encrypts the record+HMAC. This encrypted package is then passed to TCP for transport over the Internet.</p><p><img loading="lazy" alt="img" src="/assets/images/6dd1c78b-2527-4a51-90ea-8fa905ba93f4-79f3f7baf07e87aa895e3fc462bfa0c1.png" width="2246" height="510" class="img_ev3q"></p><p>Bob maintains a sequence number counter, which begins at zero and is incremented for each TLS record he sends. Bob doesn’t actually include a sequence number in the record itself, but when he calculates the HMAC, he includes the sequence number in the HMAC calculation. Thus, the HMAC is now a hash of the data plus the HMAC key plus the current sequence number. Alice tracks Bob’s sequence numbers, allowing her to verify the data integrity of a record by including the appropriate sequence number in the HMAC calculation. This use of TLS sequence numbers prevents Trudy from carrying out a woman-in-the-middle attack, such as reordering or replaying segments.</p><p>You may be wondering why there are nonces in steps 1 and 2. Don’t sequence numbers suffice for preventing the segment replay attack? The answer is yes, but they don’t alone prevent the “connection replay attack.” Suppose Trudy sniffs all messages between Alice and Bob. The next day, Trudy masquerades as Bob and sends to Alice exactly the same sequence of messages that Bob sent to Alice on the previous day. If Alice doesn’t use nonces, she will respond with exactly the same sequence of messages she sent the previous day. Alice will not suspect any funny business, as each message she receives will pass the integrity check. If Alice is an e-commerce server, she will think that Bob is placing a second order (for exactly the same thing). On the other hand, by including a nonce in the protocol, Alice will send different nonces for each TCP session, causing the encryption keys to be different on the two days. Therefore, when Alice receives played-back TLS records from Trudy, the records will fail the integrity checks, and the bogus e-commerce transaction will not succeed. In summary, in TLS, nonces are used to defend against the “connection replay attack” and sequence numbers are used to defend against replaying individual packets during an ongoing session.</p><p>At some point, either Bob or Alice will want to end the TLS session. One approach would be to let Bob end the TLS session by simply terminating the underlying TCP connection. But such a naive design sets the stage for the truncation attack. If Trudy were to do this, Alice would think she received all of Bob’s data when actuality she only received a portion of it.</p><p>The solution to this problem is to indicate in the type field whether the record serves to terminate the TLS session. (Although the TLS type is sent in the clear, it is authenticated at the receiver using the record’s HMAC.) By including such a field, if Alice were to receive a TCP FIN before receiving a closure TLS record, she would know that something funny was going on.</p><p><img loading="lazy" alt="img-80" src="/assets/images/7A53B42F-BDBE-47C9-9592-4123314BF45A-398e9837b2b137e6611329af057ad4d7.png" width="1184" height="1402" class="img_ev3q"></p><blockquote><p><a href="https://segmentfault.com/a/1190000021494676" target="_blank" rel="noopener noreferrer">HTTPS 详解一：附带最精美详尽的 HTTPS 原理图</a></p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="ipsec-and-vpns">IPsec and VPNs<a href="#ipsec-and-vpns" class="hash-link" aria-label="Direct link to IPsec and VPNs" title="Direct link to IPsec and VPNs">​</a></h3><p>The IP security protocol, more commonly known as <strong>IPsec</strong>, provides security at the network layer. IPsec secures IP datagrams between any two network-layer entities, including hosts and routers.</p><p>An institution that extends over multiple geographical regions often desires its own IP network, so that its hosts and servers can send data to each other in a secure and confidential manner. To achieve this goal, the institution could actually deploy a stand-alone physical network, called a private network.</p><p>Instead of deploying and maintaining a private network, many institutions today create VPNs over the existing public Internet. With a VPN, the institution’s inter-office traffic is sent over the public Internet rather than over a physically independent network.</p><p>We&#x27;ll focus on the Encapsulation Security Payload (ESP) protocol in the IPsec protocol suite. The ESP protocol provides source authentication, data integrity, and confidentiality.</p><p>Before sending IPsec datagrams from source entity to destination entity, the source and destination entities create a network-layer logical connection. This logical connection is called a <strong>security association (SA)</strong>. An SA is unidirectional, if both entities want to send secure datagrams to each other, then two SAs need to be established.</p><p>Large, geographically distributed deployments require an automated mechanism for creating the SAs. IPsec does this with the Internet Key Exchange (IKE) protocol.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/dev/chrome"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Chrome</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/dev/computer-science"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">计算机科学</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#computer-network-and-internet" class="table-of-contents__link toc-highlight">Computer Network and Internet</a><ul><li><a href="#network-edge" class="table-of-contents__link toc-highlight">Network Edge</a></li><li><a href="#network-core" class="table-of-contents__link toc-highlight">Network Core</a></li><li><a href="#internet-service-provider" class="table-of-contents__link toc-highlight">Internet Service Provider</a></li><li><a href="#protocol-layers" class="table-of-contents__link toc-highlight">Protocol Layers</a></li></ul></li><li><a href="#application-layer" class="table-of-contents__link toc-highlight">Application Layer</a><ul><li><a href="#the-web-and-http" class="table-of-contents__link toc-highlight">The Web and HTTP</a></li><li><a href="#http-message-format" class="table-of-contents__link toc-highlight">HTTP Message Format</a></li><li><a href="#cookie" class="table-of-contents__link toc-highlight">Cookie</a></li><li><a href="#web-caching-and-the-conditional-get" class="table-of-contents__link toc-highlight">Web Caching and The Conditional GET</a></li><li><a href="#http2" class="table-of-contents__link toc-highlight">HTTP/2</a></li><li><a href="#http3" class="table-of-contents__link toc-highlight">HTTP/3</a></li><li><a href="#email" class="table-of-contents__link toc-highlight">Email</a></li><li><a href="#dns" class="table-of-contents__link toc-highlight">DNS</a></li><li><a href="#p2p" class="table-of-contents__link toc-highlight">P2P</a></li><li><a href="#video-streaming" class="table-of-contents__link toc-highlight">Video Streaming</a></li><li><a href="#content-distribution-networks" class="table-of-contents__link toc-highlight">Content Distribution Networks</a></li><li><a href="#socket-programming" class="table-of-contents__link toc-highlight">Socket Programming</a></li></ul></li><li><a href="#transport-layer" class="table-of-contents__link toc-highlight">Transport Layer</a><ul><li><a href="#multiplexing-and-demultiplexing" class="table-of-contents__link toc-highlight">Multiplexing and Demultiplexing</a></li><li><a href="#udp-1" class="table-of-contents__link toc-highlight">UDP</a></li><li><a href="#tcp-1" class="table-of-contents__link toc-highlight">TCP</a></li><li><a href="#evolution" class="table-of-contents__link toc-highlight">Evolution</a></li></ul></li><li><a href="#network-layer" class="table-of-contents__link toc-highlight">Network Layer</a><ul><li><a href="#data-plane" class="table-of-contents__link toc-highlight">Data Plane</a></li><li><a href="#control-plane" class="table-of-contents__link toc-highlight">Control Plane</a></li></ul></li><li><a href="#link-layer" class="table-of-contents__link toc-highlight">Link Layer</a><ul><li><a href="#multiple-access-protocols" class="table-of-contents__link toc-highlight">Multiple Access Protocols</a></li><li><a href="#switched-local-area-networks" class="table-of-contents__link toc-highlight">Switched Local Area Networks</a></li><li><a href="#a-day-in-the-life-of-a-web-page-request" class="table-of-contents__link toc-highlight">A Day in the Life of a Web Page Request</a></li></ul></li><li><a href="#wireless-and-mobile-networks" class="table-of-contents__link toc-highlight">Wireless and Mobile Networks</a><ul><li><a href="#wireless-links-and-wifi" class="table-of-contents__link toc-highlight">Wireless Links and WiFi</a></li><li><a href="#mobility-in-the-same-ip-subnet" class="table-of-contents__link toc-highlight">Mobility in the Same IP Subnet</a></li><li><a href="#cellular-networks-4g-and-5g" class="table-of-contents__link toc-highlight">Cellular Networks: 4G and 5G</a></li></ul></li><li><a href="#network-security" class="table-of-contents__link toc-highlight">Network Security</a><ul><li><a href="#network-under-attack" class="table-of-contents__link toc-highlight">Network Under Attack</a></li><li><a href="#symmetric-key-cryptography" class="table-of-contents__link toc-highlight">Symmetric Key Cryptography</a></li><li><a href="#public-key-encryption" class="table-of-contents__link toc-highlight">Public Key Encryption</a></li><li><a href="#cryptographic-hash-functions" class="table-of-contents__link toc-highlight">Cryptographic Hash Functions</a></li><li><a href="#digital-signatures" class="table-of-contents__link toc-highlight">Digital Signatures</a></li><li><a href="#transport-layer-security-tls" class="table-of-contents__link toc-highlight">Transport Layer Security (TLS)</a></li><li><a href="#ipsec-and-vpns" class="table-of-contents__link toc-highlight">IPsec and VPNs</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">粤ICP备15029205号 Copyright © 2024 yianzhou</div></div></div></footer></div>
<script src="/assets/js/runtime~main.c41fd4f7.js"></script>
<script src="/assets/js/main.71c80274.js"></script>
</body>
</html>