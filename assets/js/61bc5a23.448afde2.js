"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1951],{59649:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var i=n(87462),l=(n(67294),n(3905));n(61839);const a={},r="FlutterViewController",s={unversionedId:"\u6e90\u7801/flutter-vc",id:"\u6e90\u7801/flutter-vc",title:"FlutterViewController",description:"ViewController",source:"@site/docs/flutter/\u6e90\u7801/flutter-vc.md",sourceDirName:"\u6e90\u7801",slug:"/\u6e90\u7801/flutter-vc",permalink:"/docs/flutter/\u6e90\u7801/flutter-vc",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"PlatformView",permalink:"/docs/flutter/\u6e90\u7801/flutter-platformview"}},o={},u=[{value:"ViewController",id:"viewcontroller",level:2},{value:"FlutterView",id:"flutterview",level:2},{value:"FlutterEngine",id:"flutterengine",level:2},{value:"Shell",id:"shell",level:2},{value:"PlatformViewIOS",id:"platformviewios",level:2},{value:"IOSSurface",id:"iossurface",level:2}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"flutterviewcontroller"},"FlutterViewController"),(0,l.kt)("h2",{id:"viewcontroller"},"ViewController"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"title='flutter/shell/platform/darwin/ios/framework/Source/FlutterViewController.mm'",title:"'flutter/shell/platform/darwin/ios/framework/Source/FlutterViewController.mm'"},'- (instancetype)initWithEngine:(FlutterEngine*)engine\n                       nibName:(nullable NSString*)nibName\n                        bundle:(nullable NSBundle*)nibBundle {\n  self = [super initWithNibName:nibName bundle:nibBundle];\n  if (self) {\n    _viewOpaque = YES;\n    _engine.reset([engine retain]);\n    _engineNeedsLaunch = NO;\n    _flutterView.reset([[FlutterView alloc] initWithDelegate:_engine opaque:self.isViewOpaque]);\n    _weakFactory = std::make_unique<fml::WeakPtrFactory<FlutterViewController>>(self);\n    _ongoingTouches.reset([[NSMutableSet alloc] init]);\n\n    [self performCommonViewControllerInitialization];\n    [engine setViewController:self];\n  }\n\n  return self;\n}\n\n- (void)loadView {\n  self.view = GetViewOrPlaceholder(_flutterView.get());\n  self.view.multipleTouchEnabled = YES;\n  self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n\n  [self installSplashScreenViewIfNecessary];\n  UIScrollView* scrollView = [[UIScrollView alloc] init];\n  scrollView.autoresizingMask = UIViewAutoresizingFlexibleWidth;\n  // The color shouldn\'t matter since it is offscreen.\n  scrollView.backgroundColor = UIColor.whiteColor;\n  scrollView.delegate = self;\n  // This is an arbitrary small size.\n  scrollView.contentSize = CGSizeMake(kScrollViewContentSize, kScrollViewContentSize);\n  // This is an arbitrary offset that is not CGPointZero.\n  scrollView.contentOffset = CGPointMake(kScrollViewContentSize, kScrollViewContentSize);\n  [self.view addSubview:scrollView];\n  _scrollView.reset(scrollView);\n}\n\n- (void)installSplashScreenViewIfNecessary {\n  // Show the launch screen view again on top of the FlutterView if available.\n  // This launch screen view will be removed once the first Flutter frame is rendered.\n  if (_splashScreenView && (self.isBeingPresented || self.isMovingToParentViewController)) {\n    [_splashScreenView.get() removeFromSuperview];\n    _splashScreenView.reset();\n    return;\n  }\n\n  // Use the property getter to initialize the default value.\n  UIView* splashScreenView = self.splashScreenView;\n  if (splashScreenView == nil) {\n    return;\n  }\n  splashScreenView.frame = self.view.bounds;\n  [self.view addSubview:splashScreenView];\n}\n\n- (void)viewDidLoad {\n  // Register internal plugins.\n  [self addInternalPlugins];\n\n  if ([_engine.get() viewController] == self) {\n    [_engine.get() attachView];\n  }\n\n  [super viewDidLoad];\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n  if ([_engine.get() viewController] == self) {\n    [self onUserSettingsChanged:nil];\n\n    // Only recreate surface on subsequent appearances when viewport metrics are known.\n    // First time surface creation is done on viewDidLayoutSubviews.\n    if (_viewportMetrics.physical_width) {\n      [self surfaceUpdated:YES];\n    }\n    [[_engine.get() lifecycleChannel] sendMessage:@"AppLifecycleState.inactive"];\n    [[_engine.get() restorationPlugin] markRestorationComplete];\n  }\n\n  [super viewWillAppear:animated];\n}\n\n- (void)viewDidAppear:(BOOL)animated {\n  if ([_engine.get() viewController] == self) {\n    [self onUserSettingsChanged:nil];\n    [self onAccessibilityStatusChanged:nil];\n    if (UIApplication.sharedApplication.applicationState == UIApplicationStateActive) {\n      [[_engine.get() lifecycleChannel] sendMessage:@"AppLifecycleState.resumed"];\n    }\n  }\n  [super viewDidAppear:animated];\n}\n\n- (void)viewDidLayoutSubviews {\n  CGRect viewBounds = self.view.bounds;\n  CGFloat scale = [UIScreen mainScreen].scale;\n\n  // Purposefully place this not visible.\n  _scrollView.get().frame = CGRectMake(0.0, 0.0, viewBounds.size.width, 0.0);\n  _scrollView.get().contentOffset = CGPointMake(kScrollViewContentSize, kScrollViewContentSize);\n\n  // First time since creation that the dimensions of its view is known.\n  bool firstViewBoundsUpdate = !_viewportMetrics.physical_width;\n  _viewportMetrics.device_pixel_ratio = scale;\n  _viewportMetrics.physical_width = viewBounds.size.width * scale;\n  _viewportMetrics.physical_height = viewBounds.size.height * scale;\n\n  [self updateViewportPadding];\n  [self updateViewportMetrics];\n\n  // There is no guarantee that UIKit will layout subviews when the application is active. Creating\n  // the surface when inactive will cause GPU accesses from the background. Only wait for the first\n  // frame to render when the application is actually active.\n  bool applicationIsActive =\n      [UIApplication sharedApplication].applicationState == UIApplicationStateActive;\n\n  // This must run after updateViewportMetrics so that the surface creation tasks are queued after\n  // the viewport metrics update tasks.\n  if (firstViewBoundsUpdate && applicationIsActive && _engine) {\n    [self surfaceUpdated:YES];\n\n    flutter::Shell& shell = [_engine.get() shell];\n    fml::TimeDelta waitTime =\n#if FLUTTER_RUNTIME_MODE == FLUTTER_RUNTIME_MODE_DEBUG\n        fml::TimeDelta::FromMilliseconds(200);\n#else\n        fml::TimeDelta::FromMilliseconds(100);\n#endif\n    if (shell.WaitForFirstFrame(waitTime).code() == fml::StatusCode::kDeadlineExceeded) {\n      FML_LOG(INFO) << "Timeout waiting for the first frame to render.  This may happen in "\n                    << "unoptimized builds.  If this is a release build, you should load a less "\n                    << "complex frame to avoid the timeout.";\n    }\n  }\n}\n\n- (void)surfaceUpdated:(BOOL)appeared {\n  if (!_engine) {\n    return;\n  }\n\n  // NotifyCreated/NotifyDestroyed are synchronous and require hops between the UI and raster\n  // thread.\n  if (appeared) {\n    [self installFirstFrameCallback];\n    [_engine.get() platformViewsController]->SetFlutterView(_flutterView.get());\n    [_engine.get() platformViewsController]->SetFlutterViewController(self);\n    [_engine.get() iosPlatformView]->NotifyCreated();\n  } else {\n    self.displayingFlutterUI = NO;\n    [_engine.get() iosPlatformView]->NotifyDestroyed();\n    [_engine.get() platformViewsController]->SetFlutterView(nullptr);\n    [_engine.get() platformViewsController]->SetFlutterViewController(nullptr);\n  }\n}\n\n- (void)addInternalPlugins {\n  self.keyboardManager = [[[FlutterKeyboardManager alloc] init] autorelease];\n  fml::WeakPtr<FlutterViewController> weakSelf = [self getWeakPtr];\n  FlutterSendKeyEvent sendEvent =\n      ^(const FlutterKeyEvent& event, FlutterKeyEventCallback callback, void* userData) {\n        if (weakSelf) {\n          [weakSelf.get()->_engine.get() sendKeyEvent:event callback:callback userData:userData];\n        }\n      };\n  [self.keyboardManager addPrimaryResponder:[[[FlutterEmbedderKeyResponder alloc]\n                                                initWithSendEvent:sendEvent] autorelease]];\n  FlutterChannelKeyResponder* responder = [[[FlutterChannelKeyResponder alloc]\n      initWithChannel:self.engine.keyEventChannel] autorelease];\n  [self.keyboardManager addPrimaryResponder:responder];\n  FlutterTextInputPlugin* textInputPlugin = self.engine.textInputPlugin;\n  if (textInputPlugin != nil) {\n    [self.keyboardManager addSecondaryResponder:textInputPlugin];\n  }\n}\n\n- (void)popRoute {\n  [[_engine.get() navigationChannel] invokeMethod:@"popRoute" arguments:nil];\n}\n\n- (void)pushRoute:(NSString*)route {\n  [[_engine.get() navigationChannel] invokeMethod:@"pushRoute" arguments:route];\n}\n')),(0,l.kt)("h2",{id:"flutterview"},"FlutterView"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"- (instancetype)initWithDelegate:(id<FlutterViewEngineDelegate>)delegate opaque:(BOOL)opaque {\n  self = [super initWithFrame:CGRectNull];\n  if (self) {\n    _delegate = delegate;\n    self.layer.opaque = opaque;\n  }\n  return self;\n}\n\n+ (Class)layerClass {\n  return [CAMetalLayer class];\n}\n")),(0,l.kt)("h2",{id:"flutterengine"},"FlutterEngine"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"- (void)attachView {\n  self.iosPlatformView->attachView();\n  [_textInputPlugin.get() setupIndirectScribbleInteraction:self.viewController];\n}\n\n- (flutter::PlatformViewIOS*)iosPlatformView {\n  return static_cast<flutter::PlatformViewIOS*>(_shell->GetPlatformView().get());\n}\n")),(0,l.kt)("h2",{id:"shell"},"Shell"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"fml::WeakPtr<PlatformView> Shell::GetPlatformView() {\n  return weak_platform_view_; // Shell::Setup\u4e2d\u8d4b\u503c\n}\n")),(0,l.kt)("h2",{id:"platformviewios"},"PlatformViewIOS"),(0,l.kt)("p",null,"A bridge connecting the platform-agnostic shell and the iOS embedding."),(0,l.kt)("p",null,"The shell provides and requests for UI related data and this ",(0,l.kt)("inlineCode",{parentName:"p"},"PlatformView")," subclass fulfills it with iOS specific capabilities. As an example, the iOS embedding (the ",(0,l.kt)("inlineCode",{parentName:"p"},"FlutterEngine")," and the ",(0,l.kt)("inlineCode",{parentName:"p"},"FlutterViewController"),") sends pointer data to the shell and receives the shell's request for a Skia GrDirectContext and supplies it."),(0,l.kt)("p",null,"Despite the name \"view\", this class is unrelated to UIViews on iOS and doesn't have the same lifecycle. It's a long lived bridge owned by the ",(0,l.kt)("inlineCode",{parentName:"p"},"FlutterEngine")," and can be attached and detached sequentially to multiple ",(0,l.kt)("inlineCode",{parentName:"p"},"FlutterViewController"),"s and ",(0,l.kt)("inlineCode",{parentName:"p"},"FlutterView"),"s."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"title='flutter/shell/platform/darwin/ios/platform_view_ios.mm'",title:"'flutter/shell/platform/darwin/ios/platform_view_ios.mm'"},"void PlatformViewIOS::attachView() {\n  auto flutter_view = static_cast<FlutterView*>(owner_controller_.get().view);\n  auto ca_layer = fml::scoped_nsobject<CALayer>{[[flutter_view layer] retain]};\n  ios_surface_ = IOSSurface::Create(ios_context_, ca_layer);\n}\n")),(0,l.kt)("h2",{id:"iossurface"},"IOSSurface"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"std::unique_ptr<IOSSurface> IOSSurface::Create(std::shared_ptr<IOSContext> context,\n                                               fml::scoped_nsobject<CALayer> layer) {\n    if ([layer.get() isKindOfClass:[CAMetalLayer class]]) {\n        switch (context->GetBackend()) {\n        case IOSRenderingBackend::kSkia:\n            return std::make_unique<IOSSurfaceMetalSkia>(\n                fml::scoped_nsobject<CAMetalLayer>(\n                    reinterpret_cast<CAMetalLayer*>([layer.get() retain])),  // Metal layer\n                std::move(context)                                           // context\n            );\n            break;\n        case IOSRenderingBackend::kImpeller:\n            return std::make_unique<IOSSurfaceMetalImpeller>(\n                fml::scoped_nsobject<CAMetalLayer>(\n                    reinterpret_cast<CAMetalLayer*>([layer.get() retain])),  // Metal layer\n                std::move(context)                                           // context\n            );\n        }\n    }\n    return std::make_unique<IOSSurfaceSoftware>(std::move(layer),   // layer\n                                                std::move(context)  // context\n    );\n}\n")))}d.isMDXComponent=!0}}]);