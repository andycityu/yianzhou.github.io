"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[898],{22821:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));n(61839);const l={},i="Memory Management",r={unversionedId:"Effective Objective-C/effective-oc-5",id:"Effective Objective-C/effective-oc-5",title:"Memory Management",description:"29: Reference Counting",source:"@site/docs/language/Effective Objective-C/effective-oc-5.md",sourceDirName:"Effective Objective-C",slug:"/Effective Objective-C/effective-oc-5",permalink:"/docs/language/Effective Objective-C/effective-oc-5",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Protocols and Categories",permalink:"/docs/language/Effective Objective-C/effective-oc-4"},next:{title:"Block and GCD",permalink:"/docs/language/Effective Objective-C/effective-oc-6"}},s={},c=[{value:"29: Reference Counting",id:"29-reference-counting",level:2},{value:"30: Auto Reference Counting",id:"30-auto-reference-counting",level:2},{value:"31: Release References and Clean Up Observation State Only in dealloc",id:"31-release-references-and-clean-up-observation-state-only-in-dealloc",level:2},{value:"32: Beware of Memory Management with Exception-Safe Code",id:"32-beware-of-memory-management-with-exception-safe-code",level:2},{value:"33: Use Weak References to Avoid Retain Cycles",id:"33-use-weak-references-to-avoid-retain-cycles",level:2},{value:"34: Use Autorelease Pool Blocks to Reduce High-Memory Waterline",id:"34-use-autorelease-pool-blocks-to-reduce-high-memory-waterline",level:2},{value:"35: Use Zombies to Help Debug Memory-Management Problems",id:"35-use-zombies-to-help-debug-memory-management-problems",level:2},{value:"36: Avoid Using retainCount",id:"36-avoid-using-retaincount",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"memory-management"},"Memory Management"),(0,o.kt)("h2",{id:"29-reference-counting"},"29: Reference Counting"),(0,o.kt)("p",null,"\u5728\u5f15\u7528\u8ba1\u6570\u7684\u67b6\u6784\u4e0b\uff0c\u6bcf\u4e2a\u5bf9\u8c61\u90fd\u6709\u4e2a\u201c\u8ba1\u6570\u5668\u201d\uff0c\u8868\u793a\u6709\u591a\u5c11\u4e8b\u7269\u60f3\u4ee4\u5bf9\u8c61\u5b58\u6d3b\u4e0b\u53bb\u3002"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"retain"),": increment the retain count (reference count)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"release"),": decrement the retain count"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"autorelease"),": decrement the retain count later, when the autorelease pool is drained.")),(0,o.kt)("p",null,"Object may has reference to other objects, thereby forming what is known as an object graph."),(0,o.kt)("p",null,"Objects are said to own other objects if they hold a strong reference to them. This means that they have registered their interest in keeping them alive by retaining them. When they are finished with them, they release them."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)setFoo:(id)foo {\n    [foo retain];\n    [_foo release];\n    _foo = foo;\n}\n")),(0,o.kt)("p",null,"The order is important. If the old value was release before the new value was retained and the two values are exactly the same, the release would mean that the object could potentially be deallocated prematurely."),(0,o.kt)("p",null,'In a garbage-collected environment, retain cycle would usually be picked up as a "island of isolation", the collector would deallocate all three objects.'),(0,o.kt)("p",null,"In a reference counting environment, this leads to memory leaks, and usually solved by using weak reference."),(0,o.kt)("h2",{id:"30-auto-reference-counting"},"30: Auto Reference Counting"),(0,o.kt)("p",null,"\u7f16\u8bd1\u5668\u77e5\u9053\u54ea\u4e9b\u8bed\u53e5\u4f1a\u4ee4\u5bf9\u8c61\u7684\u5f15\u7528\u8ba1\u6570\u589e\u52a0\uff0c\u5982\u679c\u6ca1\u6709\u5bf9\u5e94\u7684\u51cf\u5c11\u64cd\u4f5c\uff0c\u90a3\u4e48\u5c31\u4f1a\u6709\u5185\u5b58\u6cc4\u6f0f\u3002\u65e2\u7136\u7f16\u8bd1\u5668\u77e5\u9053\uff0c\u90a3\u4e48\u5b83\u73b0\u5728\u591a\u505a\u4e86\u4e00\u6b65\u2014\u2014\u81ea\u52a8\u5e2e\u6211\u4eec\u7ba1\u7406\u5f15\u7528\u8ba1\u6570\u3002"),(0,o.kt)("p",null,"ARC \u6bd4 MRC \u6548\u7387\u66f4\u9ad8\uff0c\u56e0\u4e3a\u5b83\u76f4\u63a5\u8c03\u7528\u5e95\u5c42 C \u7684\u51fd\u6570\uff0c\u800c\u4e0d\u662f\u5c01\u88c5\u540e\u7684 Objective-C \u65b9\u6cd5\u3002MRC \u65f6\u4ee3\u7684\u65b9\u6cd5\u5728 ARC \u73af\u5883\u4e0b\u90fd\u4e0d\u5141\u8bb8\u8c03\u7528\uff0c\u5305\u62ec ",(0,o.kt)("inlineCode",{parentName:"p"},"retain"),"\u3001",(0,o.kt)("inlineCode",{parentName:"p"},"release"),"\u3001",(0,o.kt)("inlineCode",{parentName:"p"},"autorelease"),"\u3001",(0,o.kt)("inlineCode",{parentName:"p"},"dealloc"),"\u3002"),(0,o.kt)("p",null,"ARC \u7ba1\u7406\u5bf9\u8c61\u751f\u547d\u5468\u671f\u7684\u57fa\u672c\u65b9\u6cd5\u662f\uff1a\u5728\u5408\u9002\u7684\u5730\u65b9\u63d2\u5165\u201c\u4fdd\u7559\u201d\u548c\u201c\u91ca\u653e\u201d\u64cd\u4f5c\u3002\u5728 ARC \u73af\u5883\u4e0b\uff0c\u53d8\u91cf\u7684\u5185\u5b58\u7ba1\u7406\u8bed\u4e49\u53ef\u4ee5\u901a\u8fc7\u4fee\u9970\u7b26\u6765\u6307\u660e\u3002"),(0,o.kt)("p",null,"\u5982\u679c\u8c03\u7528\u4e86\u4ee5 alloc, new, copy, mutableCopy \u5f00\u5934\u7684\u65b9\u6cd5\uff08owning prefix\uff09\uff0c\u90a3\u4e48\u5176\u8fd4\u56de\u7684\u5bf9\u8c61\u5f52\u8c03\u7528\u8005\u62e5\u6709\uff0c\u8c03\u7528\u8005\u5fc5\u987b\u8d1f\u8d23\u5c06\u5b83\u4eec\u91ca\u653e\u3002"),(0,o.kt)("p",null,"Any other method name indicates that any returned object will be returned not owned by the calling code. In these cases, the object will be returned autoreleased, so that the value is alive across the method call boundary. If it wants to ensure that the object stays alive longer, the calling code must retain it."),(0,o.kt)("p",null,"\u4e3e\u4f8b\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"+ (EOCPerson*)newPerson {\n    EOCPerson *person = [[EOCPerson alloc] init];\n    return person;\n    /**\n     * The method name begins with 'new', and since 'person'\n     * already has an unbalanced +1 retain count from the\n     * 'alloc', no retains, releases, or autoreleases are\n     * required when returning.\n     */\n}\n\n+ (EOCPerson*)somePerson {\n    EOCPerson *person = [[EOCPerson alloc] init];\n    return person;\n    /**\n     * The method name does not begin with one of the \"owning\"\n     * prefixes, therefore ARC will add an autorelease when\n     * returning 'person'.\n     * The equivalent manual reference counting statement is:\n     *   return [person autorelease];\n     */\n}\n\n- (void)doSomething {\n    EOCPerson *personOne = [EOCPerson newPerson];\n    // ...\n    EOCPerson *personTwo = [EOCPerson somePerson];\n    // ...\n    /**\n     * At this point, 'personOne' and 'personTwo' go out of\n     * scope, therefore ARC needs to clean them up as required.\n     * - 'personOne' was returned as owned by this block of\n     *   code, so it needs to be released.\n     * - 'personTwo' was returned not owned by this block of\n     *   code, so it does not need to be released.\n     * The equivalent manual reference counting cleanup code\n     * is:\n     *    [personOne release];\n     */\n}\n")),(0,o.kt)("p",null,"Objective-C \u901a\u8fc7\u4e0a\u8ff0\u7684\u547d\u540d\u7ea6\u5b9a\uff0c\u5c06\u5185\u5b58\u7ba1\u7406\u6807\u51c6\u5316\u3002"),(0,o.kt)("p",null,"ARC \u4e5f\u5305\u542b\u8fd0\u884c\u65f6\u7ec4\u4ef6\u3002\u5904\u7406\u4f18\u5316 ",(0,o.kt)("inlineCode",{parentName:"p"},"autorelease")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"retain")," \u5148\u540e\u51fa\u73b0\u7b49\u60c5\u51b5\u3002"),(0,o.kt)("p",null,"The semantics of local and instance variables can be altered through the application of the following qualifiers:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"__strong"),": The default; the value is retained."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"__unsafe__unretained"),": The value is not retained and is potentially unsafe, as the object may have been deallocated already by the time the variable is used again."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"__weak"),": The value is not retained but is safe because it is automatically set to nil if the current object is ever deallocated."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"__autoreleasing"),": This special qualifier is used when an object is passed by reference to a method. The value is autoreleased on return.")),(0,o.kt)("p",null,"You still need to clean up any non-Objective-C objects if you have any, such as CoreFoundation objects or heap-allocated memory with ",(0,o.kt)("inlineCode",{parentName:"p"},"malloc()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)dealloc {\n    CFRelease(_coreFoundationObject);\n    free(_heapAllocatedMemoryBlob);\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"__autoreleasing")," \u6211\u4eec\u4e00\u822c\u5f88\u5c11\u663e\u5f0f\u4f7f\u7528\uff0c\u901a\u5e38\u7531\u7f16\u8bd1\u5668\u9690\u5f0f\u6dfb\u52a0\u3002\u6bd4\u5982 NSFileManager \u7684\u63a5\u53e3\uff1a"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"- (nullable NSArray<NSString *> *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError **)error);")),(0,o.kt)("h2",{id:"31-release-references-and-clean-up-observation-state-only-in-dealloc"},"31: Release References and Clean Up Observation State Only in dealloc"),(0,o.kt)("p",null,"\u4f60\u7edd\u5bf9\u4e0d\u5e94\u8be5\u81ea\u5df1\u8c03\u7528 dealloc \u65b9\u6cd5\uff0cRuntime \u4f1a\u5728\u9002\u5f53\u65f6\u5019\u8c03\u7528\u3002"),(0,o.kt)("p",null,"\u5728 dealloc \u65b9\u6cd5\u4e2d\uff0c\u5e94\u8be5\u505a\u7684\u662f\u91ca\u653e\u5176\u5b83\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u53d6\u6d88\u8ba2\u9605\u7684 KVO \u6216 NSNotificationCenter \u901a\u77e5\uff0c\u4e0d\u8981\u505a\u5176\u4ed6\u4e8b\u60c5\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)dealloc {\n    CFRelease(coreFoundationObject); // CoreFoundation object \u4e0d\u5f52 ARC \u7ba1\u7406\uff0c\u987b\u81ea\u884c\u91ca\u653e\n    [[NSNotificationCenter defaultCenter] removeObserver: self]; // \u89e3\u9664\u76d1\u542c\n}\n")),(0,o.kt)("h2",{id:"32-beware-of-memory-management-with-exception-safe-code"},"32: Beware of Memory Management with Exception-Safe Code"),(0,o.kt)("p",null,"C++ and Objective-C exceptions are compatible, meaning that an exception thrown from one language can be caught using a handler from the other language."),(0,o.kt)("p",null,"Inside a try block, if an object is retained and then an exception is thrown before the object has been released, the object will leak unless this case is handled in the catch block. C++ destructors are run by the Objective-C exception-handling routines. This is important for C++ because any object whose lifetime has been cut short by a thrown exception needs to be destructed; otherwise, the memory it uses will be leaked, not to mention all the other system resources, such as file handles, that may not be cleaned up properly."),(0,o.kt)("h2",{id:"33-use-weak-references-to-avoid-retain-cycles"},"33: Use Weak References to Avoid Retain Cycles"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@property(nonatomic, unsafe_unretained) EOCPerson *other;")," \u7528 unsafe_unretained \u4fee\u9970\u7684\u5c5e\u6027\uff0c\u8bed\u4e49\u4e0a\u540c assign \u7b49\u4ef7\uff0c\u8868\u660e\u5c5e\u6027\u503c\u53ef\u80fd\u4e0d\u5b89\u5168\uff0c\u5e76\u4e14\u4e0d\u5f52\u6b64\u5b9e\u4f8b\u6240\u62e5\u6709\u3002"),(0,o.kt)("p",null,"weak \u4e0e unsafe_unretained \u7684\u4f5c\u7528\u5b8c\u5168\u76f8\u540c\u3002\u53ea\u8981\u7cfb\u7edf\u628a\u5c5e\u6027\u56de\u6536\uff0c\u5c5e\u6027\u503c\u5c31\u4f1a\u81ea\u52a8\u8bbe\u4e3a nil\uff1b\u800c unsafe_unretained \u5c5e\u6027\u4ecd\u7136\u6307\u5411\u539f\u6765\u7684\u4f4d\u7f6e\uff0c\u4e0d\u5b89\u5168\u3002"),(0,o.kt)("h2",{id:"34-use-autorelease-pool-blocks-to-reduce-high-memory-waterline"},"34: Use Autorelease Pool Blocks to Reduce High-Memory Waterline"),(0,o.kt)("p",null,"One of the features of Objective-C\u2019s reference-counted architecture is a concept known as autorelease pools. Releasing an object means that its retain count either is decremented immediately through a call ",(0,o.kt)("inlineCode",{parentName:"p"},"[obj release]")," or is added to an auto-release pool through a call ",(0,o.kt)("inlineCode",{parentName:"p"},"[obj autorelease]"),"."),(0,o.kt)("p",null,"An autorelease pool is used as a collection of objects that will need releasing at some point in the future. When a pool is drained, all the objects in the pool at that time are sent the release message."),(0,o.kt)("p",null,"If no autorelease pool is in place when an object is sent the autorelease message, you will see a message like this in the console:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Object 0xabcd0123 of class ",(0,o.kt)("inlineCode",{parentName:"p"},"__NSCFString")," autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug")),(0,o.kt)("p",null,"Often, the only one you will ever see in an application is the one that wraps the main application entry point in the main function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'int main(int argc, char *argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, @"EOCAppDelegate");\n    }\n}\n')),(0,o.kt)("p",null,"Technically, this autorelease pool block is ",(0,o.kt)("strong",{parentName:"p"},"unnecessary"),". The end of the block coincides with the application terminating, at which point the operating system releases all memory used by the application. Without it, any objects autoreleased by the UIApplicationMain function would not have a pool to go into and would log a warning saying just that. So this pool can be thought of as an outer catch-all pool."),(0,o.kt)("p",null,"The braces in ",(0,o.kt)("inlineCode",{parentName:"p"},"@autoreleasepool {}")," define the scope of the autorelease pool. A pool is created at the first brace and is automatically drained at the end of the scope. Any object autoreleased within the scope is therefore sent the release message at the end of the scope."),(0,o.kt)("p",null,"Autorelease pools can be nested. When an object is autoreleased, it is added to the innermost pool. This nesting of autorelease pools can be taken advantage of to allow the control of the ",(0,o.kt)("em",{parentName:"p"},"high memory mark")," of an application."),(0,o.kt)("p",null,"Autorelease pools can be thought of as being in a stack. When an autorelease pool is created, it is pushed onto the stack; when it is drained, it is pulled off the stack. When an object is autoreleased, it is put into the topmost pool in the stack."),(0,o.kt)("p",null,"The need to make this additional pool optimization depends entirely on your application. It is certainly not something that should be done without first monitoring the memory footprint to decide whether a problem needs addressing. Autorelease pool blocks do not incur too much overhead, but they do incur at least some overhead, so if the extra autorelease pool can be avoided, it should be."),(0,o.kt)("h2",{id:"35-use-zombies-to-help-debug-memory-management-problems"},"35: Use Zombies to Help Debug Memory-Management Problems"),(0,o.kt)("p",null,'\u542f\u7528\u4e86 "Zombie Object" \u8fd9\u4e2a\u8c03\u8bd5\u529f\u80fd\u4e4b\u540e\uff0cRuntime \u4f1a\u628a\u6240\u6709\u5df2\u7ecf\u91ca\u653e\u7684\u5b9e\u4f8b\u8f6c\u5316\u4e3a\u7279\u6b8a\u7684\u50f5\u5c38\u5bf9\u8c61\uff0c\u800c\u4e0d\u4f1a\u771f\u6b63\u56de\u6536\u4ed6\u4eec\u3002\u50f5\u5c38\u5bf9\u8c61\u6240\u5728\u7684\u6838\u5fc3\u5185\u5b58\u65e0\u6cd5\u88ab\u91cd\u7528\uff0c\u4e0d\u53ef\u80fd\u88ab\u8986\u5199\uff0c\u5f53\u5c1d\u8bd5\u5411\u50f5\u5c38\u5bf9\u8c61\u53d1\u9001\u6d88\u606f\u65f6\uff0c\u7a0b\u5e8f\u4f1a\u629b\u51fa\u5f02\u5e38\uff0c\u5176\u4e2d\u51c6\u786e\u8bf4\u660e\u4e86\u53d1\u9001\u8fc7\u6765\u7684\u6d88\u606f\uff0c\u5e76\u63cf\u8ff0\u4e86\u56de\u6536\u4e4b\u524d\u7684\u90a3\u4e2a\u5bf9\u8c61\u3002\u50f5\u5c38\u5bf9\u8c61\u662f\u8c03\u8bd5\u5185\u5b58\u7ba1\u7406\u95ee\u9898\u7684\u6700\u4f73\u65b9\u5f0f\u3002'),(0,o.kt)("h2",{id:"36-avoid-using-retaincount"},"36: Avoid Using retainCount"),(0,o.kt)("p",null,"When ARC came along, the retainCount method was deprecated, and using it causes a compiler error to be emitted."))}d.isMDXComponent=!0}}]);