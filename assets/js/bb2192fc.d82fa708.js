"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4707],{71321:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>d,toc:()=>u});var a=t(87462),o=(t(67294),t(3905));t(61839);const r={},i="\u591a\u7ebf\u7a0b",d={unversionedId:"cpp/thread",id:"cpp/thread",title:"\u591a\u7ebf\u7a0b",description:"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898",source:"@site/docs/language/cpp/thread.md",sourceDirName:"cpp",slug:"/cpp/thread",permalink:"/docs/language/cpp/thread",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u6807\u51c6\u5e93",permalink:"/docs/language/cpp/std"},next:{title:"Dart",permalink:"/docs/language/dart"}},s={},u=[{value:"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898",id:"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898",level:2}],c={toc:u};function l(n){let{components:e,...t}=n;return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"\u591a\u7ebf\u7a0b"},"\u591a\u7ebf\u7a0b"),(0,o.kt)("h2",{id:"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898"},"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898"),(0,o.kt)("p",null,"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u95ee\u9898\u662f\u7ecf\u5178\u7684\u3001\u5e76\u53d1\u7f16\u7a0b\u4e2d\u7684\u591a\u7ebf\u7a0b\u540c\u6b65\u95ee\u9898\u3002\u5b83\u6709\u5f88\u591a\u7684\u53d8\u4f53\uff0c\u6211\u4eec\u8ba8\u8bba\u4e00\u79cd\u6700\u57fa\u672c\u7684\u60c5\u51b5\uff1a\u53ea\u6709\u4e00\u4e2a\u751f\u4ea7\u8005\u7ebf\u7a0b\u548c\u4e00\u4e2a\u6d88\u8d39\u8005\u7ebf\u7a0b\uff1b\u5b83\u4eec\u4e4b\u95f4\u7f13\u51b2\u533a\u7684\u5927\u5c0f\u4e3a\u4e00\u3002"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://levelup.gitconnected.com/producer-consumer-problem-using-mutex-in-c-764865c47483"},"\u8fd9\u4e2a\u4f8b\u5b50"),"\u4e2d\uff0c\u6211\u4eec\u901a\u8fc7\u4e92\u65a5\u91cf\uff0c\u4fdd\u8bc1\u4e24\u4e2a\u7ebf\u7a0b\u5bf9\u7ade\u4e89\u8d44\u6e90\uff08\u5373\u7f13\u51b2\u533a\uff09\u7684\u8bbf\u95ee\u662f\u4e92\u65a5\u7684\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <vector>\n#include <thread>\n\nusing namespace std;\n\nclass SolutionA {\npublic:\n    int produceData() {\n        int ran = rand() % 1000; // [0, 1000) \u7684\u968f\u673a\u6570\n        cout << "Produce data: " << ran << endl;\n        return ran;\n    }\n\n    void consumeData(int data) {\n        cout << "Consume data: " << data << endl;\n    }\n\n    void producer() {\n        while (true) {\n            mu.lock();\n            data = produceData();\n            ready = true;\n            mu.unlock();\n            while (ready) {\n                // \u6bcf\u79d2\u68c0\u6d4b\u4e00\u6b21\uff0c\u76f4\u5230\u6d88\u8d39\u8005\u5403\u5b8c\n                std::this_thread::sleep_for(std::chrono::seconds(1));\n            }\n        }\n    }\n\n    void consumer() {\n        while (true) {\n            while (!ready) {\n                // \u6bcf\u79d2\u68c0\u6d4b\u4e00\u6b21\uff0c\u76f4\u5230\u751f\u4ea7\u8005\u4ea7\u51fa\n                std::this_thread::sleep_for(std::chrono::seconds(1));\n            }\n            mu.lock();\n            consumeData(data);\n            ready = false;\n            mu.unlock();\n        }\n    }\n\n    void run() {\n        thread t1(&SolutionA::producer, this);\n        thread t2(&SolutionA::consumer, this);\n        t1.detach();\n        t2.detach();\n    }\nprivate:\n    mutex mu;\n    bool ready = false;\n    int data = 0;\n};\n\nint main() {\n    SolutionA so = SolutionA();\n    so.run();\n\n    while (true) {\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n\n    return 0;\n}\n')),(0,o.kt)("p",null,"\u8fd9\u4e2a\u4f8b\u5b50\u663e\u7136\u662f\u4e0d\u591f\u597d\u7684\uff0c\u56e0\u4e3a\u6211\u4eec\u7f3a\u5c11\u4e00\u79cd\u624b\u6bb5\u8ba9\u751f\u4ea7\u8005/\u6d88\u8d39\u8005\u7ebf\u7a0b\u77e5\u9053\u5bf9\u65b9\u5df2\u7ecf\u5b8c\u6210\u5de5\u4f5c\u4e86\uff0c\u6211\u4eec\u53ea\u597d\u9009\u62e9\u7528 ",(0,o.kt)("inlineCode",{parentName:"p"},"while")," \u5faa\u73af\u8f6e\u8be2\uff0c\u8fd9\u4f1a\u4f7f\u5f97\u7ebf\u7a0b\u5728\u7b49\u5f85\u5bf9\u65b9\u65f6\u7a7a\u8f6c\uff0c\u5c3d\u7ba1\u6211\u4eec\u53ef\u4ee5\u8ba9\u7ebf\u7a0b\u4f11\u7720\u4e00\u5b9a\u7684\u65f6\u95f4\u3001\u4ee5\u8282\u7701\u8d44\u6e90\uff0c\u4f46\u8fd9\u5e76\u4e0d\u662f\u5b8c\u7f8e\u7684\u65b9\u6848\u3002",(0,o.kt)("strong",{parentName:"p"},"\u6761\u4ef6\u91cf"),"\u5c31\u662f\u7528\u6765\u89e3\u51b3\u8fd9\u79cd\u95ee\u9898\u7684\u3002"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"condition_variable")," class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the condition), and notifies the ",(0,o.kt)("inlineCode",{parentName:"p"},"condition_variable"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <vector>\n#include <thread>\n\nusing namespace std;\n\nclass SolutionB {\npublic:\n    int produceData() {\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        int ran = rand() % 1000; // [0, 1000) \u7684\u968f\u673a\u6570\n        cout << "Produce data: " << ran << endl;\n        return ran;\n    }\n\n    void consumeData(int data) {\n        cout << "Consume data: " << data << endl;\n    }\n\n    void producer() {\n        while (true) {\n            // Resource Acquisition Is Initialization or RAII\n            std::unique_lock<std::mutex> ul(mu);\n            // critical section\n            data = produceData();\n            ready = true;\n            // critical section\n            ul.unlock();\n\n            cv.notify_one();\n\n            ul.lock();\n            // The wait operations atomically release the mutex and suspend the execution of the thread.\n            cv.wait(ul, [this] {\n                return !this->ready;\n            });\n            // When the condition variable is notified, the thread is awakened, and the mutex is atomically reacquired.\n        }\n    }\n\n    void consumer() {\n        while (true) {\n            std::unique_lock<std::mutex> ul(mu);\n            cv.wait(ul, [this]() {\n                return this->ready;\n            });\n            // after the wait, we own the lock.\n            consumeData(data);\n            ready = false;\n            ul.unlock();\n            cv.notify_one();\n        }\n    }\n\n    void run() {\n        t1 = thread(&SolutionB::producer, this);\n        t2 = thread(&SolutionB::consumer, this);\n        t1.detach();\n        t2.detach();\n    }\nprivate:\n    std::mutex mu;\n    std::condition_variable cv;\n    int data = 0;\n    bool ready = false;\n\n    thread t1;\n    thread t2;\n};\n\nint main() {\n    SolutionB so = SolutionB();\n    so.run();\n\n    while (true) {\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n\n    return 0;\n}\n')))}l.isMDXComponent=!0}}]);