"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7080],{19799:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var t=n(87462),o=(n(67294),n(3905));n(61839);const i={},l="SDWebImage",r={unversionedId:"SDWebImage",id:"SDWebImage",title:"SDWebImage",description:"UIView category",source:"@site/docs/apple/SDWebImage.md",sourceDirName:".",slug:"/SDWebImage",permalink:"/docs/apple/SDWebImage",draft:!1,editUrl:"https://github.com/yianzhou/yianzhou.github.io/docs/apple/SDWebImage.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",next:{title:"UIKit",permalink:"/docs/apple/UIKit"}},s={},c=[{value:"UIView category",id:"uiview-category",level:2},{value:"NSMapTable",id:"nsmaptable",level:2},{value:"SDWebImageManager",id:"sdwebimagemanager",level:2},{value:"\u4e00\u3001\u7ec4\u5408\u64cd\u4f5c",id:"\u4e00\u7ec4\u5408\u64cd\u4f5c",level:3},{value:"\u4e8c\u3001\u67e5\u627e\u7f13\u5b58\u6d41\u7a0b",id:"\u4e8c\u67e5\u627e\u7f13\u5b58\u6d41\u7a0b",level:3},{value:"\u4e09\u3001\u4e0b\u8f7d\u6d41\u7a0b",id:"\u4e09\u4e0b\u8f7d\u6d41\u7a0b",level:3},{value:"\u56db\u3001\u5199\u5165\u7f13\u5b58\u6d41\u7a0b",id:"\u56db\u5199\u5165\u7f13\u5b58\u6d41\u7a0b",level:3},{value:"\u4e94\u3001transform \u6d41\u7a0b",id:"\u4e94transform-\u6d41\u7a0b",level:3},{value:"SDImageCache",id:"sdimagecache",level:2},{value:"SDMemoryCache",id:"sdmemorycache",level:3},{value:"NSCache",id:"nscache",level:4},{value:"WeakMemoryCache",id:"weakmemorycache",level:4},{value:"\u5c0f\u7ed3",id:"\u5c0f\u7ed3",level:4},{value:"SDDiskCache",id:"sddiskcache",level:3},{value:"\u5982\u4f55\u79fb\u9664\u8fc7\u671f\u7684\u6587\u4ef6",id:"\u5982\u4f55\u79fb\u9664\u8fc7\u671f\u7684\u6587\u4ef6",level:4},{value:"\u5982\u4f55\u5c06\u7f13\u5b58\u7684 key \u8f6c\u6362\u4e3a\u6587\u4ef6\u540d",id:"\u5982\u4f55\u5c06\u7f13\u5b58\u7684-key-\u8f6c\u6362\u4e3a\u6587\u4ef6\u540d",level:4},{value:"ExtendedCacheData",id:"extendedcachedata",level:4},{value:"WWDC 2018 - Image and Graphics Best Practices",id:"wwdc-2018---image-and-graphics-best-practices",level:3},{value:"SDImageCacheDecodeImageData",id:"sdimagecachedecodeimagedata",level:3},{value:"SDImageIOCoder",id:"sdimageiocoder",level:4},{value:"SDImageCoderHelper",id:"sdimagecoderhelper",level:4},{value:"SDImageLoader",id:"sdimageloader",level:2},{value:"SDWebImageDownloader",id:"sdwebimagedownloader",level:3},{value:"NSOperation",id:"nsoperation",level:3},{value:"SDWebImageDownloaderOperation",id:"sdwebimagedownloaderoperation",level:3},{value:"SDAnimatedImage",id:"sdanimatedimage",level:2},{value:"SDWebImagePrefetcher",id:"sdwebimageprefetcher",level:2}],m={toc:c};function d(e){let{components:a,...i}=e;return(0,o.kt)("wrapper",(0,t.Z)({},m,i,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"sdwebimage"},"SDWebImage"),(0,o.kt)("h2",{id:"uiview-category"},"UIView category"),(0,o.kt)("p",null,"\u6211\u4eec\u4ece\u4e00\u4e2a\u5e38\u7528\u7684\u8c03\u7528\u63a5\u53e3\u5f00\u59cb\u63a2\u7d22\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'let url = URL(string: "...")\nimageView.sd_setImage(with: url)\n')),(0,o.kt)("p",null,"\u8fd9\u662f ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImageView+WebCache")," \u63d0\u4f9b\u7684\u5176\u4e2d\u4e00\u4e2a\u63a5\u53e3\uff0c\u7531\u4e8e Objective-C \u4e0d\u50cf Swift \u53ef\u4ee5\u4e3a\u51fd\u6570\u58f0\u660e",(0,o.kt)("a",{parentName:"p",href:"https://docs.swift.org/swift-book/LanguageGuide/Functions.html"},"\u9ed8\u8ba4\u53c2\u6570\u503c"),"\uff0c\u56e0\u6b64\u9700\u8981\u58f0\u660e\u591a\u4e2a\u63a5\u53e3\u3002\u5b83\u4eec\u6700\u7ec8\u4f1a\u6c47\u5408\u5230\u8fd9\u4e2a\u65b9\u6cd5\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)sd_setImageWithURL:(nullable NSURL *)url\n          placeholderImage:(nullable UIImage *)placeholder\n                   options:(SDWebImageOptions)options\n                   context:(nullable SDWebImageContext *)context\n                  progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                 completed:(nullable SDExternalCompletionBlock)completedBlock {\n    [self sd_internalSetImageWithURL:url\n                    placeholderImage:placeholder\n                             options:options\n                             context:context\n                       setImageBlock:nil\n                            progress:progressBlock\n                           completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) {\n                               if (completedBlock) {\n                                   completedBlock(image, error, cacheType, imageURL);\n                               }\n                           }];\n}\n")),(0,o.kt)("p",null,"\u9996\u5148\u7406\u89e3\u8fd9\u4e2a\u63a5\u53e3\u5404\u53c2\u6570\u7684\u542b\u4e49\u3002"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageOptions")," \u5b9a\u4e49\u5728 ",(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageDefine.h"),"\uff0c\u662f\u56fe\u7247\u4e0b\u8f7d\u7684\u9009\u9879\uff0c\u7528 bitmask \u7684\u5f62\u5f0f\u8868\u793a\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {\n    /**\n     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying.\n     * This flag disable this blacklisting.\n     */\n    SDWebImageRetryFailed = 1 << 0,\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageContext")," \u5b9a\u4e49\u5728 ",(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageDefine.h"),"\uff0c\u662f\u5bf9\u4e0b\u8f7d\u9009\u9879\u7684\u4e00\u4e2a\u6269\u5145\uff0cThis hold the extra objects which options enum can not hold. \u5b83\u662f\u4e00\u4e2a\u5b57\u5178\uff0c\u53ef\u4ee5\u5bf9\u56fe\u7247 operation key\u3001cache\u3001loader\u3001coder\u3001transformer \u7b49\u8fdb\u884c\u81ea\u5b9a\u4e49\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"typedef NSDictionary<SDWebImageContextOption, id> SDWebImageContext;\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"sd_internalSetImage")," \u591a\u4e86\u4e00\u4e2a\u53c2\u6570 ",(0,o.kt)("inlineCode",{parentName:"p"},"@param setImageBlock")," If not provide, use the built-in set image code (supports ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImageView/NSImageView")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UIButton/NSButton")," currently)."),(0,o.kt)("p",null,"\u67e5\u770b\u5206\u7c7b ",(0,o.kt)("inlineCode",{parentName:"p"},"@interface UIView (WebCache)"),"\uff0c\u8fd9\u4e2a\u5206\u7c7b\u4e2d\u4e3a ",(0,o.kt)("inlineCode",{parentName:"p"},"UIView")," \u6dfb\u52a0\u4e86\u51e0\u4e2a\u5c5e\u6027\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"@property (nonatomic, strong, readonly, nullable) NSURL *sd_imageURL;\n@property (nonatomic, strong, readonly, nullable) NSString *sd_latestOperationKey;\n@property (nonatomic, strong, null_resettable) NSProgress *sd_imageProgress;\n")),(0,o.kt)("p",null,"\u4e3a\u5206\u7c7b\u6dfb\u52a0\u5c5e\u6027\u7684\u65b9\u6cd5\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (nullable NSURL *)sd_imageURL {\n    // selector \u4f5c\u4e3a key\uff01\n    return objc_getAssociatedObject(self, @selector(sd_imageURL));\n}\n\n- (void)setSd_imageURL:(NSURL * _Nullable)sd_imageURL {\n    objc_setAssociatedObject(self, @selector(sd_imageURL), sd_imageURL, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n")),(0,o.kt)("p",null,"\u63a5\u4e0b\u6765\u63a2\u7d22 ",(0,o.kt)("inlineCode",{parentName:"p"},"@implementation UIView (WebCache)")," \u4e2d\u5173\u952e\u65b9\u6cd5\u7684\u5b9e\u73b0\u3002"),(0,o.kt)("p",null,"\u4e0b\u8f7d\u56fe\u7247\u7684\u64cd\u4f5c ",(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageOperation")," \u4f1a\u4e0e\u5f53\u524d ",(0,o.kt)("inlineCode",{parentName:"p"},"UIView")," \u5173\u8054\u8d77\u6765\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'- (void)sd_internalSetImageWithURL:(nullable NSURL *)url\n                  placeholderImage:(nullable UIImage *)placeholder\n                           options:(SDWebImageOptions)options\n                           context:(nullable SDWebImageContext *)context\n                     setImageBlock:(nullable SDSetImageBlock)setImageBlock\n                          progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                         completed:(nullable SDInternalCompletionBlock)completedBlock {\n    // \u6ce8\u610f\uff0c\u8fd9\u4e2a\u51fd\u6570\u662f\u4f17\u591a UIView \u63a5\u53e3\u80cc\u540e\u7684\u8c03\u7528\n    // \u5176\u4e2d context \u53c2\u6570\u662f SDK \u5916\u90e8\u7528\u6237\u76f4\u63a5\u4f20\u53c2\u8fdb\u6765\u7684\n    // \u4e3a\u4e86\u907f\u514d\u4fee\u6539\u5916\u90e8\u7684\u53c2\u6570\uff0c\u56e0\u6b64\u5bf9\u5b83\u6267\u884c\u62f7\u8d1d\n    if (context) {\n        // copy to avoid mutable object\n        context = [context copy];\n    } else {\n        context = [NSDictionary dictionary];\n    }\n\n    NSString *validOperationKey = context[SDWebImageContextSetImageOperationKey];\n    if (!validOperationKey) {\n        validOperationKey = NSStringFromClass([self class]); // \u4f8b\u5982 "UIImageView"\n    }\n    self.sd_latestOperationKey = validOperationKey;\n    // \u53d6\u6d88\u539f\u5148\u7684\u64cd\u4f5c\n    [self sd_cancelImageLoadOperationWithKey:validOperationKey];\n\n    if (url) {\n        id <SDWebImageOperation> operation = [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {\n            dispatch_main_async_safe(^{\n                [self sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];\n                callCompletedBlockClosure();\n            });\n        }];\n        // \u5c06\u8fd9\u4e2a operation \u4e0e\u5f53\u524d UIView \u5b9e\u4f8b\u5173\u8054\u8d77\u6765\uff01\n        [self sd_setImageLoadOperation:operation forKey:validOperationKey];\n    }\n}\n')),(0,o.kt)("h2",{id:"nsmaptable"},"NSMapTable"),(0,o.kt)("p",null,"\u5173\u8054 operation \u5b9a\u4e49\u5728 ",(0,o.kt)("inlineCode",{parentName:"p"},"UIView+WebCacheOperation"),"\uff0c\u5176\u672c\u8d28\u662f\u7528\u4e00\u4e2a\u5b57\u5178\u5b58\u50a8\u5f53\u524d UIView \u6b63\u5728\u8fd0\u884c\u7684\u64cd\u4f5c ","[operationKey: operation]","\uff0c\u6709\u8da3\u7684\u662f\u8fd9\u91cc\u7528\u5230\u4e86 ",(0,o.kt)("inlineCode",{parentName:"p"},"NSMapTable"),"\uff0c\u5b83\u7684\u521d\u59cb\u5316\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"operations = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];\n")),(0,o.kt)("p",null,"NSMapTable \u7c7b\u4f3c\u4e8e NSDictionary\uff0c\u4f46\u5b83\u53ef\u4ee5",(0,o.kt)("strong",{parentName:"p"},"\u6307\u5b9a key \u548c value \u7684\u5185\u5b58\u7ba1\u7406\u8bed\u4e49"),"\u3002"),(0,o.kt)("p",null,"NSDictionary / NSMutableDictionary \u5bf9 key \u62f7\u8d1d\uff0c\u5bf9 value \u5f3a\u5f15\u7528\u3002"),(0,o.kt)("p",null,"NSMapTable \u53ef\u4ee5\u5bf9\u952e\u548c\u503c\u5f31\u5f15\u7528\uff0c\u5f53\u952e\u6216\u503c\u5f53\u4e2d\u7684\u4e00\u4e2a\u88ab\u91ca\u653e\u65f6\uff0c\u8fd9\u4e00\u952e\u503c\u5bf9\u5c31\u4f1a\u88ab\u79fb\u9664\u6389\u3002"),(0,o.kt)("p",null,"NSDictionary \u7684 key \u9700\u8981\u9075\u5b88 NSCopying \u534f\u8bae\uff0c\u5f53\u8c03\u7528 NSMutableDictionary \u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"- (void)setObject:(ObjectType)anObject forKey:(KeyType <NSCopying>)aKey;")," \u65b9\u6cd5\u65f6\uff0c\u4f1a\u5bf9 key \u8fdb\u884c copy\u3002"),(0,o.kt)("p",null,"\u7559\u610f SDWebImageContextSetImageOperationKey \u662f\u53ef\u4ee5\u7531\u5916\u90e8\u4f7f\u7528\u8005\u8bbe\u7f6e\u7684\u4efb\u610f\u5bf9\u8c61\uff0c\u8fd9\u4e9b\u5bf9\u8c61\u4e0d\u4e00\u5b9a\u9075\u5faa NSCopying\uff0c\u56e0\u6b64\u8fd9\u91cc\u5c06 key \u7684\u5185\u5b58\u7ba1\u7406\u8bed\u4e49\u6307\u5b9a\u4e3a NSPointerFunctionsStrongMemory\u3002"),(0,o.kt)("p",null,"\u540c\u65f6\uff0c\u56e0\u4e3a\u8fd9\u91cc\u5bf9 operation \u662f\u5f31\u5f15\u7528\uff0c\u5f53 key \u5bf9\u5e94\u7684 operation \u6267\u884c\u5b8c\u6bd5\u88ab\u91ca\u653e\u540e\uff0c\u5b57\u5178\u91cc\u7684\u8fd9\u4e00\u9879\u4e5f\u4f1a\u81ea\u52a8\u88ab\u79fb\u9664\u3002"),(0,o.kt)("h2",{id:"sdwebimagemanager"},"SDWebImageManager"),(0,o.kt)("p",null,"\u63a5\u4e0b\u6765\u7814\u7a76 ",(0,o.kt)("inlineCode",{parentName:"p"},"[SDWebImageManager sharedManager]")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"loadImageWithURL:")," \u63a5\u53e3\u3002"),(0,o.kt)("p",null,"SDWebImageManager \u8fd9\u4e2a\u7c7b\u662f UIView category \u63d0\u4f9b\u7684\u63a5\u53e3\u80cc\u540e\u771f\u6b63\u5b8c\u6210\u5de5\u4f5c\u7684\u7c7b\u3002\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e0d\u901a\u8fc7 UIView \u7684\u63a5\u53e3\u800c\u76f4\u63a5\u4f7f\u7528\u5b83\u3002\u5b83\u7ed3\u5408\u4e86\u4e0b\u8f7d\u548c\u7f13\u5b58\u7684\u4e24\u90e8\u5206\u529f\u80fd\uff0c\u5b83\u7684\u521d\u59cb\u5316\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (nonnull instancetype)init {\n    id<SDImageCache> cache = [[self class] defaultImageCache];\n    if (!cache) {\n        cache = [SDImageCache sharedImageCache];\n    }\n    id<SDImageLoader> loader = [[self class] defaultImageLoader];\n    if (!loader) {\n        loader = [SDWebImageDownloader sharedDownloader];\n    }\n    return [self initWithCache:cache loader:loader];\n}\n")),(0,o.kt)("p",null,"\u8fd9\u91cc\u7684 cache \u548c loader \u53ef\u4ee5\u7531\u5916\u90e8\u81ea\u884c\u6307\u5b9a\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a\u5219\u4f7f\u7528\u6846\u67b6\u5185\u7684\u9ed8\u8ba4\u5b9e\u73b0\u7c7b\u3002"),(0,o.kt)("h3",{id:"\u4e00\u7ec4\u5408\u64cd\u4f5c"},"\u4e00\u3001\u7ec4\u5408\u64cd\u4f5c"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (SDWebImageCombinedOperation *)loadImageWithURL:(nullable NSURL *)url\n                                          options:(SDWebImageOptions)options\n                                          context:(nullable SDWebImageContext *)context\n                                         progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                                        completed:(nonnull SDInternalCompletionBlock)completedBlock {\n    // \u7ec4\u5408\u64cd\u4f5c\uff1a\u4e0b\u8f7d+\u7f13\u5b58\uff01\n    // \u9075\u5faa SDWebImageOperation \u534f\u8bae\uff0coperation \u53ef\u4ee5\u88ab cancel\uff0c\u56e0\u6b64\u5728\u540e\u7eed\u7684\u6bcf\u4e00\u6b65\u9aa4\u4e2d\uff0c\u90fd\u6709\u5bf9 operation \u72b6\u6001\u7684\u68c0\u67e5\n    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];\n    operation.manager = self;\n\n    // Preprocess the options and context arg to decide the final the result for manager\n    // \u5904\u7406\u81ea\u5b9a\u4e49\u9879\u7684\u4f18\u5148\u987a\u5e8f\uff1a\n    // self.optionsProcessor > \u63a5\u53e3\u4f20\u53c2 context > self.transformer/cacheKeyFilter/cacheSerializer > default\n    SDWebImageOptionsResult *result = [self processedResultForURL:url options:options context:context];\n\n    // Start the entry to load image from cache\n    [self callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock];\n\n    return operation;\n}\n")),(0,o.kt)("p",null,"\u81ea\u5b9a\u4e49\u9879\u7684\u4f18\u5148\u987a\u5e8f\u5904\u7406\uff0c\u7c7b\u4f3c\u4e8e ",(0,o.kt)("a",{parentName:"p",href:"https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration"},"Git Configuration")," \u7684\u5206\u7ea7\u5904\u7406\uff0c\u9ad8\u4f18\u5148\u7ea7\u7684\u9009\u9879\u4f1a\u8986\u76d6\u4f4e\u4f18\u5148\u7ea7\u7684\u9009\u9879\uff08\u4ed3\u5e93 -> \u7528\u6237 -> \u7cfb\u7edf\uff09\u3002"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Git uses a series of configuration files to determine non-default behavior that you may want. The first place Git looks for these values is in the system-wide ","[path]","/etc/gitconfig file, which contains settings that are applied to ",(0,o.kt)("strong",{parentName:"p"},"every user on the system and all of their repositories"),". If you pass the option --system to git config, it reads and writes from this file specifically."),(0,o.kt)("p",{parentName:"blockquote"},"The next place Git looks is the ~/.gitconfig (or ~/.config/git/config) file, which is specific to ",(0,o.kt)("strong",{parentName:"p"},"each user"),". You can make Git read and write to this file by passing the --global option."),(0,o.kt)("p",{parentName:"blockquote"},"Finally, Git looks for configuration values in the configuration file in the Git directory (.git/config) of whatever repository you\u2019re currently using. These values are specific to that ",(0,o.kt)("strong",{parentName:"p"},"single repository"),", and represent passing the --local option to git config. If you don\u2019t specify which level you want to work with, this is the default."),(0,o.kt)("p",{parentName:"blockquote"},"Each of these \u201clevels\u201d (system, global, local) overwrites values in the previous level.")),(0,o.kt)("h3",{id:"\u4e8c\u67e5\u627e\u7f13\u5b58\u6d41\u7a0b"},"\u4e8c\u3001\u67e5\u627e\u7f13\u5b58\u6d41\u7a0b"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"- (void)callCacheProcessForOperation:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u67e5\u627e\u7ed3\u679c\u8fd4\u56de\uff0c\u4e0d\u7ba1\u662f\u5426\u547d\u4e2d\uff0c\u90fd\u8fdb\u5165\u4e0b\u8f7d\u6d41\u7a0b"),(0,o.kt)("li",{parentName:"ul"},"\u6307\u5b9a SDWebImageFromLoaderOnly\uff0c\u4e0d\u9700\u8981\u7f13\u5b58\uff0c\u8fdb\u5165\u4e0b\u8f7d\u6d41\u7a0b")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation\n                                 url:(nonnull NSURL *)url\n                             options:(SDWebImageOptions)options\n                             context:(nullable SDWebImageContext *)context\n                            progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                           completed:(nullable SDInternalCompletionBlock)completedBlock {\n    if (shouldQueryCache) {\n        NSString *key = [self cacheKeyForURL:url context:context];\n        @weakify(operation);\n        operation.cacheOperation = [imageCache queryImageForKey:key options:options context:context cacheType:queryCacheType completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) {\n            @strongify(operation); // \u89e3\u9664 operation \u5f15\u8d77\u7684\u5faa\u73af\u5f15\u7528\uff01\n            // Continue download process\n            [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];\n        }];\n    }\n}\n")),(0,o.kt)("h3",{id:"\u4e09\u4e0b\u8f7d\u6d41\u7a0b"},"\u4e09\u3001\u4e0b\u8f7d\u6d41\u7a0b"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"- (void)callDownloadProcessForOperation:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u9700\u8981\u4e0b\u8f7d",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"\u547d\u4e2d\u7f13\u5b58\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0b\u8f7d\u5b8c\u6210\uff0c\u5237\u65b0\u7f13\u5b58\uff01"),(0,o.kt)("li",{parentName:"ul"},"\u672a\u547d\u4e2d\u7f13\u5b58\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0b\u8f7d\u5b8c\u6210\uff0c\u5199\u5165\u7f13\u5b58\uff01"))),(0,o.kt)("li",{parentName:"ul"},"\u4e0d\u9700\u8981\u4e0b\u8f7d\uff0c\u8fd4\u56de\u7f13\u5b58\u56fe\u7247"),(0,o.kt)("li",{parentName:"ul"},"Image not in cache and download disallowed by delegate")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)callDownloadProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation\n                                    url:(nonnull NSURL *)url\n                                options:(SDWebImageOptions)options\n                                context:(SDWebImageContext *)context\n                            cachedImage:(nullable UIImage *)cachedImage\n                             cachedData:(nullable NSData *)cachedData\n                              cacheType:(SDImageCacheType)cacheType\n                               progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                              completed:(nullable SDInternalCompletionBlock)completedBlock {\n    if (shouldDownload) {\n        if (cachedImage && options & SDWebImageRefreshCached) {\n            // \u7f13\u5b58\u547d\u4e2d\n            [self callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];\n            // context \u662f\u4e0d\u53ef\u53d8\u7684\uff0c\u8981\u60f3\u6539\u53d8\u5b83\u9700\u8981\u7ecf\u8fc7\u4ee5\u4e0b\u7684\u64cd\u4f5c\n            SDWebImageMutableContext *mutableContext;\n            if (context) {\n                mutableContext = [context mutableCopy];\n            } else {\n                mutableContext = [NSMutableDictionary dictionary];\n            }\n            mutableContext[SDWebImageContextLoaderCachedImage] = cachedImage;\n            context = [mutableContext copy];\n        }\n\n        @weakify(operation);\n        operation.loaderOperation = [imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) {\n            @strongify(operation);\n            // Continue store cache process\n            // \u4e0b\u8f7d\u5b8c\u6210\uff0c\u5199\u5165\u7f13\u5b58\uff01\n            [self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];\n        }];\n    }\n}\n")),(0,o.kt)("h3",{id:"\u56db\u5199\u5165\u7f13\u5b58\u6d41\u7a0b"},"\u56db\u3001\u5199\u5165\u7f13\u5b58\u6d41\u7a0b"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"- (void)callStoreCacheProcessForOperation:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u7f13\u5b58\u539f\u59cb\u56fe\u50cf",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"\u8981\u7f13\u5b58\u5230\u78c1\u76d8\uff0c\u5148\u7ecf\u8fc7 cache serializer \u5904\u7406"),(0,o.kt)("li",{parentName:"ul"},"\u7f13\u5b58\u5b8c\u6210\u540e\uff0c\u8fdb\u5165 transform \u6d41\u7a0b")))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)callStoreCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation\n                                      url:(nonnull NSURL *)url\n                                  options:(SDWebImageOptions)options\n                                  context:(SDWebImageContext *)context\n                          downloadedImage:(nullable UIImage *)downloadedImage\n                           downloadedData:(nullable NSData *)downloadedData\n                                 finished:(BOOL)finished\n                                 progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                                completed:(nullable SDInternalCompletionBlock)completedBlock {\n    BOOL shouldCacheOriginal = downloadedImage && finished;\n    // \u6709\u539f\u59cb\u56fe\u50cf\u662f\u4e00\u5b9a\u4f1a\u4fdd\u5b58\u7684\n    if (shouldCacheOriginal) {\n        if (cacheSerializer && (targetStoreCacheType == SDImageCacheTypeDisk || targetStoreCacheType == SDImageCacheTypeAll)) {\n            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\n                @autoreleasepool {\n                    // \u8981\u7f13\u5b58\u5230\u78c1\u76d8\uff0c\u5148\u7ecf\u8fc7 cache serializer \u5904\u7406\n                    // The cache serializer is used to convert the decoded image, the source downloaded data, to the actual data used for storing to the disk cache.\n                    NSData *cacheData = [cacheSerializer cacheDataWithImage:downloadedImage originalData:downloadedData imageURL:url];\n                    // \u8c03\u7528 [imageCache storeImage:image imageData:data forKey:key cacheType:cacheType completion:...];\n                    [self storeImage:downloadedImage imageData:cacheData forKey:key cacheType:targetStoreCacheType options:options context:context completion:^{\n                        // Continue transform process\n                        [self callTransformProcessForOperation:operation url:url options:options context:context originalImage:downloadedImage originalData:downloadedData finished:finished progress:progressBlock completed:completedBlock];\n                    }];\n                }\n            });\n        }\n    }\n}\n")),(0,o.kt)("h3",{id:"\u4e94transform-\u6d41\u7a0b"},"\u4e94\u3001transform \u6d41\u7a0b"),(0,o.kt)("p",null,"\u7f13\u5b58 transform \u540e\u7684\u56fe\u7247\uff0c\u5b8c\u6210\u5168\u6d41\u7a0b\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"// Transform process\n- (void)callTransformProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation\n                                     url:(nonnull NSURL *)url\n                                 options:(SDWebImageOptions)options\n                                 context:(SDWebImageContext *)context\n                           originalImage:(nullable UIImage *)originalImage\n                            originalData:(nullable NSData *)originalData\n                                finished:(BOOL)finished\n                                progress:(nullable SDImageLoaderProgressBlock)progressBlock\n                               completed:(nullable SDInternalCompletionBlock)completedBlock {\n    if (shouldTransformImage) {\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{\n            @autoreleasepool {\n                UIImage *transformedImage = [transformer transformedImageWithImage:originalImage forKey:key];\n                if (transformedImage && finished) {\n                    [self storeImage:transformedImage imageData:cacheData forKey:key cacheType:storeCacheType options:options context:context completion:^{\n                        [self callCompletionBlockForOperation:operation completion:completedBlock image:transformedImage data:originalData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];\n                    }];\n                }\n            }\n        });\n    }\n}\n")),(0,o.kt)("p",null,"\u6846\u67b6\u63d0\u4f9b\u4e86\u5706\u89d2\u3001Resize\u3001Cropping\u3001Flipping\u3001Rotate\u3001Tint\u3001Blur\u3001Fliter \u591a\u79cd transformer\uff0c\u8fd8\u53ef\u4ee5\u81ea\u7531\u7ec4\u5408\u6210 SDImagePipelineTransformer\uff1b\u901a\u8fc7 ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage+Transform")," \u5206\u7c7b\u63d0\u4f9b\u5b9e\u73b0\u3002"),(0,o.kt)("p",null,"\u4e0b\u4e00\u6b65\uff0c\u6211\u4eec\u5206\u522b\u63a2\u7d22 imageCache\uff08\u67e5\u627e\u7f13\u5b58\u3001\u5199\u5165\u7f13\u5b58\uff09\u548c imageLoader\uff08\u4e0b\u8f7d\uff09\u7684\u5b9e\u73b0\u3002"),(0,o.kt)("h2",{id:"sdimagecache"},"SDImageCache"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"SDImageCacheDefine")," \u5b9a\u4e49\u4e86\u534f\u8bae ",(0,o.kt)("inlineCode",{parentName:"p"},"@protocol SDImageCache"),"\uff0c\u5916\u90e8\u53ef\u4ee5\u9075\u5b88\u8fd9\u4e2a\u534f\u8bae\u5e76\u81ea\u884c\u5b9e\u73b0\u534f\u8bae\u4e2d\u7684\u65b9\u6cd5\u3002\u5982\u679c\u4e0d\u81ea\u5b9a\u4e49\u7684\u8bdd\uff0c\u5219\u4f1a\u4f7f\u7528\u9ed8\u8ba4\u7684\u5b9e\u73b0\u7c7b ",(0,o.kt)("inlineCode",{parentName:"p"},"SDImageCache"),"\u3002"),(0,o.kt)("p",null,"\u6211\u4eec\u77e5\u9053 ",(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageCombinedOperation")," \u5305\u542b\u4e86\u4e24\u4e2a\u64cd\u4f5c ",(0,o.kt)("inlineCode",{parentName:"p"},"cacheOperation")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"loaderOperation"),"\uff0c\u5176\u4e2d ",(0,o.kt)("inlineCode",{parentName:"p"},"cacheOperation")," \u5c31\u662f\u4ece\u8fd9\u91cc\u521b\u5efa\u7684\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context cacheType:(SDImageCacheType)queryCacheType done:(nullable SDImageCacheQueryCompletionBlock)doneBlock {\n    // First check the in-memory cache...\n    UIImage *image;\n    if (queryCacheType != SDImageCacheTypeDisk) {\n        image = [self imageFromMemoryCacheForKey:key];\n        // [self.memoryCache objectForKey:key];\n    }\n\n    // \u5982\u679c\u6307\u5b9a\u53ea\u4ece\u5185\u5b58\u4e2d\u67e5\u627e\u7f13\u5b58\uff0c\u5230\u8fd9\u91cc\u5c31\u7ed3\u675f\u4e86\n    if (shouldQueryMemoryOnly) {\n        if (doneBlock) {\n            doneBlock(image, nil, SDImageCacheTypeMemory);\n        }\n        return nil; // \u5df2\u5b8c\u6210\u67e5\u8be2\uff0coperation \u8fd4\u56de nil\n    }\n\n    // Second check the disk cache...\n    NSOperation *operation = [NSOperation new];\n\n    // block\uff0c\u53d6\u78c1\u76d8\u7f13\u5b58\u53ef\u4ee5\u662f\u540c\u6b65\u6216\u5f02\u6b65\u6267\u884c\n    void(^queryDiskBlock)(void) =  ^{\n        // \u64cd\u4f5c\u88ab\u53d6\u6d88\u7684\u8bdd\u8fd9\u4e2a block \u4e0d\u4f1a\u88ab\u6267\u884c\n        if (operation.isCancelled) {\n            if (doneBlock) {\n                doneBlock(nil, nil, SDImageCacheTypeNone);\n            }\n            return;\n        }\n\n        @autoreleasepool {\n            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];\n            // [self.diskCache dataForKey:key];\n            UIImage *diskImage;\n            if (image) {\n                // the image is from in-memory cache, but need image data\n                diskImage = image;\n            } else if (diskData) {\n                diskImage = [self diskImageForKey:key data:diskData options:options context:context];\n                // \u5728\u8fd9\u91cc\u5b8c\u6210\u5bf9\u56fe\u7247\u7684\u89e3\u7801\uff01\n                // \u89c1 SDImageCacheDefine.m\n                // UIImage *image = SDImageCacheDecodeImageData(data, key, [[self class] imageOptionsFromCacheOptions:options], context);\n                // return image;\n\n                // \u89e3\u7801\u540e\u7684\u56fe\u7247\u7f13\u5b58\u5230\u5185\u5b58\u4e2d\uff01\n                if (diskImage && self.config.shouldCacheImagesInMemory) {\n                    NSUInteger cost = diskImage.sd_memoryCost;\n                    [self.memoryCache setObject:diskImage forKey:key cost:cost];\n                }\n            }\n        }\n    };\n    return operation;\n}\n")),(0,o.kt)("p",null,"\u5728 SDMWebImageManager \u7b2c\u56db\u6b65\u5199\u5165\u7f13\u5b58\u6d41\u7a0b\u65f6\uff0c\u4f1a\u8c03\u7528\u5230 SDImageCache \u7684\u8fd9\u4e2a\u65b9\u6cd5\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)storeImage:(nullable UIImage *)image\n         imageData:(nullable NSData *)imageData\n            forKey:(nullable NSString *)key\n          toMemory:(BOOL)toMemory\n            toDisk:(BOOL)toDisk\n        completion:(nullable SDWebImageNoParamsBlock)completionBlock {\n\n    if (toMemory && self.config.shouldCacheImagesInMemory) {\n        NSUInteger cost = image.sd_memoryCost;\n        [self.memoryCache setObject:image forKey:key cost:cost];\n    }\n\n    if (toDisk) {\n        // \u5bf9\u6587\u4ef6\u7684\u8bfb\u5199\u8981\u653e\u5230\u540c\u4e00\u4e2a\u64cd\u4f5c\u961f\u5217\u91cc\n        dispatch_async(self.ioQueue, ^{\n            @autoreleasepool {\n                NSData *data = imageData;\n                if (!data && image) {\n                    // \u6ca1\u6709\u539f\u59cb data\uff0c\u5c1d\u8bd5\u83b7\u53d6\u56fe\u7247\u683c\u5f0f\uff0c\u5e76\u8fdb\u884c\u7f16\u7801\n                    data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil];\n                }\n                // \u5199\u5165\u78c1\u76d8\n                [self _storeImageDataToDisk:data forKey:key];\n            }\n        });\n    }\n}\n")),(0,o.kt)("p",null,"\u6211\u4eec\u63a5\u7740\u63a2\u7d22\uff1a\u5185\u5b58\u7f13\u5b58\u5982\u4f55\u5199\u5165/\u8bfb\u53d6\uff1f\u78c1\u76d8\u7f13\u5b58\u5982\u4f55\u5199\u5165/\u8bfb\u53d6\uff1f\u56fe\u7247\u5982\u4f55\u89e3\u7801\uff1f"),(0,o.kt)("h3",{id:"sdmemorycache"},"SDMemoryCache"),(0,o.kt)("p",null,"SDWebImage \u58f0\u660e\u4e86 ",(0,o.kt)("inlineCode",{parentName:"p"},"@protocol SDMemoryCache <NSObject>")," \u534f\u8bae\u5e76\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u5b9e\u73b0\u3002\u5728\u6846\u67b6\u4e2d\u5904\u5904\u4f53\u73b0\u8fd9\u6837\u7684\u9762\u5411\u534f\u8bae\u7f16\u7a0b\u8bbe\u8ba1\u601d\u60f3\u3002"),(0,o.kt)("h4",{id:"nscache"},"NSCache"),(0,o.kt)("p",null,"SDMemoryCache \u7ee7\u627f\u81ea NSCache\uff0c\u5b83\u6709\u51e0\u4e2a\u7279\u70b9\uff1a"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u81ea\u52a8\u56de\u6536\u5185\u5b58\uff0c\u5f53\u5185\u5b58\u7d27\u5f20\u65f6\uff0c\u81ea\u52a8\u79fb\u9664\u952e\u503c\u5bf9\u3002"),(0,o.kt)("li",{parentName:"ul"},"\u7ebf\u7a0b\u5b89\u5168\uff0c\u64cd\u4f5c\u65e0\u9700\u52a0\u9501\u3002"),(0,o.kt)("li",{parentName:"ul"},"\u5bf9 key \u5f3a\u5f15\u7528\uff0c\u800c\u4e0d\u662f copy\u3002")),(0,o.kt)("p",null,"\u6211\u4eec\u53ef\u4ee5\u6307\u5b9a NSCache \u4e2d\u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"countLimit")," (The maximum number of objects the cache should hold) \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"totalCostLimit")," (The maximum total cost, such as the size in bytes of the object, that the cache can hold)\uff0c\u6765\u63a7\u5236\u7f13\u5b58\u7684\u5bb9\u91cf\uff0c\u8fd9\u4e24\u4e2a\u5c5e\u6027\u9ed8\u8ba4\u503c\u662f 0\uff0c\u5373\u65e0\u9650\u5236\u3002"),(0,o.kt)("h4",{id:"weakmemorycache"},"WeakMemoryCache"),(0,o.kt)("p",null,"\u6ce8\u610f\u5728 SDImageCacheConfig \u4e2d\u6709\u4e00\u4e2a\u9009\u9879 shouldUseWeakMemoryCache \u9ed8\u8ba4\u5f00\u542f\u3002\u5b83\u7684\u8bf4\u660e\uff1a",(0,o.kt)("inlineCode",{parentName:"p"},"SDMemoryCache")," will use a weak maptable to store the image at the same time when it stored to memory, and get removed at the same time. \u5f53\u56fe\u7247\u5b58\u5165\u5185\u5b58\u7f13\u5b58\u7684\u540c\u65f6\uff0c\u4e5f\u5728\u8fd9\u4e2a\u54c8\u5e0c\u8868\u91cc\u4fdd\u5b58\u4e86\u4e00\u4efd\u5f31\u5f15\u7528\u3002"),(0,o.kt)("p",null,"When memory warning is triggered, since the weak maptable does not hold a strong reference to image instance, even when the memory cache itself is purged, some images which are held strongly by UIImageViews or other live instances can be recovered again, to avoid later re-query from disk cache or network. This may be helpful for the case, for example, when app enter background and memory is purged, cause cell flashing after re-enter foreground. \u5f53\u5185\u5b58\u7d27\u5f20\uff0c\u5185\u5b58\u7f13\u5b58\u88ab\u6e05\u9664\u65f6\uff0c\u6709\u4e00\u4e9b\u56fe\u7247\u4ecd\u7136\u4f1a\u88ab\u6b63\u5728\u663e\u793a\u7684 UIView \u5f3a\u5f15\u7528\uff0c\u8fd9\u4e9b\u5185\u5b58\u4e0d\u4f1a\u56de\u6536\uff0c\u8fd9\u65f6 weak memory cache \u5c31\u8d77\u4f5c\u7528\u4e86\u3002\u53ef\u4ee5\u5728\u4e0b\u6b21\u67e5\u627e\u7f13\u5b58\u65f6\u76f4\u63a5\u547d\u4e2d\uff0c\u800c\u65e0\u9700\u8bfb\u53d6\u78c1\u76d8\u3002"),(0,o.kt)("p",null,"\u5b83\u540c\u6837\u4f7f\u7528 NSMapTable \u5b9e\u73b0\uff0c\u5bf9\u5b83\u7684\u64cd\u4f5c\u9700\u8981\u52a0\u9501\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)commonInit {\n    self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];\n    self.weakCacheLock = dispatch_semaphore_create(1);\n}\n")),(0,o.kt)("h4",{id:"\u5c0f\u7ed3"},"\u5c0f\u7ed3"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u5199\u5165\u5185\u5b58\u7f13\u5b58\uff1a\u8c03\u7528 NSCache \u548c NSMapTable \u7684 ",(0,o.kt)("inlineCode",{parentName:"li"},"setObject:forKey:")," \u65b9\u6cd5\u3002"),(0,o.kt)("li",{parentName:"ul"},"\u8bfb\u53d6\u5185\u5b58\u7f13\u5b58\uff1a\u8c03\u7528 NSCache \u7684 ",(0,o.kt)("inlineCode",{parentName:"li"},"objectForKey:")," \u65b9\u6cd5\uff0c\u5982\u679c\u672a\u547d\u4e2d\uff0c\u67e5\u8be2 NSMapTable\u3002\u5982\u679c\u5f31\u5f15\u7528\u7f13\u5b58\u547d\u4e2d\uff0c\u4f1a\u540c\u6b65\u5230 NSCache \u4e2d\uff01"),(0,o.kt)("li",{parentName:"ul"},"\u64e6\u9664\u5185\u5b58\u7f13\u5b58\uff1a\u8c03\u7528 NSCache \u548c NSMapTable \u7684 ",(0,o.kt)("inlineCode",{parentName:"li"},"removeObjectForKey")," \u65b9\u6cd5\u3002")),(0,o.kt)("h3",{id:"sddiskcache"},"SDDiskCache"),(0,o.kt)("p",null,"SDWebImage \u58f0\u660e\u4e86 ",(0,o.kt)("inlineCode",{parentName:"p"},"@protocol SDDiskCache <NSObject>")," \u534f\u8bae\u5e76\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u5b9e\u73b0\u3002\u5728\u6846\u67b6\u4e2d\u5904\u5904\u4f53\u73b0\u8fd9\u6837\u7684\u9762\u5411\u534f\u8bae\u7f16\u7a0b\u8bbe\u8ba1\u601d\u60f3\u3002"),(0,o.kt)("p",null,"\u67e5\u627e\u78c1\u76d8\u7f13\u5b58\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (NSData *)dataForKey:(NSString *)key {\n    NSString *filePath = [self cachePathForKey:key];\n    NSData *data = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];\n    return data;\n}\n")),(0,o.kt)("p",null,"\u5199\u5165\u78c1\u76d8\u7f13\u5b58\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)setData:(NSData *)data forKey:(NSString *)key {\n    if (![self.fileManager fileExistsAtPath:self.diskCachePath]) {\n        [self.fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];\n    }\n\n    NSString *cachePathForKey = [self cachePathForKey:key];\n    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];\n\n    [data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];\n\n    // disable iCloud backup\n    if (self.config.shouldDisableiCloud) {\n        // ignore iCloud backup resource value error\n        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];\n    }\n}\n")),(0,o.kt)("p",null,"SDDiskCache \u8fd8\u5b9e\u73b0\u4e86\u8ba1\u7b97\u6587\u4ef6\u5360\u7528\u5927\u5c0f\u3001\u6587\u4ef6\u4e2a\u6570\u7684\u76f8\u5173\u65b9\u6cd5\u3002"),(0,o.kt)("h4",{id:"\u5982\u4f55\u79fb\u9664\u8fc7\u671f\u7684\u6587\u4ef6"},"\u5982\u4f55\u79fb\u9664\u8fc7\u671f\u7684\u6587\u4ef6"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)removeExpiredData {\n    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];\n\n    // \u7b2c\u4e00\u8f6e\u6e05\u9664\uff1a\u6e05\u9664\u6240\u6709\u8fc7\u671f\u7684\u6587\u4ef6\u3002\u5982\u4f55\u5b9a\u4e49\u201c\u8fc7\u671f\u201d\uff1f\n    // \u53ef\u4ee5\u81ea\u5b9a\u4e49\u6309\u7167\u6587\u4ef6\u7684\u54ea\u4e2a\u5c5e\u6027\uff0c\u6765\u51b3\u5b9a\u662f\u5426\u8fc7\u671f\n    NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;\n\n    NSArray<NSString *> *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey];\n    // \u904d\u5386\u7f13\u5b58\u6587\u4ef6\u5939\uff0c\u83b7\u53d6\u6240\u6709\u6587\u4ef6\u7684\u4ee5\u4e0a\u5c5e\u6027\n    NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL\n                                               includingPropertiesForKeys:resourceKeys\n                                                                  options:NSDirectoryEnumerationSkipsHiddenFiles\n                                                             errorHandler:NULL];\n\n    NSDate *expirationDate = (self.config.maxDiskAge < 0) ? nil: [NSDate dateWithTimeIntervalSinceNow:-self.config.maxDiskAge];\n    NSMutableDictionary<NSURL *, NSDictionary<NSString *, id> *> *cacheFiles = [NSMutableDictionary dictionary];\n    NSUInteger currentCacheSize = 0;\n\n    // Enumerate all of the files in the cache directory.  This loop has two purposes:\n    //  1. Removing files that are older than the expiration date. \u6e05\u9664\u6240\u6709\u8fc7\u671f\u6587\u4ef6\uff01\n    //  2. Storing file attributes for the size-based cleanup pass. \u8bb0\u5f55\u6587\u4ef6\u5c5e\u6027\uff0c\u4e3a\u7b2c\u4e8c\u8f6e\u6e05\u9664\u505a\u51c6\u5907\uff01\n    NSMutableArray<NSURL *> *urlsToDelete = [[NSMutableArray alloc] init];\n    for (NSURL *fileURL in fileEnumerator) {\n        NSError *error;\n        NSDictionary<NSString *, id> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&error];\n\n        // Skip directories and errors.\n        if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) {\n            continue;\n        }\n\n        // Remove files that are older than the expiration date;\n        NSDate *modifiedDate = resourceValues[cacheContentDateKey];\n        if (expirationDate && [[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) {\n            [urlsToDelete addObject:fileURL];\n            continue;\n        }\n\n        // Store a reference to this file and account for its total size.\n        NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];\n        currentCacheSize += totalAllocatedSize.unsignedIntegerValue;\n        cacheFiles[fileURL] = resourceValues;\n    }\n\n    for (NSURL *fileURL in urlsToDelete) {\n        [self.fileManager removeItemAtURL:fileURL error:nil];\n    }\n\n    // \u7b2c\u4e8c\u8f6e\u6e05\u9664\uff1a\u5982\u679c\u5269\u4f59\u6587\u4ef6\u7684\u5927\u5c0f\uff0c\u4ecd\u7136\u8d85\u8fc7\u9650\u5236\u7684\u78c1\u76d8\u7f13\u5b58\u5927\u5c0f\uff0c\u90a3\u4e48\u6267\u884c\u7b2c\u4e8c\u8f6e\u6e05\u9664\n    // \u76ee\u6807\u662f\u5c06\u5360\u7528\u7a7a\u95f4\u6e05\u9664\u5230\u6700\u5927\u9650\u5236\u7684\u4e00\u534a\uff01\n    // \u6700\u201c\u8001\u201d\u7684\u6587\u4ef6\u6700\u5148\u88ab\u6e05\u9664\uff01\n    NSUInteger maxDiskSize = self.config.maxDiskSize;\n    if (maxDiskSize > 0 && currentCacheSize > maxDiskSize) {\n        // Target half of our maximum cache size for this cleanup pass.\n        const NSUInteger desiredCacheSize = maxDiskSize / 2;\n\n        // Sort the remaining cache files by their last modification time or last access time (oldest first).\n        NSArray<NSURL *> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent\n                                                                 usingComparator:^NSComparisonResult(id obj1, id obj2) {\n                                                                     return [obj1[cacheContentDateKey] compare:obj2[cacheContentDateKey]];\n                                                                 }];\n\n        // Delete files until we fall below our desired cache size.\n        for (NSURL *fileURL in sortedFiles) {\n            if ([self.fileManager removeItemAtURL:fileURL error:nil]) {\n                NSDictionary<NSString *, id> *resourceValues = cacheFiles[fileURL];\n                NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];\n                currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;\n                if (currentCacheSize < desiredCacheSize) {\n                    break;\n                }\n            }\n        }\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img",src:n(3628).Z})),(0,o.kt)("h4",{id:"\u5982\u4f55\u5c06\u7f13\u5b58\u7684-key-\u8f6c\u6362\u4e3a\u6587\u4ef6\u540d"},"\u5982\u4f55\u5c06\u7f13\u5b58\u7684 key \u8f6c\u6362\u4e3a\u6587\u4ef6\u540d"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},'static inline NSString * _Nonnull SDDiskCacheFileNameForKey(NSString * _Nullable key) {\n    const char *str = key.UTF8String;\n    if (str == NULL) {\n        str = "";\n    }\n    // \u56de\u987e\u52a0\u5bc6\u54c8\u5e0c\u51fd\u6570\u77e5\u8bc6\uff0c\u5c06\u4efb\u610f\u957f\u5ea6\u5b57\u7b26\u4e32\uff0c\u6620\u5c04\u5230\u56fa\u5b9a\u957f\u5ea6\u7684\u5b57\u7b26\u4e32\uff0c\u4e14\u4e0d\u540c\u7684\u5185\u5bb9\u4e00\u5b9a\u6709\u4e0d\u540c\u7684\u4ea7\u51fa\u3002\n    // C \u8bed\u8a00\u4e2d\u7684\u5b57\u7b26\u6570\u7ec4\uff0c\u5373\u5b57\u7b26\u4e32\n    // \u5c06\u4efb\u610f\u957f\u5ea6\u7684 key\uff0c\u6620\u5c04\u5230 16 \u4f4d\u957f\u5ea6\u7684\u5b57\u7b26\u4e32\uff01\n    unsigned char r[CC_MD5_DIGEST_LENGTH]; // 16\n\n    // @param1: \u9700\u8981\u54c8\u5e0c\u7684\u5185\u5bb9\n    // @param2: \u5185\u5bb9\u7684\u957f\u5ea6\n    // @param3: \u5b58\u653e\u4ea7\u51fa\u7684\u5b57\u7b26\u4e32\n    CC_MD5(str, (CC_LONG)strlen(str), r);\n\n    // \u51b3\u5b9a\u6587\u4ef6\u7684\u6269\u5c55\u540d\uff0c\u5982\u679c\u6269\u5c55\u540d\u8fc7\u957f\u5219\u820d\u5f03\uff01\n    NSURL *keyURL = [NSURL URLWithString:key];\n    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;\n    // File system has file name length limit, we need to check if ext is too long, we don\'t add it to the filename\n    if (ext.length > SD_MAX_FILE_EXTENSION_LENGTH) {\n        ext = nil;\n    }\n\n    // x \u8868\u793a\u4ee5\u5341\u516d\u8fdb\u5236\u5f62\u5f0f\u8f93\u51fa\n    // 02 \u8868\u793a\u4e0d\u8db3\u4e24\u4f4d\uff0c\u524d\u9762\u8865 0 \u8f93\u51fa\uff1b\n    // printf("%02X", 0x123);  // \u6253\u5370\u51fa\uff1a123\n    // printf("%02X", 0x1); // \u6253\u5370\u51fa\uff1a01\n    // \u5c06\u5b57\u7b26\u4e32\u7684\u6bcf\u4e00\u4f4d\u4ee5 16 \u8fdb\u5236\u6570\u8f93\u51fa\uff01\n    NSString *filename = [NSString stringWithFormat:@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@",\n                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],\n                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @"" : [NSString stringWithFormat:@".%@", ext]];\n    return filename;\n}\n')),(0,o.kt)("h4",{id:"extendedcachedata"},"ExtendedCacheData"),(0,o.kt)("p",null,"\u5728\u9605\u8bfb SDDiskCache \u7684\u6e90\u7801\u5b9e\u73b0\u4e2d\uff0c\u8fd8\u53d1\u73b0\u4e86 extendedData \u7684\u8bfb\u5199\uff0c\u8fd9\u662f\u4e00\u4e2a\u4ec0\u4e48\u6570\u636e\u5462\uff1f"),(0,o.kt)("p",null,"\u5728 ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage+ExtendedCacheData")," \u4e2d\u63d0\u5230\uff1aRead and Write the extended object and bind it to the image. Which can hold some extra metadata like Image's scale factor, URL rich link, date, etc. The extended object should conforms to NSCoding, which we use ",(0,o.kt)("inlineCode",{parentName:"p"},"NSKeyedArchiver")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"NSKeyedUnarchiver")," to archive it to data, and write to disk cache."),(0,o.kt)("p",null,"\u662f\u5916\u90e8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u7684\u4e00\u4e2a\u9075\u5faa NSCoding \u534f\u8bae\u7684\u5bf9\u8c61\u3002\u5f53\u8bbe\u7f6e\u4e86\u5b83\u540e\uff0c\u7f13\u5b58\u65f6\u4f1a\u4f7f\u7528 SDFileAttributeHelper \u5de5\u5177\u7c7b\uff0c\u5c06\u5176\u5199\u5165\u5230\u6587\u4ef6\u5c5e\u6027\u4e2d\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'// \u5165\u53c2 name \u662f static NSString * const SDDiskCacheExtendedAttributeName = @"com.hackemist.SDDiskCache";\n// \u8fd9\u4e2a\u5c5e\u6027\u540d\u662f SDWebImage \u5b9a\u4e49\u7684\uff01\n+ (NSData *)extendedAttribute:(NSString *)name atPath:(NSString *)path traverseLink:(BOOL)follow error:(NSError **)err {\n    // #define XATTR_NOFOLLOW   0x0001     /* Don\'t follow symbolic links */\n    // Symbolic Links \u7b26\u53f7\u94fe\u63a5\uff1a\u662f\u4e00\u4e2a\u6307\u5411\u5176\u4ed6\u5730\u65b9\u67d0\u4e2a\u6587\u4ef6\u7684\u6307\u9488\uff0c\u5373\u5feb\u6377\u65b9\u5f0f\uff01\n    int flags = follow ? 0 : XATTR_NOFOLLOW;\n\n    // ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options);\n    // get length\n    // \u8bfb\u53d6\u4f4d\u4e8e "path" \u7684\u6587\u4ef6\u7684 "name" \u5c5e\u6027\u957f\u5ea6\uff01\n    ssize_t attrLen = getxattr([path fileSystemRepresentation], [name UTF8String], NULL, 0, 0, flags);\n\n    // get attribute data\n    NSMutableData *attrData = [NSMutableData dataWithLength:attrLen];\n    // \u83b7\u53d6\u5230\u7684\u5c5e\u6027\u5199\u5165\u5728 [attrData mutableBytes] \u8fd9\u5757\u5185\u5b58\u4e2d\u5e76\u8fd4\u56de\u7ed9\u8c03\u7528\u8005\uff01\n    getxattr([path fileSystemRepresentation], [name UTF8String], [attrData mutableBytes], attrLen, 0, flags);\n    return attrData;\n}\n')),(0,o.kt)("h3",{id:"wwdc-2018---image-and-graphics-best-practices"},(0,o.kt)("a",{parentName:"h3",href:"https://developer.apple.com/videos/play/wwdc2018/219/"},"WWDC 2018 - Image and Graphics Best Practices")),(0,o.kt)("p",null,"\u5728\u5f00\u59cb\u63a2\u7d22\u56fe\u7247\u5982\u4f55\u89e3\u7801\u524d\uff0c\u6211\u4eec\u5148\u5b66\u4e60\u4e00\u4e9b\u51c6\u5907\u77e5\u8bc6\u3002"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UIImageView")," is the class that UIKit provides for displaying a ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage"),". In classical MVC style ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage")," can be thought of as a model object, and ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImageView"),", of course, is a view."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UIImage")," is responsible for loading image content. And ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImageView")," is responsible for displaying it, for rendering it. In addition to rendering, being a continuous process, rather than a one-time event, there's this hidden phase called decoding."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img",src:n(30420).Z})),(0,o.kt)("p",null,"But in order to discuss decoding, I first need to discuss a concept called a buffer."),(0,o.kt)("p",null,"A buffer is just a contiguous region of memory. But we tend to use the term buffer when we're discussing memory that's composed of a sequence of elements of the same size, usually, of the same internal construction."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"data buffer"),", which is just a buffer that contains a sequence of bytes. A data buffer that contains an image file, typically, begins with some metadata describing the size of the image, and then, the image data itself, which is encoded in some form like JPEG compression or PNG."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"image buffer"),", a term we use for buffer that holds the in-memory representation of some image. Each element of this buffer describes the color and transparency of a single pixel in our image."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"frame buffer")," is what holds the actual rendered output of your application. As your application updates its view hierarchy UIKit will render the application's window and all of its subviews into the frame buffer. And that frame buffer provides per pixel color information that the display hardware will read in order to illuminate the pixels on the display, at a fixed interval like 60 fps."),(0,o.kt)("p",null,"When we've assigned a ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage")," to this image view, in order to populate the frame buffer with per pixel data, ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage")," will allocate an image buffer and performs an operation called decoding that will convert the JPEG or PNG or other encoded image data into per pixel image information."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img",src:n(73879).Z})),(0,o.kt)("p",null,"And then, depending on the content mode of our image view, when UIKit asks the image view to render, it will copy and scale the image data from the image buffer as it copies it into the frame buffer. \u6ce8\u610f\uff0c\u7f29\u653e\u53d1\u751f\u5728 image buffer \u62f7\u8d1d\u5230 frame buffer \u7684\u8fc7\u7a0b\u4e2d\uff01\u610f\u5473\u7740\uff0c\u5982\u679c\u5b9e\u9645\u663e\u793a\u5c3a\u5bf8\u6bd4\u539f\u56fe\u5c3a\u5bf8\u5c0f\u7684\u8bdd\uff0cdecode \u539f\u56fe\u5c3a\u5bf8\u5230 image buffer \u7136\u540e\u518d\u7531 UIKit \u7f29\u653e\u5e76\u62f7\u8d1d\u5230 frame buffer \u662f\u4f1a\u6d6a\u8d39\u5185\u5b58\u7a7a\u95f4\u7684\uff01\u90a3\u4e48\u6709\u6ca1\u6709\u529e\u6cd5\u5728\u89e3\u7801\u9636\u6bb5\u53ea\u751f\u6210\u5b9e\u9645\u663e\u793a\u5c3a\u5bf8\u7684 image buffer \u5462\uff1f"),(0,o.kt)("p",null,"Suppose the image view is actually smaller than the image we're going to display inside of it. Normally, the core animation framework would be responsible for shrinking that image down during the rendering phase, but we can save some memory by using ",(0,o.kt)("strong",{parentName:"p"},"downsampling")," technique. By capturing that shrinking operation into an object called the thumbnail, we're going to have a smaller decoded image buffer."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"img",src:n(29324).Z})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},"// Downsampling large images for display at smaller size\nfunc downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -> UIImage {\n    // kCGImageSourceShouldCache Specifies whether the image should be cached in a decoded form.\n    // kCGImageSourceShouldCache = false tells the Core Graphics that we're just creating an object to represent the information stored in the file at this URL.\n    // Don't go ahead and decode this image immediately.\n    let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n    let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions)!\n    let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale\n\n    // kCGImageSourceShouldCacheImmediately = true tells Core Graphics that when I ask you to create the thumbnail that's the exact moment you should create the decoded image buffer for me.\n    // The default value is kCFBooleanFalse (image decoding will happen at rendering time).\n    let downsampleOptions =\n    [kCGImageSourceCreateThumbnailFromImageAlways: true,\n    kCGImageSourceShouldCacheImmediately: true,\n    kCGImageSourceCreateThumbnailWithTransform: true,\n    kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as CFDictionary\n\n    let downsampledImage =\n    CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions)!\n    return UIImage(cgImage: downsampledImage)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (UIImage *)downSampleImageAtPath:(NSString *)path toPointSize:(CGSize)pointSize scale:(CGFloat)scale {\n    // \u52a0\u8f7d\u56fe\u7247\u7684\u9009\u9879\n    CFStringRef key[1];\n    key[0] = kCGImageSourceShouldCache;\n    CFTypeRef value[1];\n    value[0] = (CFTypeRef)kCFBooleanFalse;\n    CFDictionaryRef imageOptions = CFDictionaryCreate(NULL,\n                                                      (const void **) key,\n                                                      (const void **) value,\n                                                      1,\n                                                      &kCFTypeDictionaryKeyCallBacks,\n                                                      &kCFTypeDictionaryValueCallBacks);\n    NSURL *fileURL = [NSURL fileURLWithPath:path];\n    CGImageSourceRef imageSource = CGImageSourceCreateWithURL((__bridge CFURLRef)fileURL, imageOptions);\n    // \u964d\u91c7\u6837\u7684\u9009\u9879\n    CFMutableDictionaryRef downSampleOptions = CFDictionaryCreateMutable(NULL,\n                                                                         4,\n                                                                         &kCFTypeDictionaryKeyCallBacks,\n                                                                         &kCFTypeDictionaryValueCallBacks);\n    CGFloat maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale;\n    NSNumber *maxDimensionInPixelsNum = [NSNumber numberWithFloat:maxDimensionInPixels];\n    CFDictionaryAddValue(downSampleOptions, kCGImageSourceCreateThumbnailFromImageAlways, kCFBooleanTrue);\n    CFDictionaryAddValue(downSampleOptions, kCGImageSourceShouldCacheImmediately, kCFBooleanTrue);\n    CFDictionaryAddValue(downSampleOptions, kCGImageSourceCreateThumbnailWithTransform, kCFBooleanTrue);\n    CFDictionaryAddValue(downSampleOptions, kCGImageSourceThumbnailMaxPixelSize, (__bridge CFNumberRef)maxDimensionInPixelsNum);\n    // \u521b\u5efa\u964d\u91c7\u6837\u56fe\u7247\n    CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downSampleOptions);\n    return [UIImage imageWithCGImage:imageRef];\n}\n")),(0,o.kt)("p",null,"Best practices when implementing ",(0,o.kt)("inlineCode",{parentName:"p"},"UICollectionView"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Prefetching allows CollectionView to inform our data source that it needs a cell right in the very near future."),(0,o.kt)("li",{parentName:"ol"},"Performing decoding in the background. Rather than simply dispatching work to one of the global asynchronous queues, we're going to create a serial queue to avoid thread explosion. (GCD is keep creating new threads and spend a lot of time moving between those threads to try to make incremental progress)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'let serialQueue = DispatchQueue(label: "Decode queue")\nfunc collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {\n    // Asynchronously decode and downsample every image we are about to show\n    for indexPath in indexPaths {\n        serialQueue.async {\n            let downsampledImage = downsample(images[indexPath.row])\n            DispatchQueue.main.async {\n                self.update(at: indexPath, with: downsampledImage)\n            }\n        }\n    }\n}\n')),(0,o.kt)("h3",{id:"sdimagecachedecodeimagedata"},"SDImageCacheDecodeImageData"),(0,o.kt)("p",null,"\u4ece\u4e00\u6bb5\u6700\u7b80\u5355\u7684\u52a0\u8f7d\u56fe\u7247\u4ee3\u7801\u8bf4\u8d77\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'let image = UIImage(named: "unnamed") // encoded image in data buffer\nimageView.image = image; // decoded image in image buffer\n')),(0,o.kt)("p",null,"\u521b\u5efa\u4e00\u4e2a ",(0,o.kt)("inlineCode",{parentName:"p"},"UIImage")," \u5b9e\u4f8b\u53ea\u4f1a\u52a0\u8f7d data buffer\uff0c \u5c06\u56fe\u50cf\u663e\u793a\u5230\u5c4f\u5e55\u4e0a\u624d\u4f1a\u89e6\u53d1\u89e3\u7801\uff0c\u53ef\u4ee5\u901a\u8fc7 Xcode \u65ad\u70b9\u8c03\u8bd5\uff0c\u89c2\u5bdf\u5185\u5b58\u5360\u7528\u60c5\u51b5\u6765\u9a8c\u8bc1\u8fd9\u4e00\u70b9\u3002\u89e3\u7801\u540e\u7684\u6570\u636e\u5373 image buffer\uff0c\u5305\u542b\u4e86\u56fe\u50cf\u6240\u6709\u50cf\u7d20\u7684\u4fe1\u606f\uff0c\u4f1a\u5360\u7528\u8f83\u591a\u7684\u5185\u5b58\u3002"),(0,o.kt)("p",null,"By default, we will decode the image in the background during cache query and download from the network. This can help to improve performance because when rendering image on the screen, it need to be firstly decoded. But this happen on the main queue by Core Animation. However, this process may increase the memory usage as well. \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5c06\u56fe\u7247\u6e32\u67d3\u5728\u5c4f\u5e55\u4e0a\uff0c\u9700\u8981\u5148\u7531 Core Animation \u5728\u4e3b\u7ebf\u7a0b\u8fdb\u884c\u89e3\u7801\u3002SDWebImage \u5728\u67e5\u8be2\u7f13\u5b58\u548c\u4e0b\u8f7d\u56fe\u7247\u65f6\u5e2e\u6211\u4eec\u5728\u540e\u53f0\u7ebf\u7a0b\u8fdb\u884c\u89e3\u7801\uff0c\u8fd9\u53ef\u4ee5\u63d0\u9ad8\u6027\u80fd\uff0c\u4f46\u4f1a\u589e\u52a0\u5185\u5b58\u5360\u7528\uff08\u4f8b\u5982\u4f60\u5e76\u4e0d\u5b9e\u9645\u663e\u793a\u8fd9\u5f20\u56fe\u7247\uff09\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"UIImage * _Nullable SDImageCacheDecodeImageData(NSData * _Nonnull imageData, NSString * _Nonnull cacheKey, SDWebImageOptions options, SDWebImageContext * _Nullable context) {\n    UIImage *image; // \u6700\u7ec8\u8fd4\u56de\u7684\u56fe\u7247\n\n    // \u8fd9\u91cc\u7701\u7565\u5bf9\u52a8\u56fe\u7684\u5904\u7406\u76f8\u5173\u4ee3\u7801\uff01\n\n    // \u5982\u679c\u662f UIKit\uff0c\u5219\u9700\u8003\u8651 UIScreen.main.scale\uff01\n    // \u770b cacheKey \u4e2d\u662f\u5426\u542b\u6709 @2x @3x\uff0c\u6709\u7684\u8bdd\uff0c\u53d6\u51fa\u6765\u4f5c\u4e3a scaleFactor\uff01\n    NSNumber *scaleValue = context[SDWebImageContextImageScaleFactor];\n    CGFloat scale = scaleValue.doubleValue >= 1 ? scaleValue.doubleValue : SDImageScaleFactorForKey(cacheKey);\n\n    // \u7f29\u653e\u662f\u5426\u9700\u4fdd\u6301\u539f\u59cb\u5bbd\u9ad8\u6bd4\u4f8b\uff01\n    NSNumber *preserveAspectRatioValue = context[SDWebImageContextImagePreserveAspectRatio];\n    // \u7f29\u7565\u56fe\u5927\u5c0f\n    NSValue *thumbnailSizeValue;\n\n    // \u662f\u5426\u9700\u8981\u964d\u91c7\u6837\uff01\n    BOOL shouldScaleDown = SD_OPTIONS_CONTAINS(options, SDWebImageScaleDownLargeImages);\n    if (shouldScaleDown) {\n        // \u6ce8\u610f\u4e86\uff01\uff01\n        // \u6bcf\u4e00\u4e2a\u50cf\u7d20\u9700\u8981\u5b58\u50a8 RGBA \u4fe1\u606f\uff0c\u5171 8 bits * 4 = 4 bytes\uff01\n        // defaultScaleDownLimitBytes defines the maximum size in MB of the decoded image\n        // \u8fd9\u4e2a\u53d8\u91cf\u5b9a\u4e49\u4e86\u89e3\u7801\u540e\u7684\u56fe\u7247\u6240\u5360\u7528\u7684\u6700\u5927\u5185\u5b58\u5927\u5c0f\uff0c\u5bf9\u4e8e UIKit\uff0cSDWebImage \u7ed9\u7684\u5efa\u8bae\u503c\u662f 60MB\uff01\n\n        // \u8ba1\u7b97\u51fa\u56fe\u7247\u50cf\u7d20\u70b9\u7684\u4e2a\u6570\uff01\n        CGFloat thumbnailPixels = SDImageCoderHelper.defaultScaleDownLimitBytes / 4;\n        // \u6839\u636e\u5185\u5b58\u9650\u5236\u6240\u8ba1\u7b97\u51fa\u7684\u7f29\u7565\u56fe\u5bbd\u9ad8\uff01UIKit \u8ba1\u7b97\u51fa\u6765\u5927\u6982\u662f\u5bbd\u9ad8\u5404 3965.9\uff01\n        CGFloat dimension = ceil(sqrt(thumbnailPixels));\n        thumbnailSizeValue = @(CGSizeMake(dimension, dimension));\n    }\n    if (context[SDWebImageContextImageThumbnailPixelSize]) {\n        thumbnailSizeValue = context[SDWebImageContextImageThumbnailPixelSize];\n    }\n\n    if (!image) {\n        // \u89c1 SDImageCodersManager\n        // \u9ed8\u8ba4\u8c03\u7528 SDImageIOCoder \u7684\u65b9\u6cd5\uff01\n        image = [imageCoder decodedImageWithData:imageData options:coderOptions];\n    }\n    if (image) {\n        BOOL shouldDecode = !SD_OPTIONS_CONTAINS(options, SDWebImageAvoidDecodeImage);\n        if (shouldDecode) {\n            image = [SDImageCoderHelper decodedImageWithImage:image];\n        }\n    }\n    return image;\n}\n")),(0,o.kt)("p",null,"\u63a5\u4e0b\u6765\u6211\u4eec\u770b SDImageIOCoder \u548c SDImageCoderHelper \u7684 decode \u5206\u522b\u505a\u4e86\u4ec0\u4e48\uff01"),(0,o.kt)("h4",{id:"sdimageiocoder"},"SDImageIOCoder"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (UIImage *)decodedImageWithData:(NSData *)data options:(nullable SDImageCoderOptions *)options {\n    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);\n\n    CGSize thumbnailSize = CGSizeZero;\n    NSValue *thumbnailSizeValue = options[SDImageCoderDecodeThumbnailPixelSize];\n    thumbnailSize = thumbnailSizeValue.CGSizeValue; // in pixels\n\n    UIImage *image = [SDImageIOAnimatedCoder createFrameAtIndex:0 source:source scale:scale preserveAspectRatio:preserveAspectRatio thumbnailSize:thumbnailSize options:nil];\n    CFRelease(source);\n    return image;\n}\n")),(0,o.kt)("p",null,"\u518d\u770b\u5230 SDImageIOAnimatedCoder\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"+ (UIImage *)createFrameAtIndex:(NSUInteger)index source:(CGImageSourceRef)source scale:(CGFloat)scale preserveAspectRatio:(BOOL)preserveAspectRatio thumbnailSize:(CGSize)thumbnailSize options:(NSDictionary *)options {\n    // Parse the image properties\n    NSDictionary *properties = (__bridge_transfer NSDictionary *)CGImageSourceCopyPropertiesAtIndex(source, index, (__bridge CFDictionaryRef)options);\n    NSUInteger pixelWidth = [properties[(__bridge NSString *)kCGImagePropertyPixelWidth] unsignedIntegerValue];\n    NSUInteger pixelHeight = [properties[(__bridge NSString *)kCGImagePropertyPixelHeight] unsignedIntegerValue];\n    CGImagePropertyOrientation exifOrientation = (CGImagePropertyOrientation)[properties[(__bridge NSString *)kCGImagePropertyOrientation] unsignedIntegerValue];\n    if (!exifOrientation) {\n        exifOrientation = kCGImagePropertyOrientationUp;\n    }\n\n    // \u89c1 https://developer.apple.com/documentation/uniformtypeidentifiers/uttype\n    CFStringRef uttype = CGImageSourceGetType(source);\n\n    CGImageRef imageRef;\n    BOOL createFullImage = thumbnailSize.width == 0 || thumbnailSize.height == 0 || pixelWidth == 0 || pixelHeight == 0 || (pixelWidth <= thumbnailSize.width && pixelHeight <= thumbnailSize.height);\n    if (createFullImage) {\n        // \u4e0d\u9700\u8981\u964d\u91c7\u6837\uff0c\u521b\u5efa\u539f\u56fe\uff01\n        imageRef = CGImageSourceCreateImageAtIndex(source, index, (__bridge CFDictionaryRef)[decodingOptions copy]);\n    } else {\n        // \u9700\u8981\u964d\u91c7\u6837\uff0c\u521b\u5efa\u7f29\u7565\u56fe\uff01\n        decodingOptions[(__bridge NSString *)kCGImageSourceCreateThumbnailWithTransform] = @(preserveAspectRatio);\n\n        // Resizing is accomplished by the kCGImageSourceThumbnailMaxPixelSize option, which specifies the maximum dimension used to scale the image at its original aspect ratio.\n        CGFloat maxPixelSize;\n        if (preserveAspectRatio) {\n            CGFloat pixelRatio = pixelWidth / pixelHeight;\n            CGFloat thumbnailRatio = thumbnailSize.width / thumbnailSize.height;\n            if (pixelRatio > thumbnailRatio) {\n                maxPixelSize = thumbnailSize.width;\n            } else {\n                maxPixelSize = thumbnailSize.height;\n            }\n        } else {\n            maxPixelSize = MAX(thumbnailSize.width, thumbnailSize.height);\n        }\n        decodingOptions[(__bridge NSString *)kCGImageSourceThumbnailMaxPixelSize] = @(maxPixelSize);\n\n        decodingOptions[(__bridge NSString *)kCGImageSourceCreateThumbnailFromImageAlways] = @(YES);\n        imageRef = CGImageSourceCreateThumbnailAtIndex(source, index, (__bridge CFDictionaryRef)[decodingOptions copy]);\n    }\n    if (!imageRef) {\n        return nil;\n    }\n    // Thumbnail image post-process\n    if (!createFullImage) {\n        if (preserveAspectRatio) {\n            // kCGImageSourceCreateThumbnailWithTransform will apply EXIF transform as well, we should not apply twice\n            exifOrientation = kCGImagePropertyOrientationUp;\n        } else {\n            // `CGImageSourceCreateThumbnailAtIndex` take only pixel dimension, if not `preserveAspectRatio`, we should manual scale to the target size\n            // \u5165\u53c2 thumbnailSize \u7684\u5bbd\u9ad8\u6bd4\u4f8b\u4e0d\u4e00\u5b9a\u548c\u539f\u56fe\u4e00\u6837\u7684\uff01\n            // \u524d\u9762\u521b\u5efa\u597d\u7684\u7f29\u7565\u56fe\u662f\u6839\u636e thumbnailSize \u5bbd\u3001\u9ad8\u7684\u8f83\u5927\u503c\u521b\u5efa\uff0c\u4fdd\u6301\u4e86\u539f\u56fe\u7684\u6bd4\u4f8b\u7684\uff01\n            // \u6b64\u5904\u8fd8\u9700\u8981\u8fdb\u884c\u518d\u6b21\u7f29\u653e\u4ee5\u5f97\u5230 thumbnailSize \u7684\u56fe\u7247\uff01\n            CGImageRef scaledImageRef = [SDImageCoderHelper CGImageCreateScaled:imageRef size:thumbnailSize];\n            CGImageRelease(imageRef);\n            imageRef = scaledImageRef;\n        }\n    }\n\n    UIImageOrientation imageOrientation = [SDImageCoderHelper imageOrientationFromEXIFOrientation:exifOrientation];\n    UIImage *image = [[UIImage alloc] initWithCGImage:imageRef scale:scale orientation:imageOrientation];\n    CGImageRelease(imageRef);\n    return image;\n}\n")),(0,o.kt)("h4",{id:"sdimagecoderhelper"},"SDImageCoderHelper"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"+ (UIImage *)decodedImageWithImage:(UIImage *)image {\n    CGImageRef imageRef = [self CGImageCreateDecoded:image.CGImage];\n    UIImage *decodedImage = [[UIImage alloc] initWithCGImage:imageRef scale:image.scale orientation:image.imageOrientation];\n    return decodedImage;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"+ (CGImageRef)CGImageCreateDecoded:(CGImageRef)cgImage orientation:(CGImagePropertyOrientation)orientation {\n    size_t width = CGImageGetWidth(cgImage);\n    size_t height = CGImageGetHeight(cgImage);\n\n    BOOL hasAlpha = [self CGImageContainsAlpha:cgImage];\n    CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n    bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n\n    /* \u521b\u5efa\u4e0a\u4e0b\u6587\n\n     @param0 data\n     @param1 width\n     @param2 height\n     @param3 bitsPerComponent\n     @param4 bytesPerRow\n     @param5 space\n     @param6 bitmapInfo\n\n     The context draws into a bitmap which is `width' pixels wide and `height' pixels high.\n\n     The number of components for each pixel is specified by `space',\n     which may also specify a destination color profile.\n     Note that the only legal case when `space' can be NULL is when alpha is specified as kCGImageAlphaOnly.\n\n     The number of bits for each component of a pixel is specified by `bitsPerComponent'.\n\n     The number of bytes per pixel is equal to `(bitsPerComponent * number of components + 7)/8'.\n\n     Each row of the bitmap consists of `bytesPerRow' bytes, which must be at least\n     `width * bytes per pixel' bytes; in addition, `bytesPerRow' must be an\n     integer multiple of the number of bytes per pixel.\n\n     `data', if non-NULL, points to a block of memory at least `bytesPerRow * height' bytes.\n     If `data' is NULL, the data for context is allocated automatically and freed\n     when the context is deallocated.\n\n     `bitmapInfo' specifies whether the bitmap\n     should contain an alpha channel and how it's to be generated, along with\n     whether the components are floating-point or integer. */\n    CGContextRef context = CGBitmapContextCreate(NULL, newWidth, newHeight, 8, 0, [self colorSpaceGetDeviceRGB], bitmapInfo);\n\n    // \u89e3\u7801\u5230 image buffer\uff01\uff01\n    // \u5b9e\u9645\u5c31\u662f\u5bf9\u56fe\u7247\u8fdb\u884c\u91cd\u65b0\u7ed8\u5236\uff0c\u5f97\u5230\u4e00\u5f20\u65b0\u7684\u89e3\u538b\u7f29\u540e\u7684\u4f4d\u56fe\uff01\uff01\n    // \u7ed8\u56fe\uff01\uff01\n    /* Return an image containing a snapshot of the bitmap context `context'. */\n    CGImageRef newImageRef = CGBitmapContextCreateImage(context);\n    CGContextRelease(context);\n\n    return newImageRef;\n}\n")),(0,o.kt)("p",null,"\u56fe\u7247\u89e3\u7801\u7814\u7a76\u5b8c\u4e86\uff0c\u7f13\u5b58\u7684\u5168\u6d41\u7a0b\u63a2\u7d22\u5b8c\u6bd5\uff01"),(0,o.kt)("h2",{id:"sdimageloader"},"SDImageLoader"),(0,o.kt)("h3",{id:"sdwebimagedownloader"},"SDWebImageDownloader"),(0,o.kt)("p",null,"SDWebImageDownloader \u662f SDImageLoader \u534f\u8bae\u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@interface SDWebImageDownloadToken : NSObject <SDWebImageOperation>"),": A token associated with each download. Can be used to cancel a download."),(0,o.kt)("p",null,"NSURLSessionTaskMetrics: Each NSURLSessionTaskMetrics object contains the ",(0,o.kt)("inlineCode",{parentName:"p"},"taskInterval")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"redirectCount"),", as well as metrics for each request-and-response transaction made during the execution of the task."),(0,o.kt)("p",null,"\u8fd9\u91cc\u8bbe\u7f6e\u4e86\u4e24\u4e2a\u9ed8\u8ba4\u7684 HTTP Header\uff0c\u6709\u5173 HTTP Header \u7684\u8bf4\u660e\u53ef\u4ee5\u5728 ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html"},"RFC2616")," \u627e\u5230\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43\n// \u8f93\u51fa `demo/1.0 (iPhone; iOS 14.0; Scale/2.00)`\nuserAgent = [NSString stringWithFormat:@"%@/%@ (%@; iOS %@; Scale/%0.2f)",\n                     [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey],\n                     [[UIDevice currentDevice] model],\n                     [[UIDevice currentDevice] systemVersion],\n                     [[UIScreen mainScreen] scale]];\nheaderDictionary[@"User-Agent"] = userAgent;\nheaderDictionary[@"Accept"] = @"image/*,*/*;q=0.8"; // \u56fe\u7247\u7c7b\u578b\u6743\u91cd 1.0\uff1b\u4efb\u610f\u7c7b\u578b\u6743\u91cd 0.8\uff1b\u5373\u4f18\u5148\u8fd4\u56de\u56fe\u7247\u7c7b\u578b\n')),(0,o.kt)("p",null,"\u6211\u4eec\u77e5\u9053 SDWebImageCombinedOperation \u5305\u542b\u4e86\u4e24\u4e2a\u64cd\u4f5c cacheOperation \u548c loaderOperation\uff0c\u5176\u4e2d loaderOperation \u5c31\u662f\u4ece\u8fd9\u91cc\u521b\u5efa\u7684\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (id<SDWebImageOperation>)requestImageWithURL:(NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context progress:(SDImageLoaderProgressBlock)progressBlock completed:(SDImageLoaderCompletedBlock)completedBlock {\n    return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock];\n}\n\n- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url\n                                                   options:(SDWebImageDownloaderOptions)options\n                                                   context:(nullable SDWebImageContext *)context\n                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock\n                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock {\n    SD_LOCK(self.operationsLock);\n    id downloadOperationCancelToken;\n    NSOperation<SDWebImageDownloaderOperation> *operation = [self.URLOperations objectForKey:url];\n    if (!operation || operation.isFinished || operation.isCancelled) {\n        operation = [self createDownloaderOperationWithUrl:url options:options context:context];\n        @weakify(self);\n        operation.completionBlock = ^{\n            @strongify(self);\n            if (!self) {\n                return;\n            }\n            SD_LOCK(self.operationsLock);\n            [self.URLOperations removeObjectForKey:url];\n            SD_UNLOCK(self.operationsLock);\n        };\n        self.URLOperations[url] = operation;\n        downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];\n        [self.downloadQueue addOperation:operation];\n    } else {\n        // When we reuse the download operation to attach more callbacks, there may be thread safe issue because the getter of callbacks may in another queue (decoding queue or delegate queue)\n        // So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.\n        @synchronized (operation) {\n            downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];\n        }\n    }\n    SD_UNLOCK(self.operationsLock);\n\n    SDWebImageDownloadToken *token = [[SDWebImageDownloadToken alloc] initWithDownloadOperation:operation];\n    token.url = url;\n    token.request = operation.request;\n    token.downloadOperationCancelToken = downloadOperationCancelToken;\n\n    return token;\n}\n\n- (nullable NSOperation<SDWebImageDownloaderOperation> *)createDownloaderOperationWithUrl:(nonnull NSURL *)url\n                                                                                  options:(SDWebImageDownloaderOptions)options\n                                                                                  context:(nullable SDWebImageContext *)context {\n    // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise\n    // \u5df2\u7ecf\u505a\u4e86\u56fe\u7247\u7f13\u5b58\u4e86\uff0c\u9ed8\u8ba4\u5ffd\u7565 NSURLSession \u7684\u7f13\u5b58\uff01\n    NSURLRequestCachePolicy cachePolicy = options & SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;\n    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];\n    mutableRequest.HTTPShouldHandleCookies = SD_OPTIONS_CONTAINS(options, SDWebImageDownloaderHandleCookies);\n    mutableRequest.HTTPShouldUsePipelining = YES;\n    SD_LOCK(self.HTTPHeadersLock);\n    mutableRequest.allHTTPHeaderFields = self.HTTPHeaders;\n    SD_UNLOCK(self.HTTPHeadersLock);\n\n    // \u8c03\u7528\u534f\u8bae\u7684\u65b9\u6cd5\n    NSOperation<SDWebImageDownloaderOperation> *operation = [[operationClass alloc] initWithRequest:request inSession:self.session options:options context:context];\n\n    if (self.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {\n        // Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation\n        // This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations\n        // Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder\n        for (NSOperation *pendingOperation in self.downloadQueue.operations) {\n            [pendingOperation addDependency:operation];\n        }\n    }\n\n    return operation;\n}\n")),(0,o.kt)("h3",{id:"nsoperation"},"NSOperation"),(0,o.kt)("p",null,"\u5728\u5f00\u59cb\u7814\u7a76 ",(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageDownloaderOperation")," \u524d\uff0c\u5148\u590d\u4e60\u4e00\u4e0b ",(0,o.kt)("inlineCode",{parentName:"p"},"NSOperation")," \u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," \u4e24\u4e2a\u65b9\u6cd5\u3002"),(0,o.kt)("p",null,"\u5f53 ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," \u65b9\u6cd5\u8fd4\u56de\u540e\uff0coperation \u5c31\u7ed3\u675f\u4e86\u3002\u5f53\u6211\u4eec\u5728 ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," \u65b9\u6cd5\u4e2d\u6709\u5f02\u6b65\u64cd\u4f5c\u65f6\uff0c\u8fd9\u53ef\u80fd\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\u7ed3\u679c\u3002\u6bd4\u5982\u4ee5\u4e0b\u8fd9\u6bb5\u4ee3\u7801\uff0coperation \u5df2\u7ecf\u5b8c\u6210\u4e86\uff0c\u7f51\u7edc\u8bf7\u6c42\u624d\u8fd4\u56de\u3002"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'private final class DownloadOperation: Operation {\n    override func main() {\n        let url = URL(string: "https://www.baidu.com/")!\n        let request = URLRequest(url: url)\n        let dataTask = URLSession.shared.dataTask(with: request) { (data, response, error) in\n            print("URL data task completed")\n        }\n        dataTask.resume()\n    }\n}\n\nlet op = DownloadOperation()\noperationQueue.addOperation(op)\nDispatchQueue.main.asyncAfter(deadline: .now() + 0.001) {\n    print("operation finished: \\(op.isFinished)")\n}\n')),(0,o.kt)("p",null,"\u56e0\u6b64\uff0c\u5982\u679c\u7b49\u5f85\u5f02\u6b65\u65b9\u6cd5\u6267\u884c\u5b8c\u540e\u518d\u5b8c\u6210\u64cd\u4f5c\uff0c\u53ef\u4ee5\u91cd\u5199 ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," \u65b9\u6cd5\u3002\u6ce8\u610f\uff0c\u5f53\u6211\u4eec\u91cd\u5199 ",(0,o.kt)("inlineCode",{parentName:"p"},"start")," \u65b9\u6cd5\u65f6\uff0c\u9700\u8981\u81ea\u884c\u8ffd\u8e2a operation \u7684\u72b6\u6001\u5e76\u5b9e\u73b0\u72b6\u6001\u8f6c\u6362\uff1b\u5e76\u4e14\uff0c\u8fd8\u9700\u8981\u8c03\u7528 KVO \u65b9\u6cd5\u901a\u77e5\u5916\u90e8\uff01"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'private final class DownloadOperation: Operation {\n    private var _executing: Bool = false\n    override var isExecuting: Bool {\n        get {\n            return _executing\n        }\n        set {\n            if _executing != newValue {\n                willChangeValue(forKey: "isExecuting")\n                _executing = newValue\n                didChangeValue(forKey: "isExecuting")\n            }\n        }\n    }\n\n    private var _finished: Bool = false\n    override var isFinished: Bool {\n        get {\n            return _finished\n        }\n        set {\n            if _finished != newValue {\n                willChangeValue(forKey: "isFinished")\n                _finished = newValue\n                didChangeValue(forKey: "isFinished")\n            }\n        }\n    }\n\n    override func start() {\n        self.isExecuting = true\n        let url = URL(string: "https://www.baidu.com")!\n        let request = URLRequest(url: url)\n        let dataTask = URLSession.shared.dataTask(with: request) { (data, response, error) in\n            print("URL data task completed")\n            self.isExecuting = false\n            self.isFinished = true\n        }\n        dataTask.resume()\n    }\n}\n\nlet op = DownloadOperation()\noperationQueue.addOperation(op)\n')),(0,o.kt)("h3",{id:"sdwebimagedownloaderoperation"},"SDWebImageDownloaderOperation"),(0,o.kt)("p",null,"\u4e86\u89e3\u4e86 NSOperation \u7684\u77e5\u8bc6\u540e\uff0c\u6211\u4eec\u6765\u770b ",(0,o.kt)("inlineCode",{parentName:"p"},"SDWebImageDownloaderOperation")," \u7684\u76f8\u5173\u65b9\u6cd5"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},'- (void)start {\n    @synchronized (self) {\n        if (self.isCancelled) {\n            self.finished = YES;\n            // Operation cancelled by user before sending the request\n            [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:@{NSLocalizedDescriptionKey : @"Operation cancelled by user before sending the request"}]];\n            [self reset];\n            return;\n        }\n\n        // \u542f\u52a8\u540e\u53f0\u4efb\u52a1\uff0c\u7533\u8bf7 App \u9000\u51fa\u540e\u53f0\u540e\u989d\u5916\u7684\u6267\u884c\u65f6\u95f4\n        Class UIApplicationClass = NSClassFromString(@"UIApplication");\n        BOOL hasApplication = UIApplicationClass && [UIApplicationClass respondsToSelector:@selector(sharedApplication)];\n        if (hasApplication && [self shouldContinueWhenAppEntersBackground]) {\n            __weak typeof(self) wself = self;\n            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];\n            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^{\n                [wself cancel];\n            }];\n        }\n\n        // session \u4e00\u822c\u60c5\u51b5\u4e0b\u662f\u4ece SDWebImageDownloader \u4f20\u8fdb\u6765\u7684\n        NSURLSession *session = self.unownedSession;\n        if (!session) {\n            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];\n            sessionConfig.timeoutIntervalForRequest = 15;\n            session = [NSURLSession sessionWithConfiguration:sessionConfig\n                                                    delegate:self\n                                               delegateQueue:nil];\n            self.ownedSession = session;\n        }\n\n        self.dataTask = [session dataTaskWithRequest:self.request];\n        self.executing = YES;\n    }\n\n    if (self.dataTask) {\n        [self.dataTask resume];\n        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) {\n            progressBlock(0, NSURLResponseUnknownLength, self.request.URL);\n        }\n        __block typeof(self) strongSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:strongSelf];\n        });\n    }\n}\n\n- (void)cancel {\n    @synchronized (self) {\n        [self cancelInternal];\n    }\n}\n\n- (void)cancelInternal {\n    if (self.isFinished) return;\n    [super cancel];\n\n    if (self.dataTask) {\n        [self.dataTask cancel];\n        __block typeof(self) strongSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:strongSelf];\n        });\n        if (self.isExecuting) self.executing = NO;\n        if (!self.isFinished) self.finished = YES;\n    }\n    [self reset];\n}\n\n- (void)reset {\n    @synchronized (self) {\n        [self.callbackBlocks removeAllObjects];\n        self.dataTask = nil;\n\n        if (self.ownedSession) {\n            [self.ownedSession invalidateAndCancel];\n            self.ownedSession = nil;\n        }\n\n        if (self.backgroundTaskId != UIBackgroundTaskInvalid) {\n            // If backgroundTaskId != UIBackgroundTaskInvalid, sharedApplication is always exist\n            UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];\n            [app endBackgroundTask:self.backgroundTaskId];\n            self.backgroundTaskId = UIBackgroundTaskInvalid;\n        }\n    }\n}\n')),(0,o.kt)("p",null,"\u63a5\u4e0b\u6765\u770b\u5bf9 NSURLSessionDelegate \u76f8\u5173\u65b9\u6cd5\u7684\u5b9e\u73b0\uff0c\u91cd\u70b9\u5173\u6ce8\u4e0b\u8f7d\u5b8c\u6210\u540e\uff0c\u89e3\u7801\u7684\u8fc7\u7a0b"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {\n    if (self.isFinished) return;\n\n    @synchronized(self) {\n        self.dataTask = nil;\n        __block typeof(self) strongSelf = self;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:strongSelf];\n            if (!error) {\n                [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:strongSelf];\n            }\n        });\n    }\n\n    // make sure to call `[self done]` to mark operation as finished\n    if (error) {\n        // custom error instead of URLSession error\n        if (self.responseError) {\n            error = self.responseError;\n        }\n        [self callCompletionBlocksWithError:error];\n        [self done];\n    } else {\n        NSData *imageData = [self.imageData copy];\n        self.imageData = nil;\n        // decode the image in coder queue, cancel all previous decoding process\n        [self.coderQueue cancelAllOperations];\n        [self.coderQueue addOperationWithBlock:^{\n            UIImage *image = SDImageLoaderDecodeImageData(imageData, self.request.URL, [[self class] imageOptionsFromDownloaderOptions:self.options], self.context);\n            [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES];\n            [self done];\n        }];\n    }\n}\n")),(0,o.kt)("h2",{id:"sdanimatedimage"},"SDAnimatedImage"),(0,o.kt)("p",null,"5.0 \u7248\u672c\u5f00\u59cb\uff0c\u629b\u5f03\u4e86 FLAnimatedImage\uff0c\u7531\u6846\u67b6\u81ea\u884c\u5b9e\u73b0\u3002SDAnimatedImage \u7ee7\u627f\u81ea UIImage\uff0c\u4e0e SDAnimatedImageView \u914d\u5408\u4f7f\u7528\u5c55\u793a\u52a8\u56fe\u3002"),(0,o.kt)("p",null,"SDAnimatedImageView, by default, will decode and cache the image frames with a buffer (where the buffer size is calculated based on current memory status), when the buffer is out of limit size, the older image frame will be purged to free up memory. This allows you to keep a balance in both CPU & memory."),(0,o.kt)("h2",{id:"sdwebimageprefetcher"},"SDWebImagePrefetcher"),(0,o.kt)("p",null,"\u4f7f\u7528\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},"let prefetchURLs = [URL]()\nSDWebImagePrefetcher.shared.prefetchURLs(prefetchURLs)\n")))}d.isMDXComponent=!0},73879:(e,a,n)=>{n.d(a,{Z:()=>t});const t="data:image/jpeg;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6ZmNkMGMwY2IzMzUwMzY4YzVhZGZhZTljZDIyNmVlMmE2N2VlYTgyM2MyYmEwM2RhM2IyZDgzOTE5N2QzNDM3YgpzaXplIDkwOTM4Cg=="},3628:(e,a,n)=>{n.d(a,{Z:()=>t});const t="data:image/png;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6ZDBiNjJkYTMyNWIxY2M2OWRhODVhYzhjY2Q0YjdiNzdlZGM3YTliYzE3ZThhZDViZTE1NWE0NmMyMDlkOTIyMwpzaXplIDIwNjQ5Nwo="},30420:(e,a,n)=>{n.d(a,{Z:()=>t});const t="data:image/jpeg;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6ZWQwMGIyZDdlNDY2OTc2ZTBiNWY1OTFmZDNjOTY1ZWNlYmJmNjAxNjcxMDQ0YWY2MTNlNjk1YmFlMGE4M2QyMwpzaXplIDYxNjU3NAo="},29324:(e,a,n)=>{n.d(a,{Z:()=>t});const t="data:image/jpeg;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6ZGRjYjIxMDdiNWNjZmVmNDg2ZjdiZWVhYWVjMmM5YjY2MDI1MjFkMmVhZTY2ODJlNzlhMmM1Mzc2YTQ2NDlhNwpzaXplIDcwNzAzCg=="}}]);