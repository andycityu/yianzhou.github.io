"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[190],{39228:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));n(61839);const o={},l="Get Accustomed",r={unversionedId:"Effective Objective-C/effective-oc-1",id:"Effective Objective-C/effective-oc-1",title:"Get Accustomed",description:"1. Objective-C's Roots",source:"@site/docs/language/Effective Objective-C/effective-oc-1.md",sourceDirName:"Effective Objective-C",slug:"/Effective Objective-C/effective-oc-1",permalink:"/docs/language/Effective Objective-C/effective-oc-1",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",next:{title:"Objects, Messaging, and the Runtime",permalink:"/docs/language/Effective Objective-C/effective-oc-2"}},s={},c=[{value:"1. Objective-C&#39;s Roots",id:"1-objective-cs-roots",level:2},{value:"2. Forward Declaring",id:"2-forward-declaring",level:2},{value:"3. Literal Syntax",id:"3-literal-syntax",level:2},{value:"4. Prefer Typed Constants to Preprocessor #define",id:"4-prefer-typed-constants-to-preprocessor-define",level:2},{value:"5. Use Enumerations",id:"5-use-enumerations",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"get-accustomed"},"Get Accustomed"),(0,i.kt)("h2",{id:"1-objective-cs-roots"},"1. Objective-C's Roots"),(0,i.kt)("p",null,"Objective-C is a superset of C, adding object-oriented features. Objective-C uses a messaging structure with dynamic binding, meaning that the type of an object is discovered at runtime. The runtime, rather than the compiler, works out what code to run for a given message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'NSString *str = @"Hello";\n')),(0,i.kt)("p",null,"All Objective-C objects must be declared in this way because the memory for objects is always allocated in heap space and never on the stack."),(0,i.kt)("p",null,"The memory allocated in the heap has to be managed directly, whereas the stack-allocated memory to hold the variables is automatically cleaned up when the stack frame on which they are allocated is popped."),(0,i.kt)("p",null,"Objective-C \u4e0d\u9700\u8981\u50cf C \u4e00\u6837\u4f7f\u7528 malloc \u548c free \u6765\u5206\u914d\u6216\u91ca\u653e\u5806\u533a\u5185\u5b58\uff0cObjective-C Runtime \u628a\u8fd9\u90e8\u5206\u5de5\u4f5c\u62bd\u8c61\u4e3a\u4e00\u5957\u5185\u5b58\u7ba1\u7406\u67b6\u6784\uff0c\u5373\u5f15\u7528\u8ba1\u6570\u673a\u5236\u3002"),(0,i.kt)("h2",{id:"2-forward-declaring"},"2. Forward Declaring"),(0,i.kt)("p",null,"To compile anything that imports EOCPerson.h, you don\u2019t need to know the full details about what an EOCEmployer is. All you need to know is that a class called EOCEmployer exists."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"#import <Foundation/Foundation.h>\n@class EOCEmployer;\n\n@interface EOCPerson : NSObject\n@property (nonatomic, copy) NSString *firstName;\n@property (nonatomic, copy) NSString *lastName;\n@property (nonatomic, strong) EOCEmployer *employer;\n\n@end\n")),(0,i.kt)("p",null,"The implementation file for EOCPerson would then need to import the header file of EOCEmployer, as it would need to know the full interface details of the class in order to use it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'#import "EOCPerson.h"\n#import "EOCEmployer.h"\n@implementation EOCPerson\n\n@end\n')),(0,i.kt)("p",null,"Deferring the import to where it is required enables you to limit the scope of what a consumer of your class needs to import. In the example, if EOCEmployer.h were imported in EOCPerson.h, anything importing EOCPerson.h would also import all of EOCEmployer.h. If the chain of importing continues, you could end up importing a lot more than you bargained for, which will certainly increase compile time."),(0,i.kt)("p",null,"Using forward declaration also alleviates the problem of both classes referring to each other."),(0,i.kt)("p",null,"When writing an import into a header file, always ask yourself whether it\u2019s really necessary. If the import can be forward declared, prefer that. If the import is for something used in a property, instance variable, or protocol conformance and can be moved to the class-continuation category (see Item 27), prefer that. Doing so will keep compile time as low as possible and reduce interdependency."),(0,i.kt)("h2",{id:"3-literal-syntax"},"3. Literal Syntax"),(0,i.kt)("p",null,"\u4e0d\u7528 Foundation \u4e5f\u80fd\u5199\u51fa Objective-C \u4ee3\u7801\uff0c\u4f46 iOS \u5f00\u53d1\u4e0e Foundation \u5bc6\u4e0d\u53ef\u5206\u3002\u4f7f\u7528 literal syntax \u4f7f\u4ee3\u7801\u66f4\u6613\u8bfb\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'NSString *str = @"Hello";\nNSNumber *num = @1;\nNSArray *animals = @[@"cat", @"dog"];\nNSDictionary* dic = @{@"key" : @"value", @"key2" : @28};\n')),(0,i.kt)("p",null,"\u901a\u8fc7\u4e0b\u6807\u8fdb\u884c get \u548c set\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'mutableArray[1] = @"dog";\nmutableDictionary[@"lastName"] = @"Galloway";\n')),(0,i.kt)("h2",{id:"4-prefer-typed-constants-to-preprocessor-define"},"4. Prefer Typed Constants to Preprocessor #define"),(0,i.kt)("p",null,"\u5c11\u7528\u9884\u5904\u7406\u6307\u4ee4\uff1a",(0,i.kt)("inlineCode",{parentName:"p"},"#define ANIMATION_DURATION 0.3"),"\uff0c\u591a\u4f7f\u7528\u7c7b\u578b\u5e38\u91cf\uff0c\u540e\u8005\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u53ef\u8bfb\u6027\u3002"),(0,i.kt)("p",null,"A constant that does not need to be exposed to the outside world should be defined in the implementation file where it is used. The usual convention for constants is to prefix with the letter ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," for constants that are local to a translation unit (implementation file)."),(0,i.kt)("p",null,"A translation unit is the input the compiler receives to generate one object file. In the case of Objective-C, this usually means that there is one translation unit per class: every implementation (.m) file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'#import "EOCAnimatedView.h"\n\nstatic const NSTimeInterval kAnimationDuration = 0.3;\n\n@implementation EOCAnimatedView\n- (void)animate {\n    [UIView animateWithDuration:kAnimationDuration animations:^(){}];\n}\n@end\n')),(0,i.kt)("p",null,"It is important that the variable is declared as both ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"const"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," qualifier means that the compiler will throw an error if you try to alter the value."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," qualifier means that the variable is local to the translation unit in which it is defined."),(0,i.kt)("p",null,"So in the preceding example, ",(0,i.kt)("inlineCode",{parentName:"p"},"kAnimationDuration")," will be declared locally to the object file generated from ",(0,i.kt)("inlineCode",{parentName:"p"},"EOCAnimatedView.m"),"."),(0,i.kt)("p",null,"If the variable were not declared ",(0,i.kt)("inlineCode",{parentName:"p"},"static"),", the compiler would create an external symbol for it. If another translation unit also declared a variable with the same name, the linker would throw an error."),(0,i.kt)("p",null,"In fact, when declaring the variable as both ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"const"),", the compiler doesn\u2019t end up creating a symbol at all but instead replaces occurrences just like a preprocessor define does. Remember, however, the benefit is that the type information is present."),(0,i.kt)("p",null,"For constants that are exposed outside of a class, it is usual to prefix with the class name. Such constants need to appear in the global symbol table to be used from outside the translation unit in which they are defined."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'// In the header file\nextern NSString *const EOCStringConstant;\n\n// In the implementation file\nNSString *const EOCStringConstant = @"VALUE";\n')),(0,i.kt)("p",null,"The constant is declared in the header file and defined in the implementation file."),(0,i.kt)("p",null,"The placement of the ",(0,i.kt)("inlineCode",{parentName:"p"},"const"),' qualifier is important, means "constant pointer to an ',(0,i.kt)("inlineCode",{parentName:"p"},"NSString"),'", the constant should not be allowed to change to point to a different ',(0,i.kt)("inlineCode",{parentName:"p"},"NSString")," object."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"extern")," keyword in the header tells the compiler that there will be a symbol for ",(0,i.kt)("inlineCode",{parentName:"p"},"EOCStringConstant")," in the global symbol table. This means that the constant can be used without the compiler\u2019s being able to see the definition for it. The compiler simply knows that the constant will exist when the binary is linked. The compiler will allocate storage for the string in the data section of the object file that is generated from this implementation file. When this object file is linked with other object files to produce the final binary, the linker will be able to resolve the global symbol for ",(0,i.kt)("inlineCode",{parentName:"p"},"EOCStringConstant")," wherever else it has been used."),(0,i.kt)("h2",{id:"5-use-enumerations"},"5. Use Enumerations"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"enum EOCConnectionState {\n    EOCConnectionStateDisconnected,\n    EOCConnectionStateConnecting,\n    EOCConnectionStateConnected,\n};\ntypedef enum EOCConnectionState EOCConnectionState;\n\nEOCConnectionState state = EOCConnectionStateDisconnected;\n")))}d.isMDXComponent=!0}}]);