"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5245],{43452:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));n(61839);const o={},r="Objects, Messaging, and the Runtime",s={unversionedId:"Effective Objective-C/effective-oc-2",id:"Effective Objective-C/effective-oc-2",title:"Objects, Messaging, and the Runtime",description:"6. Property",source:"@site/docs/language/Effective Objective-C/effective-oc-2.md",sourceDirName:"Effective Objective-C",slug:"/Effective Objective-C/effective-oc-2",permalink:"/docs/language/Effective Objective-C/effective-oc-2",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Get Accustomed",permalink:"/docs/language/Effective Objective-C/effective-oc-1"},next:{title:"Interface and API",permalink:"/docs/language/Effective Objective-C/effective-oc-3"}},l={},c=[{value:"6. Property",id:"6-property",level:2},{value:"7. Instance Variables",id:"7-instance-variables",level:2},{value:"\u8bbf\u95ee\u5b9e\u4f8b\u53d8\u91cf\u548c\u8bbf\u95ee\u5c5e\u6027\u7684\u533a\u522b",id:"\u8bbf\u95ee\u5b9e\u4f8b\u53d8\u91cf\u548c\u8bbf\u95ee\u5c5e\u6027\u7684\u533a\u522b",level:3},{value:"\u4f5c\u8005\u63a8\u8350\u7684\u7528\u6cd5",id:"\u4f5c\u8005\u63a8\u8350\u7684\u7528\u6cd5",level:3},{value:"8. Object Equality",id:"8-object-equality",level:2},{value:"9. Class Cluster",id:"9-class-cluster",level:2},{value:"10: Associated Objects",id:"10-associated-objects",level:2},{value:"11: objc_msgSend",id:"11-objc_msgsend",level:2},{value:"12. Message Forwarding",id:"12-message-forwarding",level:2},{value:"resolveInstanceMethod",id:"resolveinstancemethod",level:3},{value:"forwardingTargetForSelector",id:"forwardingtargetforselector",level:3},{value:"forwardInvocation",id:"forwardinvocation",level:3},{value:"\u4f8b\u5b50",id:"\u4f8b\u5b50",level:3},{value:"13. Method Swizzling",id:"13-method-swizzling",level:2},{value:"14. Class Object",id:"14-class-object",level:2}],d={toc:c};function p(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"objects-messaging-and-the-runtime"},"Objects, Messaging, and the Runtime"),(0,i.kt)("h2",{id:"6-property"},"6. Property"),(0,i.kt)("p",null,"\u8bbf\u95ee\u5bf9\u8c61\u7684\u5b9e\u4f8b\u53d8\u91cf\uff0c\u662f\u901a\u8fc7\u8bbf\u95ee\u5bf9\u8c61\u5728\u5185\u5b58\u4e2d\u7684\u9996\u5730\u5740 + \u504f\u79fb\u91cf\u6765\u5b8c\u6210\u3002"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"http://www.sealiesoftware.com/blog/archive/2009/01/27/objc_explain_Non-fragile_ivars.html"},"objc explain: Non-fragile ivars"))),(0,i.kt)("p",null,"\u5982\u679c\u8fd9\u4e2a\u504f\u79fb\u91cf\u662f\u4e00\u4e2a\u7f16\u8bd1\u65f6\u51b3\u5b9a\u7684\u5e38\u91cf\uff0c\u90a3\u4e48\u7236\u7c7b\u589e\u52a0\u6210\u5458\u53d8\u91cf\uff0c\u5c31\u4f1a\u9020\u6210\u5185\u5b58\u5e03\u5c40\u7684\u6539\u52a8\u3001\u5bfc\u81f4\u6240\u6709\u5b50\u7c7b\u90fd\u9700\u8981\u91cd\u65b0\u7f16\u8bd1\uff0c\u5426\u5219\u5c31\u65e0\u6cd5\u8fd0\u884c\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u5728\u67d0\u4e2a macOS \u7248\u672c\u7f16\u5199\u4e86\u4e00\u4e2a\u7c7b ",(0,i.kt)("inlineCode",{parentName:"p"},"PetShopView")," \u7ee7\u627f ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView"),"\uff0c\u5b83\u4eec\u7684\u5185\u5b58\u5e03\u5c40\uff1a"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img",src:n(8705).Z})),(0,i.kt)("p",null,"\u5047\u8bbe\uff0c\u82f9\u679c\u5728\u65b0\u7684 macOS \u7248\u672c\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," \u589e\u52a0\u4e86\u4e00\u4e2a\u5b9e\u4f8b\u53d8\u91cf\uff0c\u90a3\u4e48\u5b83\u4eec\u7684\u5185\u5b58\u5e03\u5c40\u5c31\u4f1a\u53d8\u6210\uff1a"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img",src:n(78610).Z})),(0,i.kt)("p",null,"\u8fd9\u610f\u5473\u7740\uff0c\u6240\u6709\u7ee7\u627f\u81ea ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," \u7684\u5b50\u7c7b\u90fd\u4e0d\u53ef\u7528\u4e86\uff01\u8981\u4e48\u5f00\u53d1\u8005\u91cd\u65b0\u7f16\u8bd1\u5e76\u53d1\u5e03\u66f4\u65b0\uff1b\u8981\u4e48\u82f9\u679c\u5c31\u4e0d\u53ef\u4ee5\u6539\u52a8 ",(0,i.kt)("inlineCode",{parentName:"p"},"NSView")," \u7684\u5b9e\u4f8b\u53d8\u91cf\u5e03\u5c40\u3001\u4ee5\u514d\u65b0\u7248\u64cd\u4f5c\u7cfb\u7edf\u4e0a\u5927\u91cf\u8f6f\u4ef6\u53d8\u5f97\u4e0d\u53ef\u7528\uff01"),(0,i.kt)("p",null,"\u90a3\u4e48\u5982\u4f55\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u5462\uff1f"),(0,i.kt)("p",null,"To overcome this problem, languages have invented a variety of techniques. The approach Objective-C has taken is to make instance variables special variables held by class objects storing the offset. Then at runtime, the offset is looked up so that if the class definition changes, the offset stored is updated; whenever an access to the instance variable is made, the correct offset is used."),(0,i.kt)("p",null,"This is known as the nonfragile Application Binary Interface (ABI). An ABI defines, among other things, the conventions for how code should be generated. The nonfragile ABI also means that instance variables can be defined in a class-continuation category or in the implementation. So you don\u2019t have to have all your instance variables declared in the interface anymore, and you therefore don\u2019t leak internal information about your implementation in the public interface."),(0,i.kt)("p",null,"\u5c5e\u6027\u662f Objective-C \u7684\u7279\u6027\uff0c\u8ba9\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u4e0e\u5c5e\u6027\u76f8\u5173\u7684\u5b58\u53d6\u65b9\u6cd5\u3002\u4f7f\u7528\u201c\u70b9\u8bed\u6cd5\u201d\u7b49\u540c\u4e8e\u8c03\u7528\u4e86\u5b58\u53d6\u65b9\u6cd5\u3002"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@property")," \u7684\u672c\u8d28\u662f\u4ec0\u4e48\uff1f@property = ivar + getter + setter;"),(0,i.kt)("p",null,"\u7f16\u8bd1\u5668\u4f1a\u4e3a\u6bcf\u4e2a ",(0,i.kt)("inlineCode",{parentName:"p"},"@property")," \u6dfb\u52a0 ",(0,i.kt)("inlineCode",{parentName:"p"},"@synthesize"),"\uff0c\u5982\u4ee5\u4e0b\u5f62\u5f0f\uff1a",(0,i.kt)("inlineCode",{parentName:"p"},"@synthesize propertyName = _propertyName;")),(0,i.kt)("p",null,"\u5b9e\u9645\u4e0a\u7f16\u8bd1\u5668\u4f7f\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"_\u5c5e\u6027\u540d")," \u5982 ",(0,i.kt)("inlineCode",{parentName:"p"},"_firstName")," \u4f5c\u4e3a\u771f\u6b63\u7684\u5b9e\u4f8b\u53d8\u91cf\uff0c\u5e76\u751f\u6210\u4e86\u5b58\u53d6\u65b9\u6cd5\u3002\u4f7f\u7528 @synthesize \u53ef\u4ee5\u66f4\u6539\u8fd9\u4e2a\u9ed8\u8ba4\u7684\u540d\u5b57\uff0c\u4f46\u4e0d\u5efa\u8bae\u8fd9\u4e48\u505a\u3002"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@dynamic")," \u53ef\u4ee5\u544a\u8bc9\u7f16\u8bd1\u5668\u4e0d\u8981\u81ea\u52a8\u521b\u5efa\u5b9e\u4f8b\u53d8\u91cf ",(0,i.kt)("inlineCode",{parentName:"p"},"_firstName")," \u548c\u5b58\u53d6\u65b9\u6cd5\u3002"),(0,i.kt)("p",null,"\u5c5e\u6027\u7684 attribute \u4f1a\u5f71\u54cd\u7f16\u8bd1\u5668\u6240\u751f\u6210\u7684\u5b58\u53d6\u65b9\u6cd5\uff1a"),(0,i.kt)("p",null,"\u4e00\u3001\u539f\u5b50\u6027\u3002\u5728 iOS \u5f00\u53d1\u4e2d\uff0c\u6240\u6709\u5c5e\u6027\u90fd\u58f0\u660e\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"nonatomic"),"\uff0c\u8fd9\u6837\u505a\u662f\u56e0\u4e3a\u5728 iOS \u4e2d\u4f7f\u7528\u540c\u6b65\u9501\u7684\u5f00\u9500\u8f83\u5927\uff0c\u4f1a\u5e26\u6765\u4e25\u91cd\u7684\u6027\u80fd\u95ee\u9898\u3002\u800c\u4e14 ",(0,i.kt)("inlineCode",{parentName:"p"},"atomic")," \u7684\u5c5e\u6027\u5e76\u4e0d\u80fd\u4fdd\u8bc1\u7ebf\u7a0b\u5b89\u5168\uff0c\u8981\u4fdd\u8bc1\u7ebf\u7a0b\u5b89\u5168\uff0c\u8fd8\u9700\u91c7\u7528\u66f4\u4e3a\u6df1\u5c42\u7684\u9501\u5b9a\u673a\u5236\u3002"),(0,i.kt)("p",null,"Atomic accessors include locks to ensure atomicity. This means that if two threads are reading and writing the same property, the value of the property at any given point in time is valid. Without the locks, or nonatomic, the property value may be read on one thread while another thread is midway through writing to it. If this happens, the value that\u2019s read could be invalid."),(0,i.kt)("p",null,"If you\u2019ve been developing for iOS at all, you\u2019ll notice that all properties are declared nonatomic. The reason is that, historically, the locking introduces such an overhead on iOS that it becomes a performance problem. Usually, atomicity is not required anyway, since it does not ensure thread safety, which usually requires a deeper level of locking."),(0,i.kt)("p",null,"\u901a\u8fc7\u9605\u8bfb objc \u7684\u6e90\u7801\u5f97\u77e5\uff0c\u5f53\u5c5e\u6027\u88ab\u58f0\u660e\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"atomic"),"\uff0c\u5bf9\u8be5\u5c5e\u6027\u7684\u8bfb\u3001\u5199\u4f1a\u4f7f\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"os_unfair_lock")," \u52a0\u9501\u3002\u8fd9\u4e2a\u9501\u4ec5\u4ec5\u662f\u5728\u8bfb\u3001\u5199\u5c5e\u6027\u65f6\u52a0\u7684\uff0c\u5bf9\u5c5e\u6027\u7684\u5176\u5b83\u64cd\u4f5c\u90fd\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002\u4f8b\u5982\u8fd9\u6837\u4e00\u4e2a\u5c5e\u6027 ",(0,i.kt)("inlineCode",{parentName:"p"},"@property(atomic, assign) int money;"),"\uff0c\u5bf9\u5b83\u8fdb\u884c ",(0,i.kt)("inlineCode",{parentName:"p"},"self.money++")," \u8fd9\u6837\u7684\u64cd\u4f5c\u5c31\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002"),(0,i.kt)("p",null,"\u4e8c\u3001\u8bfb\u5199\u6743\u9650\uff08readwrite \u6216 readonly\uff09"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@property (nonatomic, copy, readonly) NSString *firstName;")),(0,i.kt)("p",null,"readonly \u7684\u5c5e\u6027\u6709\u529e\u6cd5\u4fee\u6539\u5417\uff1f\u6709\uff0c",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html"},"Key-Value Coding"),"\uff1a"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'[person setValue:@"Yian" forKey:"firstName"];')),(0,i.kt)("p",null,"\u4e09\u3001\u5185\u5b58\u7ba1\u7406\uff08ARC\uff09"),(0,i.kt)("p",null,"| assign | The setter is a simple assign operation used for scalar types, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"CGFloat")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"NSInteger"),". |\n| unsafe_unretained | This has the same semantics as assign but is used where the type is an object type to indicate a nonowning relationship (unretained) that is not nilled out (unsafe) when the target is destroyed, unlike weak. |\n| strong | This designates that the property defines an owning relationship. When a new value is set, it is first retained, the old value is released, and then the value is set. |\n| weak | This designates that the property defines a nonowning relationship. When a new value is set, it is not retained; nor is the old value released. This is similar to what assign does, but the value is also nilled out when the object pointed to by the property at any time is destroyed. |\n| copy | This designates an owning relationship similar to strong; however, instead of retaining the value, it is copied. This is often used when the type is ",(0,i.kt)("inlineCode",{parentName:"p"},"NSString")," to preserve encapsulation, since the value passed into the setter might be an instance of the subclass ",(0,i.kt)("inlineCode",{parentName:"p"},"NSMutableString"),". If it\u2019s this mutable variant, the value could be mutated after the property is set, without the object\u2019s knowing. So an immutable copy is taken to ensure that the string cannot change from underneath the object. Any object that may be mutable should take a copy. |"),(0,i.kt)("p",null,"\u5e38\u89c1\u7c7b\u578b\u7684\u5185\u5b58\u7ba1\u7406\u8bed\u4e49\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"// \u975e\u6307\u9488\u7c7b\u578b\u7528 assign\n@property(nonatomic, assign) CGFloat floatNum;\n@property(nonatomic, assign) CGPoint point;\n@property(nonatomic, assign) NSInteger integer;\n\n// \u6307\u9488\u7c7b\u578b\u7528 strong\n@property(nonatomic, strong) NSObject *obj;\n@property(nonatomic, strong) NSNumber *num;\n\n// \u6709\u53ef\u53d8\u5b50\u7c7b\u7684\u8981\u7528 copy\uff0c\u4ee5\u9632\u4e0d\u53ef\u77e5\u7684\u4fee\u6539\n@property(nonatomic, copy) NSString *str;\n@property(nonatomic, copy) NSArray *arr;\n@property(nonatomic, copy) NSDictionary *dic;\n@property(nonatomic, copy) NSSet *set;\n\n// \u53ef\u53d8\u7c7b\u578b\u4e0d\u80fd\u7528 copy\uff0c\u4f1a\u5d29\u6e83\uff01\n@property(nonatomic, strong) NSMutableString *str;\n@property(nonatomic, strong) NSMutableArray *arr;\n@property(nonatomic, strong) NSMutableDictionary *dic;\n@property(nonatomic, strong) NSMutableSet *set;\n")),(0,i.kt)("p",null,"\u6dfb\u52a0\u5173\u8054\u5bf9\u8c61 ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_setAssociatedObject"),"\uff0c\u5176\u4e2d\u5173\u8054\u5bf9\u8c61\u7684\u5185\u5b58\u7ba1\u7406\u8bed\u4e49 ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_AssociationPolicy")," \u5e38\u7528\u7684\u6709\u4e09\u79cd\uff1a"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"OBJC_ASSOCIATION_ASSIGN"),(0,i.kt)("li",{parentName:"ul"},"OBJC_ASSOCIATION_COPY_NONATOMIC"),(0,i.kt)("li",{parentName:"ul"},"OBJC_ASSOCIATION_RETAIN_NONATOMIC")),(0,i.kt)("p",null,"\u56db\u3001\u65b9\u6cd5\u540d getter, setter\uff08\u5c11\u7528\uff09"),(0,i.kt)("h2",{id:"7-instance-variables"},"7. Instance Variables"),(0,i.kt)("p",null,"Properties should always be used to access instance variables of an object ",(0,i.kt)("strong",{parentName:"p"},"externally"),", but how you access instance variables ",(0,i.kt)("strong",{parentName:"p"},"internally")," is a hotly debated topic within the Objective-C community. \u5728\u7c7b\u7684\u5916\u90e8\uff0c\u6beb\u65e0\u7591\u95ee\u5e94\u8be5\u4f7f\u7528\u5c5e\u6027\uff0c\u4f46\u5728\u7c7b\u7684\u5185\u90e8\u662f\u5426\u4f7f\u7528\u5c5e\u6027\uff0c\u5b58\u5728\u4e89\u8bae\u3002"),(0,i.kt)("h3",{id:"\u8bbf\u95ee\u5b9e\u4f8b\u53d8\u91cf\u548c\u8bbf\u95ee\u5c5e\u6027\u7684\u533a\u522b"},"\u8bbf\u95ee\u5b9e\u4f8b\u53d8\u91cf\u548c\u8bbf\u95ee\u5c5e\u6027\u7684\u533a\u522b"),(0,i.kt)("p",null,"Direct access to the instance variables will undoubtedly be faster, as it does not have to go through Objective-C method dispatch. The compiler will emit code that directly accesses the memory where the object\u2019s instance variables are stored. \u76f4\u63a5\u8bbf\u95ee\u5b9e\u4f8b\u53d8\u91cf\uff0c\u4e0d\u4f1a\u7ecf\u8fc7 OC \u65b9\u6cd5\u7684\u6d88\u606f\u53d1\u9001\uff0c\u800c\u662f\u76f4\u63a5\u8bbf\u95ee\u5185\u5b58\u91cc\u5f53\u524d\u7c7b\u7684\u5185\u5b58\u9996\u5730\u5740\u52a0\u4e0a\u4e00\u4e2a\u504f\u79fb\u91cf\uff0c\u901f\u5ea6\u66f4\u5feb\u3002"),(0,i.kt)("p",null,"Direct access bypasses the property\u2019s memory-management semantics defined by the setter. For example, if your property is declared as copy, directly setting the instance variable will not cause a copy to be made. The new value will be retained and the old value released. \u76f4\u63a5\u8bbe\u7f6e\u5b9e\u4f8b\u53d8\u91cf\uff0c\u4f1a\u8df3\u8fc7\u5c5e\u6027\u7684\u5185\u5b58\u7ba1\u7406\u8bed\u4e49\uff01"),(0,i.kt)("p",null,"Key-Value Observing (KVO) notifications would not be fired when accessing the instance variables directly."),(0,i.kt)("p",null,"Accessing through properties can make it easier to debug issues surrounding a property, since you can add a breakpoint to the getter and/or setter to determine who is accessing the properties and when."),(0,i.kt)("h3",{id:"\u4f5c\u8005\u63a8\u8350\u7684\u7528\u6cd5"},"\u4f5c\u8005\u63a8\u8350\u7684\u7528\u6cd5"),(0,i.kt)("p",null,"I strongly encourage you to read instance variables using direct access but to set them using the property, with a few caveats."),(0,i.kt)("p",null,"The first caveat is when values are set within an initializer method. Here, you should always use direct instance variable access, because subclasses could override the setter. However, there are some cases in which you must use the setter in an initializer. This is when the instance variable is declared within a superclass; you cannot access the instance variable directly anyway, so you must use the setter."),(0,i.kt)("p",null,"Another caveat is when the property uses lazy initialization. In this case, you have to go via the getter; if you don\u2019t, the instance variable will never get a chance to be initialized."),(0,i.kt)("h2",{id:"8-object-equality"},"8. Object Equality"),(0,i.kt)("p",null,"NSObject \u534f\u8bae\u4e2d\u6709\u4e24\u4e2a\u7528\u4e8e\u5224\u65ad\u5bf9\u8c61\u662f\u5426\u76f8\u7b49\u7684\u5173\u952e\u65b9\u6cd5\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"- (BOOL)isEqual:(id)object;\n- (NSUInteger)hash;\n")),(0,i.kt)("p",null,"The default implementations of these methods from the NSObject class itself work such that two objects are equal if and only if their pointer values are exactly the same."),(0,i.kt)("p",null,"\u54c8\u5e0c\u65b9\u6cd5\u662f\u7528\u4f5c\u8ba1\u7b97\u5143\u7d20\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u4f4d\u7f6e\u7684\u3002\u5982\u679c\u4e24\u4e2a\u5bf9\u8c61\u76f8\u7b49\uff0c\u5176 hash \u503c\u5fc5\u987b\u76f8\u540c\uff1b\u4f46\u4e24\u4e2a hash \u503c\u76f8\u540c\u7684\u5bf9\u8c61\u4e0d\u4e00\u5b9a\u76f8\u7b49\u3002\u4e24\u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u54c8\u5e0c\u503c\u76f8\u540c\uff0c\u8fd9\u79cd\u60c5\u51b5\u79f0\u4e3a\u54c8\u5e0c\u51b2\u7a81\u3002"),(0,i.kt)("p",null,"\u54c8\u5e0c\u503c\u5728\u5bf9\u8c61\u88ab\u52a0\u5165\u54c8\u5e0c\u8868\u65f6\u4f1a\u7528\u5230\uff08\u4f8b\u5982\u6dfb\u52a0\u81f3 ",(0,i.kt)("inlineCode",{parentName:"p"},"NSSet"),"\u3001\u8bbe\u7f6e\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"NSDictionary")," \u7684 key \u65f6\uff09\u3002\u5728\u5224\u65ad\u5143\u7d20\u662f\u5426\u76f8\u7b49\u65f6\uff0c\u4f1a\u9996\u5148\u5224\u65ad hash \u503c\u662f\u5426\u76f8\u7b49\uff0chash \u503c\u4e0d\u540c\u7684\u4e24\u4e2a\u5bf9\u8c61\u76f4\u63a5\u5224\u65ad\u4e0d\u76f8\u7b49\uff1b\u5982\u679c\u76f8\u7b49\uff0c\u518d\u8c03\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"isEqual:")),(0,i.kt)("p",null,"\u9ed8\u8ba4\u7684\u54c8\u5e0c\u65b9\u6cd5\u76f4\u63a5\u8fd4\u56de\u4e86\u5185\u5b58\u5730\u5740\uff0c\u6240\u4ee5\u603b\u662f\u4e0d\u540c\u7684\u3002\u5982\u679c\u53ea\u5b9e\u73b0\u4e86 ",(0,i.kt)("inlineCode",{parentName:"p"},"isEqual:")," \u800c\u4e0d\u5b9e\u73b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"hash"),"\uff0c\u90a3\u4e48\u5373\u4f7f\u6211\u4eec\u5b9a\u4e49\u4e86 object a is equals to object b\uff0c\u4ed6\u4eec\u8fd8\u662f\u53ef\u4ee5\u88ab\u653e\u5728\u4e00\u4e2a\u96c6\u5408\u91cc\u9762\uff0c\u8fd9\u4e0d\u7b26\u5408\u6211\u4eec\u7684\u5b9a\u4e49\u3002"),(0,i.kt)("h2",{id:"9-class-cluster"},"9. Class Cluster"),(0,i.kt)("p",null,"A class cluster is a great way to hide implementation detail behind an abstract base class."),(0,i.kt)("p",null,"An example from UIKit is UIButton. To create a button, you call the following class method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"+ (UIButton*)buttonWithType:(UIButtonType)type;\n")),(0,i.kt)("p",null,"This ",(0,i.kt)("strong",{parentName:"p"},"factory pattern")," is one way of creating a class cluster."),(0,i.kt)("p",null,"Unfortunately, Objective-C gives no language feature for designating that the base class is abstract. In some cases, there is no init family method defined in the interface, which indicates that perhaps instances should not be created directly."),(0,i.kt)("p",null,"The type of the object returned will depend on the button type passed in. However, all classes inherit from the same base class, UIButton. The point of doing this is that the consumer of the UIButton class does not care about the type of the button being created and the implementation detail behind how that button draws itself. All it needs to know is how to create a button; set attributes, such as the title; and add targets for touch actions."),(0,i.kt)("p",null,"Class Cluster pattern provides the flexibility of multiple subclasses while keeping a clean interface by hiding them away behind an abstract base class."),(0,i.kt)("p",null,"There are many class clusters in the system frameworks. Most of the collection classes are class clusters, such as NSArray, and its mutable counterpart, NSMutableArray."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"// __NSArrayI\nNSArray *arr1 = @[@0, @1];\nNSArray *arr2 = [NSArray arrayWithObjects:@0, @1, nil];\nNSArray *arr3 = [NSArray arrayWithArray:arr1];\nNSArray *arr4 = [[NSArray alloc]initWithObjects:@0, @1, nil];\nNSArray *arr5 = [NSArray arrayWithObjects:@0, nil];\n\n// __NSArray0\uff0c\u4ec5\u521d\u59cb\u5316\uff0c\u4e0d\u542b\u6709\u4efb\u4f55\u5143\u7d20\u7684\u6570\u7ec4\nNSArray *arr6 = [NSArray array];\n\n// __NSSingleObjectArrayI \u53ea\u6709\u4e00\u4e2a\u5143\u7d20\u7684\u6570\u7ec4\nNSArray *arr7 = @[@0];\nNSArray *arr8 = [[NSArray alloc]initWithObjects:@1, nil];\nNSArray *arr9 = [[NSArray alloc]initWithArray:arr7];\n\n// __NSPlaceholderArray \u5360\u4f4d\u6570\u7ec4\nNSArray *arr10 = [NSArray alloc];\n\n// __NSArrayM \u53ef\u53d8\u6570\u7ec4\nNSMutableArray *arr11 = [[NSMutableArray alloc]initWithArray:arr1];\n")),(0,i.kt)("h2",{id:"10-associated-objects"},"10: Associated Objects"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"id objc_getAssociatedObject(id object, void *key);\nvoid objc_removeAssociatedObjects(id object);\n")),(0,i.kt)("h2",{id:"11-objc_msgsend"},"11: objc_msgSend"),(0,i.kt)("p",null,"Since Objective-C is a superset of C, it\u2019s a good idea to start by understanding that calling a function in C uses what is known as static binding, which means that the function being called is known at compile time. For example, consider the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#import <stdio.h>\nvoid printHello() {\n   printf("Hello, world!\\n");\n}\nvoid printGoodbye() {\n    printf("Goodbye, world!\\n");\n}\nvoid doTheThing(int type) {\n    if (type == 0) {\n        printHello();\n    } else {\n        printGoodbye();\n    }\n    return 0;\n}\n')),(0,i.kt)("p",null,"Ignoring inlining, when this is compiled, printHello and printGoodbye are known, and the compiler emits instructions to directly call the functions. The addresses of the functions are effectively hardcoded into the instructions. Consider now if that had been written like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#import <stdio.h>\nvoid printHello() {\n   printf("Hello, world!\\n");\n}\nvoid printGoodbye() {\n    printf("Goodbye, world!\\n");\n}\nvoid doTheThing(int type) {\n    void (*fnc)();\n    if (type == 0) {\n        fnc = printHello;\n    } else {\n        fnc = printGoodbye;\n    }\n    fnc();\n    return 0;\n}\n')),(0,i.kt)("p",null,"Here, dynamic binding is used, since the function being called is unknown until runtime. The difference in the instructions the compiler emits will be that in the first example, a function call is made inside both the if and the else statements. In the second example, only a single function call is made but at the cost of having to read the address of which function to call rather than being hardcoded."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Dynamic binding")," is the mechanism by which methods in Objective-C are invoked when a message is passed to an object. All methods are plain old C functions under the hood, but which one is invoked for a given message is decided entirely at runtime and can even change throughout the course of an app running, making Objective-C truly dynamic. \u8c03\u7528\u54ea\u4e2a\u65b9\u6cd5\u662f\u8fd0\u884c\u65f6\u51b3\u5b9a\u7684\uff0c\u751a\u81f3\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u6539\u53d8\u3002"),(0,i.kt)("p",null,"A message being called on an object looks like this:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"id returnValue = [someObject messageName:parameter];")),(0,i.kt)("p",null,"In this example, someObject is referred to as the receiver, and messageName is the selector. The selector combined with the parameters is known as the message. When it sees this message, the compiler turns it into a standard C function call to the function at the heart of messaging, objc_msgSend, which has the following prototype:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"void objc_msgSend(id self, SEL cmd, ...)")),(0,i.kt)("p",null,"This is a variadic \u53d8\u957f\u53c2\u6570 function that takes two or more parameters. The first parameter is the receiver, the second parameter is the selector (SEL is the type of a selector), and the remaining parameters are the message parameters in the order they appear. A selector is the name that refers to a method. The term selector is often used interchangeably with the term method. The preceding example message will be converted to the following:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"id returnValue = objc_msgSend(receiver, @selector(messageName:), params);")),(0,i.kt)("p",null,"The objc_msgSend function calls the correct method, depending on the type of the receiver and the selector. In order to do this, the function looks through the list of methods implemented by the receiver\u2019s class and, if it finds a method that matches the selector name, jumps to its implementation. If not, the function traverses up the inheritance hierarchy to find the method to jump to. If no matching method is found, message forwarding kicks in."),(0,i.kt)("p",null,"objc_msgSend caches the result in a fast map, one for each class, so that future messages to the same class and selector combination are executed quickly. Even this fast path is slower than for a statically bound function call but not by very much once the selector is cached; in reality, message dispatch is not the bottleneck in an application."),(0,i.kt)("p",null,"The preceding stands only for certain messages. Additional functions are exposed by the Objective-C runtime to handle certain edge cases: ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_msgSend_stret"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"objc_msgSend_fpret"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"objc_msgSendSuper"),"."),(0,i.kt)("p",null,"Every method of an Objective-C object can be thought of as a simple C function, whose prototype is similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_msgSend")," function itself. This is no coincidence. It makes jumping to the method simpler and can make good use of tail-call optimizations. Tail-call optimization occurs when the last thing a function does is call another function. Instead of pushing a new stack frame, the compiler can emit code to jump to the next function. This can be done only if the final thing a function does is call another function and does not need to use the return value for anything. Using this optimization is crucial for ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_msgSend")," because without it, the stack trace would show ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_msgSend")," right before every Objective-C method. Also, stack overflow would occur prematurely."),(0,i.kt)("h2",{id:"12-message-forwarding"},"12. Message Forwarding"),(0,i.kt)("p",null,"A class can understand only messages that it has been programmed to understand, through implementing methods. But it\u2019s not a compile-time error to send a message to a class that it doesn\u2019t understand, since methods can be added to classes at runtime so the compiler has no way of knowing whether a method implementation is going to exist. When it receives a method that it doesn\u2019t understand, an object goes through message forwarding."),(0,i.kt)("p",null,"\u5f53\u6d88\u606f\u63a5\u53d7\u8005\u65e0\u6cd5\u54cd\u5e94\u4e00\u4e2a selector\uff0c\u6d88\u606f\u8f6c\u53d1\u5c31\u53d1\u751f\u4e86\u3002\u8fd9\u5c31\u662f\u89e3\u51b3 unrecognized selector \u5d29\u6e83\u7684\u601d\u8def\uff01"),(0,i.kt)("p",null,"\u6ce8\u610f\uff0c\u6d88\u606f\u8f6c\u53d1\u662f\u9700\u8981\u5f00\u9500\u7684\uff0c\u800c\u4e14\u8d8a\u5f80\u540e\u7684\u6b65\u9aa4\u5f00\u9500\u8d8a\u5927\u3002"),(0,i.kt)("h3",{id:"resolveinstancemethod"},"resolveInstanceMethod"),(0,i.kt)("p",null,"The first method that\u2019s called when a message is passed to an object that it doesn\u2019t understand is a class method on the object\u2019s class: ",(0,i.kt)("inlineCode",{parentName:"p"},"+ (BOOL)resolveInstanceMethod:(SEL)selector"),"."),(0,i.kt)("p",null,"Using this approach requires the implementation of the method to already be available, ready to plug in to the class dynamically. This method is often used to implement @dynamic properties such as occurs in CoreData for accessing properties of ",(0,i.kt)("inlineCode",{parentName:"p"},"NSManagedObjects"),"."),(0,i.kt)("h3",{id:"forwardingtargetforselector"},"forwardingTargetForSelector"),(0,i.kt)("p",null,"\u7b2c\u4e8c\u6b21\u5c1d\u8bd5\u662f\u770b\u6709\u6ca1\u6709\u66ff\u8865\u7684\u6d88\u606f\u63a5\u53d7\u8005\uff1a",(0,i.kt)("inlineCode",{parentName:"p"},"-(id)forwardingTargetForSelector:(SEL)selector"),"\u3002"),(0,i.kt)("p",null,"\u5728\u8fd9\u4e2a\u65b9\u6cd5\u4e2d\u8fd4\u56de\u5b9e\u9645\u5904\u7406\u6d88\u606f\u7684\u5bf9\u8c61\uff0c\u5728\u5916\u90e8\u770b\u6765\u597d\u50cf\u5b83\u81ea\u5df1\u5904\u7406\u8fd9\u4e2a\u6d88\u606f\u4e00\u6837\u3002"),(0,i.kt)("h3",{id:"forwardinvocation"},"forwardInvocation"),(0,i.kt)("p",null,"\u5982\u679c\u4ee5\u4e0a\u90fd\u4e0d\u80fd\u5904\u7406\u6d88\u606f\uff0c\u6700\u540e\u4e00\u4e2a\u65b9\u6cd5\u5c31\u662f\u5b8c\u6574\u7684\u6d88\u606f\u8f6c\u53d1\u3002"),(0,i.kt)("p",null,"\u901a\u8fc7 ",(0,i.kt)("inlineCode",{parentName:"p"},"methodSignatureForSelector:")," \u83b7\u53d6\u65b9\u6cd5\u7b7e\u540d\uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a ",(0,i.kt)("inlineCode",{parentName:"p"},"NSInvocation")," \u5bf9\u8c61\uff0c\u5305\u88c5\u7740\u672a\u88ab\u5904\u7406\u7684\u6d88\u606f\u7684\u5168\u90e8\u7ec6\u8282\uff0c\u5305\u62ec selector, target, parameters\u3002"),(0,i.kt)("p",null,"\u7136\u540e\u8c03\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"forwardInvocation:"),"\uff0c\u5728\u8fd9\u4e2a\u65b9\u6cd5\u7684\u5b9e\u73b0\u4e2d\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u5411\u7236\u7c7b\u8f6c\u53d1\uff0c\u5982\u679c\u7ee7\u627f\u5173\u7cfb\u91cc\u7684\u6240\u6709\u7236\u7c7b\u90fd\u6ca1\u6709\u5904\u7406\uff0c\u90a3\u4e48\u6700\u540e\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"NSObject")," \u7684\u5b9e\u4f8b\u65b9\u6cd5 ",(0,i.kt)("inlineCode",{parentName:"p"},"doesNotRecognizeSelector:")," \u4f1a\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    if ([otherObject respondsToSelector:[anInvocation selector]]) {\n        [anInvocation invokeWithTarget:otherObject];\n    } else {\n        [super forwardInvocation:anInvocation];\n    }\n}\n")),(0,i.kt)("h3",{id:"\u4f8b\u5b50"},"\u4f8b\u5b50"),(0,i.kt)("p",null,"Consider an object that allows you to store any object in it, much like a dictionary, but provides access through properties."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},"#import <Foundation/Foundation.h>\n@interface EOCAutoDictionary : NSObject\n@property (nonatomic, strong) NSString *string;\n@property (nonatomic, strong) NSNumber *number;\n@property (nonatomic, strong) NSDate *date;\n@property (nonatomic, strong) id opaqueObject;\n@end\n")),(0,i.kt)("p",null,"Internally, the values for each property will be held in a dictionary, declaring the properties as @dynamic such that instance variables and accessors are not automatically created for them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'#import "EOCAutoDictionary.h"\n#import <objc/runtime.h>\n@interface EOCAutoDictionary ()\n@property (nonatomic, strong) NSMutableDictionary *backingStore;\n@end\n\n@implementation EOCAutoDictionary\n@dynamic string, number, date, opaqueObject;\n- (id)init {\n    if ((self = [super init])) {\n        _backingStore = [NSMutableDictionary new];\n    }\n    return self;\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)selector {\n    NSString *selectorString = NSStringFromSelector(selector);\n    if ([selectorString hasPrefix:@"set"]) {\n        // "v@:@" is the type encoding of the implementation.\n        // type encoding is made up from characters representing the return type, followed by the parameters that the function takes.\n        class_addMethod(self, selector, (IMP)autoDictionarySetter, "v@:@");\n    } else {\n        class_addMethod(self, selector, (IMP)autoDictionaryGetter, "@@:");\n    }\n    return YES;\n}\n\nid autoDictionaryGetter(id self, SEL _cmd) {\n    // Get the backing store from the object\n    EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;\n    NSMutableDictionary *backingStore = typedSelf.backingStore;\n    // The key is simply the selector name\n    NSString *key = NSStringFromSelector(_cmd);\n    // Return the value\n    return [backingStore objectForKey:key];\n}\n\nvoid autoDictionarySetter(id self, SEL _cmd, id value) {\n    // Get the backing store from the object\n    EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;\n    NSMutableDictionary *backingStore = typedSelf.backingStore;\n    /** The selector will be for example, "setOpaqueObject:".\n    * We need to remove the "set", ":" and lowercase the first * letter of the remainder.\n    */\n    NSString *selectorString = NSStringFromSelector(_cmd);\n    NSMutableString *key = [selectorString mutableCopy];\n    // Remove the \':\' at the end\n    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)]; // Remove the \'set\' prefix\n    [key deleteCharactersInRange:NSMakeRange(0, 3)];\n    // Lowercase the first character\n    NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];\n    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];\n    if (value) {\n        [backingStore setObject:value forKey:key];\n    } else {\n        [backingStore removeObjectForKey:key];\n    }\n}\n@end\n')),(0,i.kt)("p",null,"A similar approach is employed by CALayer, part of the CoreAnimation framework on iOS. This approach allows CALayer to be a key-value-coding-compliant container class, meaning that it can store a value against any key. CALayer uses this ability to allow the addition of custom animatable properties whereby the storage of the property values is handled directly by the base class, but the property definition can be added in a subclass."),(0,i.kt)("h2",{id:"13-method-swizzling"},"13. Method Swizzling"),(0,i.kt)("p",null,"\u65b9\u6cd5\u4ea4\u6362\u4f1a\u5bf9\u7c7b\u7684\u6240\u6709\u5b9e\u4f8b\u90fd\u751f\u6548\u3002"),(0,i.kt)("p",null,"A class\u2019s method list contains a list of ",(0,i.kt)("strong",{parentName:"p"},"selector names to implementation mappings"),", telling the dynamic messaging system where to find the implementation of a given method. The implementations are stored as function pointers called IMPs and have the following prototype:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"id (*IMP)(id, SEL, ...)")),(0,i.kt)("p",null,"Method Swizzling can be used to great advantage, as it can be used to change functionality in classes for which you don't have the source code, without having to subclass and override methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-objc"},'#import "objc/Runtime.h"\n@implementation Demo (Yell) // category \u4e2d\u5b9e\u73b0\n\n// 1. \u4ea4\u6362\u65b9\u6cd5\u5e94\u5728 load \u65b9\u6cd5\n+(void)load{\n    // 2. load \u4f1a\u88ab\u6267\u884c\u591a\u6b21\uff0c\u6240\u4ee5\u4ea4\u6362\u65b9\u6cd5\u5e94\u8be5\u653e\u5230 dispatch_once \u4e2d\u6267\u884c\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Method originalMethod = class_getInstanceMethod([self class], @selector(hello));\n        Method swizzledMethod = class_getInstanceMethod([self class], @selector(yellHello));\n        // 3. \u9996\u5148\u5c1d\u8bd5\u6dfb\u52a0\u65b9\u6cd5\u5b9e\u73b0\uff08\u9488\u5bf9\u7236\u7c7b\u5b9e\u73b0\u4e86\uff0c\u5b50\u7c7b\u6ca1\u5b9e\u73b0\u7684\u60c5\u51b5\uff09\n        BOOL didAddMethod = class_addMethod([self class],\n                                            @selector(hello),\n                                            method_getImplementation(swizzledMethod),\n                                            method_getTypeEncoding(swizzledMethod));\n        if (didAddMethod) {\n            class_replaceMethod([self class],\n                                @selector(yellHello),\n                                method_getImplementation(originalMethod),\n                                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n-(void)yellHello {\n    // 4. \u6839\u636e\u9700\u8981\uff0c\u4ea4\u6362\u7684\u5206\u7c7b\u65b9\u6cd5\u53ef\u4ee5\u8c03\u7528\u539f\u5b9e\u73b0\n    [self yellHello];\n    NSLog(@"Yell hello!");\n}\n')),(0,i.kt)("h2",{id:"14-class-object"},"14. Class Object"),(0,i.kt)("p",null,"\u6bcf\u4e2a Objective-C \u5bf9\u8c61\u5b9e\u4f8b\u90fd\u662f\u6307\u5411\u67d0\u5757\u5185\u5b58\u7684\u6307\u9488\u3002",(0,i.kt)("inlineCode",{parentName:"p"},"id")," \u7c7b\u578b\u662f\u6307\u5411 ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_object")," \u7ed3\u6784\u4f53\u7684\u6307\u9488\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"typedef struct objc_object *id;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"objc_object")," \u7ed3\u6784\u4f53\u6709\u4e00\u4e2a ",(0,i.kt)("inlineCode",{parentName:"p"},"isa")," \u6307\u9488\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"Class")," \u7c7b\u578b\u662f\u6307\u5411 ",(0,i.kt)("inlineCode",{parentName:"p"},"objc_class")," \u7ed3\u6784\u4f53\u7684\u6307\u9488\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct objc_object {\n    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;\n};\n\ntypedef struct objc_class *Class;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"objc_class")," \u7ed3\u6784\u4f53\u6709\u4e24\u4e2a\u7279\u6b8a\u7684\u6307\u9488\uff0c\u4e00\u4e2a\u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"isa"),"\uff0c\u6307\u5411\u5b83\u7684 ",(0,i.kt)("inlineCode",{parentName:"p"},"metaclass"),"\uff1b\u4e00\u4e2a\u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"super_class"),"\uff0c\u6307\u5411\u5b83\u7684\u7236\u7c7b\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct objc_class {\n    Class _Nonnull isa;\n    Class _Nullable super_class;\n};\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"super_class")," \u6307\u9488\u660e\u786e\u4e86\u7ee7\u627f\u5173\u7cfb\uff1b",(0,i.kt)("inlineCode",{parentName:"p"},"isa")," \u6307\u9488\u63cf\u8ff0\u4e86\u5b9e\u4f8b\u6240\u5c5e\u7684\u7c7b\uff1b\u7c7b\u5bf9\u8c61\u6240\u5c5e\u7684\u7c7b\u578b\u662f\u53e6\u5916\u4e00\u4e2a\u7c7b\uff0c\u79f0\u4e3a metaclass\uff0c\u7528\u6765\u8868\u8ff0\u7c7b\u5bf9\u8c61\u672c\u8eab\u7684\u5143\u6570\u636e\uff0cstatic \u65b9\u6cd5\u5c31\u5b9a\u4e49\u4e8e\u6b64\u5904\u3002\u6bcf\u4e2a\u7c7b\u4ec5\u6709\u4e00\u4e2a\u201c\u7c7b\u5bf9\u8c61\u201d\uff0c\u6bcf\u4e2a\u201c\u7c7b\u5bf9\u8c61\u201d\u4ec5\u6709\u4e00\u4e2a\u4e0e\u4e4b\u76f8\u5173\u7684 metaclass\u3002"),(0,i.kt)("p",null,"![image]","(/assets/images/Screen Shot 2020-01-21 at 17.50.43.png)"),(0,i.kt)("p",null,"\u901a\u8fc7\u8fd9\u6837\u7684\u5173\u7cfb\uff0c\u6211\u4eec\u53ef\u4ee5\u67e5\u51fa\u5bf9\u8c61\u662f\u5426\u80fd\u54cd\u5e94\u67d0\u4e2a",(0,i.kt)("inlineCode",{parentName:"p"},"selector"),"\uff0c\u662f\u5426\u9075\u5faa\u67d0\u4e2a\u534f\u8bae\uff0c\u4ee5\u53ca\u5bf9\u8c61\u4f4d\u4e8e\u7c7b\u7ee7\u627f\u4f53\u7cfb\u7684\u54ea\u4e00\u90e8\u5206\u3002"))}p.isMDXComponent=!0},78610:(e,t,n)=>{n.d(t,{Z:()=>a});const a="data:image/png;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6Zjc3YTAyMjNlMzIxYTJlMGJiZWJkOWMwZTVlMzIzNTI0NTBjNzkzOGUxOWE1M2Y0YjcyNzQ5ODJjZDk2NzRlZgpzaXplIDI2NDQyMAo="},8705:(e,t,n)=>{n.d(t,{Z:()=>a});const a="data:image/png;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6YjdjMmQ4NDYwZjIwZTJkMzYxZGE2YmZkMjMwZjEwZTA0MTY2ZDcwMGFkZjBmZDZmNTMzYjE2ZjExYThjYWYzMApzaXplIDIyNTA4NQo="}}]);