"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5398],{10025:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));a(61839);const r={},o="Metal",l={unversionedId:"metal",id:"metal",title:"Metal",description:"Metal \u5b98\u65b9\u6587\u6863\u7ffb\u8bd1",source:"@site/docs/apple/metal.md",sourceDirName:".",slug:"/metal",permalink:"/docs/apple/metal",draft:!1,editUrl:"https://github.com/yianzhou/yianzhou.github.io/docs/apple/metal.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u5185\u5b58\u4f18\u5316",permalink:"/docs/apple/memory"},next:{title:"\u591a\u7ebf\u7a0b",permalink:"/docs/apple/multithread"}},s={},p=[{value:"Metal and MetalKit",id:"metal-and-metalkit",level:2},{value:"Metal Objects",id:"metal-objects",level:2},{value:"Rendering Pipeline",id:"rendering-pipeline",level:2},{value:"Vertex function",id:"vertex-function",level:3},{value:"Rasterization",id:"rasterization",level:3},{value:"Fragment Function",id:"fragment-function",level:3},{value:"Obtain Function Libraries and Create a Pipeline",id:"obtain-function-libraries-and-create-a-pipeline",level:2},{value:"Draw a triangle",id:"draw-a-triangle",level:2},{value:"Vertex Buffer",id:"vertex-buffer",level:2},{value:"Texture",id:"texture",level:2}],d={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"metal"},"Metal"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.jianshu.com/p/0ab0a3823819"},"Metal \u5b98\u65b9\u6587\u6863\u7ffb\u8bd1")),(0,i.kt)("h2",{id:"metal-and-metalkit"},"Metal and MetalKit"),(0,i.kt)("p",null,"Metal\uff1a\u63d0\u4f9b GPU \u7684\u76f4\u63a5\u63a7\u5236\u3002"),(0,i.kt)("p",null,"MetalKit\uff1a\u63d0\u4f9b ",(0,i.kt)("inlineCode",{parentName:"p"},"MTKView: UIView"),"\uff0ca MetalKit view automatically sets up and manages a continuous rendering loop that provides you with a 2D, displayable resource, commonly known as a ",(0,i.kt)("strong",{parentName:"p"},"drawable"),", for each frame."),(0,i.kt)("p",null,"When developing a Metal app, it\u2019s often useful to separate your rendering loop into its own class."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"MTKViewDelegate")," object implements ",(0,i.kt)("inlineCode",{parentName:"p"},"drawInMTKView:")," methods. The view calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawInMTKView:")," method whenever it\u2019s time to render a new frame, as specified by the frame rate (for example, 60 FPS) set on the view\u2019s ",(0,i.kt)("inlineCode",{parentName:"p"},"preferredFramesPerSecond")," property. This callback is typically the main event that begins the execution of your rendering loop."),(0,i.kt)("p",null,"This rate is not guaranteed: the view will pick a closest frame rate that the display is capable of refreshing (usually 30 or 60 times per second). Also if our renderer spends more than 1/60th of a second in ",(0,i.kt)("inlineCode",{parentName:"p"},"-[AAPLRender drawInMTKView:]")," the view will skip further calls until the renderer has returned from that long ",(0,i.kt)("inlineCode",{parentName:"p"},"-[AAPLRender drawInMTKView:]")," call. In other words, the view will drop frames. So we should set this to a frame rate that we think our renderer can consistently maintain."),(0,i.kt)("h2",{id:"metal-objects"},"Metal Objects"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/metal/using_a_render_pipeline_to_render_primitives"},"Using a Render Pipeline to Render Primitives")),(0,i.kt)("p",null,"In this Devices and Commands sample, you learned how to write an app that uses Metal and issues basic rendering commands to the GPU."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLDevice")," object represents a GPU."),(0,i.kt)("p",null,"The first object all apps need to interact with the GPU is a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLCommandQueue")," object."),(0,i.kt)("p",null,"You use a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLCommandQueue")," object to create and organize ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLCommandBuffer")," objects, ensuring that they\u2019re sent to the GPU in the correct order. For every frame, a new ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLCommandBuffer")," object is created and filled with commands that are executed by the GPU."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLCommandBuffer")," object coalesces different commands into a single submission, but they must first be encoded in a device-agnostic \u4e0e\u8bbe\u5907\u65e0\u5173\u7684 way using a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLCommandEncoder")," object."),(0,i.kt)("p",null,"To create a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRenderCommandEncoder")," object, you must first create a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRenderPassDescriptor")," object. A MetalKit view creates a new ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRenderPassDescriptor")," object for every frame, provided via the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentRenderPassDescriptor")," property."),(0,i.kt)("p",null,"Commands encoded into this ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRenderCommandEncoder")," object render to the view\u2019s drawable. By default, creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRenderCommandEncoder")," object implicitly encodes a clear command that the GPU executes before any other rendering commands."),(0,i.kt)("p",null,"You call the ",(0,i.kt)("inlineCode",{parentName:"p"},"presentDrawable:")," method to tell Metal to wait for the GPU to finish rendering to a drawable before presenting it onscreen."),(0,i.kt)("p",null,"The GPU also doesn\u2019t execute commands until ",(0,i.kt)("inlineCode",{parentName:"p"},"[commandBuffer commit];"),". When the GPU begins execution, the drawable is cleared with a new color. When the GPU completes execution, the rendered drawable is presented onscreen."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://docs-assets.developer.apple.com/published/6aedb538f8/b5ff0489-1079-441a-8a24-8f8c75dd2b1e.png",alt:"image"})),(0,i.kt)("h2",{id:"rendering-pipeline"},"Rendering Pipeline"),(0,i.kt)("p",null,"In its most basic form, the pipeline receives vertices as input and renders pixels as output. This sample focuses on the three main stages of the pipeline: The vertex function and fragment function are programmable stages. The rasterization stage is fixed."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://docs-assets.developer.apple.com/published/a8fcc3ae6f/24096b5e-34f4-460d-a72b-ca5fb5ef51e5.png",alt:"image"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Vertex")," data is usually loaded from a file that contains 3D model data exported from specialized modeling software."),(0,i.kt)("p",null,"Vertex data, and 3D graphics data in general, is usually defined with ",(0,i.kt)("strong",{parentName:"p"},"vector")," data types, simplifying common graphics algorithms and GPU processing. This sample uses optimized vector data types provided by the ",(0,i.kt)("a",{parentName:"p",href:"http://ermig1979.github.io/Simd/"},"SIMD library")," to represent the triangle\u2019s vertices."),(0,i.kt)("p",null,"Using SIMD data types in your Metal app ensures that memory layouts match exactly across CPU/GPU declarations and facilitates sending vertex data from the CPU to the GPU."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/metal/mtlviewport"},"viewport")," is a ",(0,i.kt)("strong",{parentName:"p"},"3D area")," with an x and y offset, a width and height, and near and far planes (for 3D contents)."),(0,i.kt)("h3",{id:"vertex-function"},"Vertex function"),(0,i.kt)("p",null,"The main task of a ",(0,i.kt)("strong",{parentName:"p"},"vertex function")," (also known as a vertex shader) is to process incoming vertex data and map each vertex to a position in the viewport. This way, subsequent stages in the pipeline can refer to this viewport position and render pixels to an exact location in the drawable. The vertex function accomplishes this task by translating arbitrary vertex coordinates into normalized device coordinates (NDC), also known as ",(0,i.kt)("strong",{parentName:"p"},"clip-space coordinates"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Clip space is a 2D coordinate system")," that maps the viewport area to a ","[-1.0, 1.0]"," range along both the x and y axes."),(0,i.kt)("p",null,"Vertex functions are written in the Metal shading language(",(0,i.kt)("inlineCode",{parentName:"p"},".metal"),"), which is based on C++ 14. Traditional C/C++ code is typically executed on the CPU, whereas Metal shading language code is exclusively executed on the GPU."),(0,i.kt)("p",null,"\u5173\u4e8e\u51fd\u6570\u4e2d\u7684",(0,i.kt)("inlineCode",{parentName:"p"},"[[]]"),"\u5c5e\u6027\u4fee\u9970\u7b26\u56f0\u6270\u4e86\u6211\u4e00\u6bb5\u65f6\u95f4\uff0c\u8fd9\u662f\u82f9\u679c\u5b9a\u4e49\u597d\u7684\u63cf\u8ff0\u5c5e\u6027\u7684\u4fee\u9970\u7b26\u3002"),(0,i.kt)("h3",{id:"rasterization"},"Rasterization"),(0,i.kt)("p",null,"\u6211\u4eec\u8bbe\u7f6e\u4e86\u4e09\u89d2\u5f62\u4e09\u4e2a\u9876\u70b9\u7684\u989c\u8272\uff0c\u90a3\u4e48\u4f4d\u4e8e\u4e09\u89d2\u5f62\u533a\u57df\u5185\u7684\u5176\u5b83\u9876\u70b9\u7684\u989c\u8272\u5982\u4f55\u786e\u5b9a\u5462\uff1fThe rasterizer passes color values to the fragment function after converting them from per-vertex values to per-fragment values. This conversion uses a fixed interpolation function, which calculates a single weighted color derived from the color values of the triangle\u2019s three vertices. The weights for the interpolation function (also known as barycentric coordinates) are the relative distances of each vertex position to the center of a fragment."),(0,i.kt)("p",null,"\u8fd9\u662f\u4e00\u4e2a\u4e0d\u53ef\u7f16\u7a0b\u7684\u6b65\u9aa4\u3002Because rasterization is a fixed pipeline stage, its behavior can\u2019t be modified by custom Metal shading language code."),(0,i.kt)("h3",{id:"fragment-function"},"Fragment Function"),(0,i.kt)("p",null,"The main task of a fragment function (also known as fragment shader) is to process incoming fragment data and calculate a RGBA color value for the drawable\u2019s pixels."),(0,i.kt)("h2",{id:"obtain-function-libraries-and-create-a-pipeline"},"Obtain Function Libraries and Create a Pipeline"),(0,i.kt)("p",null,"Metal shading language code is compiled in two stages:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Front-end compilation happens in Xcode at build time. ",(0,i.kt)("inlineCode",{parentName:"li"},".metal")," files are compiled from high-level source code into intermediate representation (IR) files."),(0,i.kt)("li",{parentName:"ol"},"Back-end compilation happens in a physical device at runtime. IR files are then compiled into low-level machine code.")),(0,i.kt)("p",null,"These ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLFunction")," objects are used to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRenderPipelineState")," object that ",(0,i.kt)("strong",{parentName:"p"},"represents the graphics-rendering pipeline"),". Calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"newRenderPipelineStateWithDescriptor:error:")," method of a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLDevice")," object begins the back-end compilation process that links the ",(0,i.kt)("inlineCode",{parentName:"p"},"vertexShader")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fragmentShader")," functions, resulting in a fully compiled pipeline."),(0,i.kt)("p",null,"A view\u2019s ",(0,i.kt)("strong",{parentName:"p"},"pixel format")," defines the memory layout of each of its pixels. This sample only renders to a single target, the view\u2019s drawable (",(0,i.kt)("inlineCode",{parentName:"p"},"colorAttachments[0]"),")."),(0,i.kt)("h2",{id:"draw-a-triangle"},"Draw a triangle"),(0,i.kt)("p",null,"Triangles are geometric primitives in Metal that require three vertices to be drawn. With the drawing complete, the render loop can end encoding, commit the command buffer, and present the drawable containing the rendered triangle."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/metal/basic_buffers"},"Basic Buffers: Demonstrates how to manage hundreds of vertices with a vertex buffer."))),(0,i.kt)("h2",{id:"vertex-buffer"},"Vertex Buffer"),(0,i.kt)("p",null,"Typically, Metal apps or games draw models with thousands of vertices, each with multiple vertex attributes, that consume several megabytes of memory. For these apps or games to scale well and be managed efficiently, Metal provides specialized data containers represented by ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLBuffer")," objects. This sample allocates a large amount of vertex data once, copies it into a ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLBuffer")," object, and then reuses the vertex data in each frame."),(0,i.kt)("p",null,"\u8fd9\u4e2a\u6848\u4f8b\u7701\u7565\u4e86\u4ece\u6a21\u578b\u4e2d\u52a0\u8f7d\u9876\u70b9\u4fe1\u606f\u7684\u8fc7\u7a0b\uff0c\u800c\u7528\u4e00\u4e2a\u6211\u4eec\u5b9a\u4e49\u7684\u65b9\u6cd5\u6765\u751f\u6210\uff0c\u5305\u88c5\u5728",(0,i.kt)("inlineCode",{parentName:"p"},"NSData"),"\u91cc\u3002In Objective-C, byte buffers are wrapped by ",(0,i.kt)("inlineCode",{parentName:"p"},"NSData")," objects. The complexity of model-loading code varies by model, but ultimately the vertex data is also stored in a byte buffer that\u2019s handed off to Metal code."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://developer.apple.com/documentation/metal/basic_texturing"},"Basic Texturing: Demonstrates how to load image data and texture a quad."))),(0,i.kt)("h2",{id:"texture"},"Texture"),(0,i.kt)("p",null,"In this sample, image data is loaded into a texture, applied to a single quad, and rendered as a 2D image. To populate a Metal texture with image data, its pixel data must already be formatted in a Metal-compatible pixel format, defined by a single ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLPixelFormat")," enumeration value."),(0,i.kt)("p",null,"The pixel format describes the layout of each of the texture\u2019s pixels (its ",(0,i.kt)("strong",{parentName:"p"},"texels"),")."),(0,i.kt)("p",null,"In this sample, for simplicity, the custom ",(0,i.kt)("inlineCode",{parentName:"p"},"AAPLImage")," class loads image data from a file (Image.tga) into memory (NSData)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MTLPixelFormatBGRA8Unorm")," indicates that each pixel has a blue, green, red, and alpha channel, where each channel is an 8-bit unsigned normalized value (i.e. 0 maps to 0.0 and 255 maps to 1.0)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MTLTexture")," objects are used specifically to store formatted image data."),(0,i.kt)("p",null,"Textures have known dimensions that can be interpreted as regions of pixels. A ",(0,i.kt)("inlineCode",{parentName:"p"},"MTLRegion")," structure is used to identify a specific ",(0,i.kt)("em",{parentName:"p"},"region")," of a texture."),(0,i.kt)("p",null,"A texture can\u2019t be rendered on its own; it must correspond to some geometric surface that\u2019s output by the vertex function and turned into fragments by the rasterizer. This relationship is defined by ",(0,i.kt)("strong",{parentName:"p"},"texture coordinates"),": floating-point positions that map locations on a texture image to locations on a geometric surface."),(0,i.kt)("p",null,"Reading a texel is also known as sampling. The fragment function uses the built-in texture ",(0,i.kt)("inlineCode",{parentName:"p"},"sample()")," function to sample texel data."))}m.isMDXComponent=!0}}]);