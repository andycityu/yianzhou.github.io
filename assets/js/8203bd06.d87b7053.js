"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6763],{74464:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>_,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=n(87462),s=(n(67294),n(3905));n(61839);const o={},r="Network Quality Estimator",a={unversionedId:"nqe",id:"nqe",title:"Network Quality Estimator",description:"",source:"@site/docs/dev/nqe.md",sourceDirName:".",slug:"/nqe",permalink:"/docs/dev/nqe",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"macOS",permalink:"/docs/dev/macos"},next:{title:"React",permalink:"/docs/dev/react"}},_={},l=[],c={toc:l};function h(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,i.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"network-quality-estimator"},"Network Quality Estimator"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"Observation(int32_t value, // RTT\n            base::TimeTicks timestamp, // \u65f6\u95f4\u6233\n            int32_t signal_strength, // \u4fe1\u53f7\u5f3a\u5ea6\n            NetworkQualityObservationSource source, // \u89c2\u6d4b\u6765\u6e90\uff08\u4f8b\u5982HTTP\u5c42\u3001TCP\u5c42\uff09\n            const absl::optional<IPHash>& host); // \u8bbf\u95ee\u7ad9\u70b9\n\n// \u8861\u91cf\u7f51\u7edc\u8d28\u91cf\nNetworkQuality(const base::TimeDelta& http_rtt,\n                const base::TimeDelta& transport_rtt,\n                int32_t downstream_throughput_kbps);\n\nCachedNetworkQuality(base::TimeTicks last_update_time,\n                    const NetworkQuality& network_quality,\n                    EffectiveConnectionType effective_connection_type); // 2/3/4G\n\nNetworkID(NetworkChangeNotifier::ConnectionType type, // 2/3/4G/WIFI\n            const std::string& id,\n            int32_t signal_strength);\n\nclass NetworkQualityStore {\n    void Add(const nqe::internal::NetworkID& network_id,\n           const nqe::internal::CachedNetworkQuality& cached_network_quality);\n}\n\ndouble GetWeightMultiplierPerSecond(\n    const std::map<std::string, std::string>& params) {\n  // \u7528\u4e8e\u8ba1\u7b97\u65f6\u95f4\u52a0\u6743\u767e\u5206\u4f4d\u6570\u7684\u534a\u8870\u671f\u9ed8\u8ba4\u503c\uff08\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff09\u3002\u6bcf\u4e2a\u534a\u8870\u671f\uff0c\u6240\u6709\u89c2\u6d4b\u503c\u7684\u6743\u91cd\u90fd\u4f1a\u51cf\u5c11\u4e00\u534a\u3002\u964d\u4f4e\u534a\u8870\u671f\u4f1a\u66f4\u5feb\u5730\u51cf\u5c11\u65e7\u503c\u7684\u6743\u91cd\u3002\n  // \u6743\u91cd\u7684\u9ed8\u8ba4\u534a\u8870\u671f\u4e3a60\u79d2\n  int half_life_seconds = 60;\n  return pow(0.5, 1.0 / half_life_seconds);\n}\n\nvoid ObservationBuffer::ComputeWeightedObservations(\n    const base::TimeTicks& begin_timestamp,\n    int32_t current_signal_strength,\n    std::vector<WeightedObservation>* weighted_observations,\n    double* total_weight) const {\n    // \u904d\u5386\u6240\u6709\u5386\u53f2\u89c2\u6d4b\u6570\u636e\n    for (const auto& observation : observations_) {\n        if (observation.timestamp() < begin_timestamp)\n        continue; // \u53ea\u8003\u8651\u6307\u5b9a\u65f6\u95f4\u6233\u4e4b\u540e\u7684\u6570\u636e\n\n        base::TimeDelta time_since_sample_taken = now - observation.timestamp();\n        // \u9ed8\u8ba4\u534a\u8870\u671f\u4e3a\u4e00\u5206\u949f\uff0c\u8ddd\u79bb\u5f53\u524d\u65f6\u95f4\u6233\u8d8a\u8fdc\u7684\u89c2\u6d4b\u70b9\uff0c\u8870\u51cf\u8d8a\u591a\uff0c\u6743\u91cd\u8d8a\u4f4e\n        double time_weight =\n            pow(weight_multiplier_per_second_, time_since_sample_taken.InSeconds());\n\n        double signal_strength_weight = 1.0;\n        if (current_signal_strength >= 0 && observation.signal_strength() >= 0) {\n        int32_t signal_strength_weight_diff =\n            std::abs(current_signal_strength - observation.signal_strength());\n        // \u4e0e\u5f53\u524d\u4fe1\u53f7\u5f3a\u5ea6\u5dee\u5f02\u8d8a\u5927\u7684\u89c2\u6d4b\u70b9\uff0c\u6743\u91cd\u8d8a\u4f4e\n        // weight_multiplier_per_signal_level_\u662f\u4e00\u4e2a[0,1]\u4e4b\u95f4\u7684\u6570\n        signal_strength_weight =\n            pow(weight_multiplier_per_signal_level_, signal_strength_weight_diff);\n        }\n\n        // \u65f6\u95f4\u6743\u91cd * \u4fe1\u53f7\u6743\u91cd\n        double weight = time_weight * signal_strength_weight;\n        weight = std::clamp(weight, DBL_MIN, 1.0);\n\n        weighted_observations->push_back(\n            WeightedObservation(observation.value(), weight));\n        total_weight_observations += weight;\n  }\n}\n\n// 50\u767e\u5206\u4f4d\u7684RTT\u662f\u591a\u5c11\n// 70\u767e\u5206\u4f4d\u7684RTT\u662f\u591a\u5c11\nabsl::optional<int32_t> ObservationBuffer::GetPercentile(\n    base::TimeTicks begin_timestamp,\n    int32_t current_signal_strength,\n    int percentile,\n    size_t* observations_count) const {\n    // Stores weighted observations in increasing order by value.\n    // value\u5c31\u662fRTT\uff0cRTT\u8d8a\u5927\uff0c\u4ee3\u8868\u7f51\u7edc\u6027\u80fd\u8d8a\u5dee\n    std::vector<WeightedObservation> weighted_observations;\n    // Total weight of all observations in |weighted_observations|.\n    double total_weight = 0.0;\n    ComputeWeightedObservations(begin_timestamp, current_signal_strength,\n                              &weighted_observations, &total_weight);\n    double desired_weight = percentile / 100.0 * total_weight;\n    double cumulative_weight_seen_so_far = 0.0;\n    for (const auto& weighted_observation : weighted_observations) {\n        cumulative_weight_seen_so_far += weighted_observation.weight;\n        if (cumulative_weight_seen_so_far >= desired_weight)\n            return weighted_observation.value;\n    }\n}\n\n// \u8fd4\u56de\u6307\u5b9a\u767e\u5206\u4f4d\u5904\u7684\u7f51\u7edc\u8d28\u91cf\u4f30\u8ba1\u503c\u3002\n// \u4ec5\u665a\u4e8e |start_time| \u7684\u89c2\u5bdf\u7ed3\u679c\u88ab\u8003\u8651\u5728\u5185\u3002\n// \u767e\u5206\u4f4d\u6570\u8d8a\u9ad8\u8868\u793a\u7f51\u7edc\u6027\u80fd\u8f83\u5dee\u3002\u4f8b\u5982\uff0c\u5982\u679c\u767e\u5206\u4f4d\u662f 90\uff0c\u90a3\u4e48\u7f51\u7edc\u9884\u8ba1\u4f1a\u6709 0.9 \u7684\u6982\u7387\u6bd4\u8fd4\u56de\u7684RTT\u66f4\u5feb\u3002\nvirtual base::TimeDelta GetRTTEstimateInternal(\n    base::TimeTicks start_time,\n    nqe::internal::ObservationCategory observation_category,\n    int percentile,\n    size_t* observations_count) const {\n    return base::Milliseconds(\n          rtt_ms_observations_[observation_category]\n              .GetPercentile(start_time, current_network_id_.signal_strength,\n                             percentile, observations_count)\n              .value_or(nqe::internal::INVALID_RTT_THROUGHPUT));\n}\n\nint32_t NetworkQualityEstimator::GetDownlinkThroughputKbpsEstimateInternal(\n    const base::TimeTicks& start_time,\n    int percentile) const {\n  // Throughput observations are sorted by kbps from slowest to fastest,\n  // thus a higher percentile throughput will be faster than a lower one.\n  return http_downstream_throughput_kbps_observations_\n      .GetPercentile(start_time, current_network_id_.signal_strength,\n                     100 - percentile, nullptr)\n      .value_or(nqe::internal::INVALID_RTT_THROUGHPUT);\n}\n\nbool NetworkQualityEstimator::GetRecentRTT(\n    nqe::internal::ObservationCategory observation_category,\n    const base::TimeTicks& start_time,\n    base::TimeDelta* rtt,\n    size_t* observations_count) const {\n  // 50\u767e\u5206\u4f4d\n  *rtt = GetRTTEstimateInternal(start_time, observation_category, 50,\n                                observations_count);\n  return (*rtt != nqe::internal::InvalidRTT());\n}\n\nEffectiveConnectionType\nNetworkQualityEstimator::GetRecentEffectiveConnectionTypeUsingMetrics(\n    base::TimeDelta* http_rtt,\n    base::TimeDelta* transport_rtt,\n    base::TimeDelta* end_to_end_rtt,\n    int32_t* downstream_throughput_kbps,\n    size_t* transport_rtt_observation_count,\n    size_t* end_to_end_rtt_observation_count) const {\n  GetRecentRTT(nqe::internal::OBSERVATION_CATEGORY_HTTP, base::TimeTicks(),\n                    http_rtt, nullptr));\n\n  GetRecentRTT(nqe::internal::OBSERVATION_CATEGORY_TRANSPORT,\n                    base::TimeTicks(), transport_rtt,\n                    transport_rtt_observation_count));\n\n  iGetRecentRTT(nqe::internal::OBSERVATION_CATEGORY_END_TO_END,\n                    base::TimeTicks(), end_to_end_rtt,\n                    end_to_end_rtt_observation_count));\n\n  UpdateHttpRttUsingAllRttValues(http_rtt, *transport_rtt, *end_to_end_rtt);\n\n  GetRecentDownlinkThroughputKbps(base::TimeTicks(),\n                                       downstream_throughput_kbps));\n\n  // Search from the slowest connection type to the fastest to find the\n  // EffectiveConnectionType that best matches the current connection's\n  // performance. The match is done by comparing RTT and throughput.\n  for (size_t i = 0; i < EFFECTIVE_CONNECTION_TYPE_LAST; ++i) {\n    EffectiveConnectionType type = static_cast<EffectiveConnectionType>(i);\n    const bool estimated_http_rtt_is_higher_than_threshold =\n        *http_rtt >= params_->ConnectionThreshold(type).http_rtt();\n    if (estimated_http_rtt_is_higher_than_threshold)\n      return type;\n  }\n}\n")))}h.isMDXComponent=!0}}]);